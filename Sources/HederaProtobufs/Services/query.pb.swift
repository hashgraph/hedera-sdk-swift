// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A single query, which is sent from the client to a node. This includes all possible queries. Each
/// Query should not have more than 50 levels.
public struct Proto_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: Proto_Query.OneOf_Query? = nil

  ///*
  /// Get all entities associated with a given key
  public var getByKey: Proto_GetByKeyQuery {
    get {
      if case .getByKey(let v)? = query {return v}
      return Proto_GetByKeyQuery()
    }
    set {query = .getByKey(newValue)}
  }

  ///*
  /// Get the IDs in the format used in transactions, given the format used in Solidity
  public var getBySolidityID: Proto_GetBySolidityIDQuery {
    get {
      if case .getBySolidityID(let v)? = query {return v}
      return Proto_GetBySolidityIDQuery()
    }
    set {query = .getBySolidityID(newValue)}
  }

  ///*
  /// Call a function of a smart contract instance
  public var contractCallLocal: Proto_ContractCallLocalQuery {
    get {
      if case .contractCallLocal(let v)? = query {return v}
      return Proto_ContractCallLocalQuery()
    }
    set {query = .contractCallLocal(newValue)}
  }

  ///*
  /// Get information about a smart contract instance
  public var contractGetInfo: Proto_ContractGetInfoQuery {
    get {
      if case .contractGetInfo(let v)? = query {return v}
      return Proto_ContractGetInfoQuery()
    }
    set {query = .contractGetInfo(newValue)}
  }

  ///*
  /// Get runtime code used by a smart contract instance
  public var contractGetBytecode: Proto_ContractGetBytecodeQuery {
    get {
      if case .contractGetBytecode(let v)? = query {return v}
      return Proto_ContractGetBytecodeQuery()
    }
    set {query = .contractGetBytecode(newValue)}
  }

  ///*
  /// Get Records of the contract instance
  public var contractGetRecords: Proto_ContractGetRecordsQuery {
    get {
      if case .contractGetRecords(let v)? = query {return v}
      return Proto_ContractGetRecordsQuery()
    }
    set {query = .contractGetRecords(newValue)}
  }

  ///*
  /// Get the current balance in a cryptocurrency account
  public var cryptogetAccountBalance: Proto_CryptoGetAccountBalanceQuery {
    get {
      if case .cryptogetAccountBalance(let v)? = query {return v}
      return Proto_CryptoGetAccountBalanceQuery()
    }
    set {query = .cryptogetAccountBalance(newValue)}
  }

  ///*
  /// Get all the records that currently exist for transactions involving an account
  public var cryptoGetAccountRecords: Proto_CryptoGetAccountRecordsQuery {
    get {
      if case .cryptoGetAccountRecords(let v)? = query {return v}
      return Proto_CryptoGetAccountRecordsQuery()
    }
    set {query = .cryptoGetAccountRecords(newValue)}
  }

  ///*
  /// Get all information about an account
  public var cryptoGetInfo: Proto_CryptoGetInfoQuery {
    get {
      if case .cryptoGetInfo(let v)? = query {return v}
      return Proto_CryptoGetInfoQuery()
    }
    set {query = .cryptoGetInfo(newValue)}
  }

  ///*
  /// Get a single livehash from a single account, if present
  public var cryptoGetLiveHash: Proto_CryptoGetLiveHashQuery {
    get {
      if case .cryptoGetLiveHash(let v)? = query {return v}
      return Proto_CryptoGetLiveHashQuery()
    }
    set {query = .cryptoGetLiveHash(newValue)}
  }

  ///*
  /// Get all the accounts that proxy stake to a given account, and how much they proxy stake
  /// (not yet implemented in the current API)
  public var cryptoGetProxyStakers: Proto_CryptoGetStakersQuery {
    get {
      if case .cryptoGetProxyStakers(let v)? = query {return v}
      return Proto_CryptoGetStakersQuery()
    }
    set {query = .cryptoGetProxyStakers(newValue)}
  }

  ///*
  /// Get the contents of a file (the bytes stored in it)
  public var fileGetContents: Proto_FileGetContentsQuery {
    get {
      if case .fileGetContents(let v)? = query {return v}
      return Proto_FileGetContentsQuery()
    }
    set {query = .fileGetContents(newValue)}
  }

  ///*
  /// Get information about a file, such as its expiration date
  public var fileGetInfo: Proto_FileGetInfoQuery {
    get {
      if case .fileGetInfo(let v)? = query {return v}
      return Proto_FileGetInfoQuery()
    }
    set {query = .fileGetInfo(newValue)}
  }

  ///*
  /// Get a receipt for a transaction (lasts 180 seconds)
  public var transactionGetReceipt: Proto_TransactionGetReceiptQuery {
    get {
      if case .transactionGetReceipt(let v)? = query {return v}
      return Proto_TransactionGetReceiptQuery()
    }
    set {query = .transactionGetReceipt(newValue)}
  }

  ///*
  /// Get a record for a transaction
  public var transactionGetRecord: Proto_TransactionGetRecordQuery {
    get {
      if case .transactionGetRecord(let v)? = query {return v}
      return Proto_TransactionGetRecordQuery()
    }
    set {query = .transactionGetRecord(newValue)}
  }

  ///*
  /// Get a record for a transaction (lasts 180 seconds)
  public var transactionGetFastRecord: Proto_TransactionGetFastRecordQuery {
    get {
      if case .transactionGetFastRecord(let v)? = query {return v}
      return Proto_TransactionGetFastRecordQuery()
    }
    set {query = .transactionGetFastRecord(newValue)}
  }

  ///*
  /// Get the parameters of and state of a consensus topic.
  public var consensusGetTopicInfo: Proto_ConsensusGetTopicInfoQuery {
    get {
      if case .consensusGetTopicInfo(let v)? = query {return v}
      return Proto_ConsensusGetTopicInfoQuery()
    }
    set {query = .consensusGetTopicInfo(newValue)}
  }

  ///*
  /// Get the versions of the HAPI protobuf and Hedera Services software deployed on the
  /// responding node.
  public var networkGetVersionInfo: Proto_NetworkGetVersionInfoQuery {
    get {
      if case .networkGetVersionInfo(let v)? = query {return v}
      return Proto_NetworkGetVersionInfoQuery()
    }
    set {query = .networkGetVersionInfo(newValue)}
  }

  ///*
  /// Get all information about a token
  public var tokenGetInfo: Proto_TokenGetInfoQuery {
    get {
      if case .tokenGetInfo(let v)? = query {return v}
      return Proto_TokenGetInfoQuery()
    }
    set {query = .tokenGetInfo(newValue)}
  }

  ///*
  /// Get all information about a scheduled entity
  public var scheduleGetInfo: Proto_ScheduleGetInfoQuery {
    get {
      if case .scheduleGetInfo(let v)? = query {return v}
      return Proto_ScheduleGetInfoQuery()
    }
    set {query = .scheduleGetInfo(newValue)}
  }

  ///*
  /// Get a list of NFTs associated with the account
  public var tokenGetAccountNftInfos: Proto_TokenGetAccountNftInfosQuery {
    get {
      if case .tokenGetAccountNftInfos(let v)? = query {return v}
      return Proto_TokenGetAccountNftInfosQuery()
    }
    set {query = .tokenGetAccountNftInfos(newValue)}
  }

  ///*
  /// Get all information about a NFT
  public var tokenGetNftInfo: Proto_TokenGetNftInfoQuery {
    get {
      if case .tokenGetNftInfo(let v)? = query {return v}
      return Proto_TokenGetNftInfoQuery()
    }
    set {query = .tokenGetNftInfo(newValue)}
  }

  ///*
  /// Get a list of NFTs for the token
  public var tokenGetNftInfos: Proto_TokenGetNftInfosQuery {
    get {
      if case .tokenGetNftInfos(let v)? = query {return v}
      return Proto_TokenGetNftInfosQuery()
    }
    set {query = .tokenGetNftInfos(newValue)}
  }

  ///*
  /// Gets <tt>handleTransaction</tt> times for one or more "sufficiently recent" TransactionIDs
  public var networkGetExecutionTime: Proto_NetworkGetExecutionTimeQuery {
    get {
      if case .networkGetExecutionTime(let v)? = query {return v}
      return Proto_NetworkGetExecutionTimeQuery()
    }
    set {query = .networkGetExecutionTime(newValue)}
  }

  ///*
  /// Gets all information about an account including allowances granted by the account
  public var accountDetails: Proto_GetAccountDetailsQuery {
    get {
      if case .accountDetails(let v)? = query {return v}
      return Proto_GetAccountDetailsQuery()
    }
    set {query = .accountDetails(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Query: Equatable {
    ///*
    /// Get all entities associated with a given key
    case getByKey(Proto_GetByKeyQuery)
    ///*
    /// Get the IDs in the format used in transactions, given the format used in Solidity
    case getBySolidityID(Proto_GetBySolidityIDQuery)
    ///*
    /// Call a function of a smart contract instance
    case contractCallLocal(Proto_ContractCallLocalQuery)
    ///*
    /// Get information about a smart contract instance
    case contractGetInfo(Proto_ContractGetInfoQuery)
    ///*
    /// Get runtime code used by a smart contract instance
    case contractGetBytecode(Proto_ContractGetBytecodeQuery)
    ///*
    /// Get Records of the contract instance
    case contractGetRecords(Proto_ContractGetRecordsQuery)
    ///*
    /// Get the current balance in a cryptocurrency account
    case cryptogetAccountBalance(Proto_CryptoGetAccountBalanceQuery)
    ///*
    /// Get all the records that currently exist for transactions involving an account
    case cryptoGetAccountRecords(Proto_CryptoGetAccountRecordsQuery)
    ///*
    /// Get all information about an account
    case cryptoGetInfo(Proto_CryptoGetInfoQuery)
    ///*
    /// Get a single livehash from a single account, if present
    case cryptoGetLiveHash(Proto_CryptoGetLiveHashQuery)
    ///*
    /// Get all the accounts that proxy stake to a given account, and how much they proxy stake
    /// (not yet implemented in the current API)
    case cryptoGetProxyStakers(Proto_CryptoGetStakersQuery)
    ///*
    /// Get the contents of a file (the bytes stored in it)
    case fileGetContents(Proto_FileGetContentsQuery)
    ///*
    /// Get information about a file, such as its expiration date
    case fileGetInfo(Proto_FileGetInfoQuery)
    ///*
    /// Get a receipt for a transaction (lasts 180 seconds)
    case transactionGetReceipt(Proto_TransactionGetReceiptQuery)
    ///*
    /// Get a record for a transaction
    case transactionGetRecord(Proto_TransactionGetRecordQuery)
    ///*
    /// Get a record for a transaction (lasts 180 seconds)
    case transactionGetFastRecord(Proto_TransactionGetFastRecordQuery)
    ///*
    /// Get the parameters of and state of a consensus topic.
    case consensusGetTopicInfo(Proto_ConsensusGetTopicInfoQuery)
    ///*
    /// Get the versions of the HAPI protobuf and Hedera Services software deployed on the
    /// responding node.
    case networkGetVersionInfo(Proto_NetworkGetVersionInfoQuery)
    ///*
    /// Get all information about a token
    case tokenGetInfo(Proto_TokenGetInfoQuery)
    ///*
    /// Get all information about a scheduled entity
    case scheduleGetInfo(Proto_ScheduleGetInfoQuery)
    ///*
    /// Get a list of NFTs associated with the account
    case tokenGetAccountNftInfos(Proto_TokenGetAccountNftInfosQuery)
    ///*
    /// Get all information about a NFT
    case tokenGetNftInfo(Proto_TokenGetNftInfoQuery)
    ///*
    /// Get a list of NFTs for the token
    case tokenGetNftInfos(Proto_TokenGetNftInfosQuery)
    ///*
    /// Gets <tt>handleTransaction</tt> times for one or more "sufficiently recent" TransactionIDs
    case networkGetExecutionTime(Proto_NetworkGetExecutionTimeQuery)
    ///*
    /// Gets all information about an account including allowances granted by the account
    case accountDetails(Proto_GetAccountDetailsQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_Query.OneOf_Query, rhs: Proto_Query.OneOf_Query) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getByKey, .getByKey): return {
        guard case .getByKey(let l) = lhs, case .getByKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getBySolidityID, .getBySolidityID): return {
        guard case .getBySolidityID(let l) = lhs, case .getBySolidityID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractCallLocal, .contractCallLocal): return {
        guard case .contractCallLocal(let l) = lhs, case .contractCallLocal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractGetInfo, .contractGetInfo): return {
        guard case .contractGetInfo(let l) = lhs, case .contractGetInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractGetBytecode, .contractGetBytecode): return {
        guard case .contractGetBytecode(let l) = lhs, case .contractGetBytecode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractGetRecords, .contractGetRecords): return {
        guard case .contractGetRecords(let l) = lhs, case .contractGetRecords(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptogetAccountBalance, .cryptogetAccountBalance): return {
        guard case .cryptogetAccountBalance(let l) = lhs, case .cryptogetAccountBalance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoGetAccountRecords, .cryptoGetAccountRecords): return {
        guard case .cryptoGetAccountRecords(let l) = lhs, case .cryptoGetAccountRecords(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoGetInfo, .cryptoGetInfo): return {
        guard case .cryptoGetInfo(let l) = lhs, case .cryptoGetInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoGetLiveHash, .cryptoGetLiveHash): return {
        guard case .cryptoGetLiveHash(let l) = lhs, case .cryptoGetLiveHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoGetProxyStakers, .cryptoGetProxyStakers): return {
        guard case .cryptoGetProxyStakers(let l) = lhs, case .cryptoGetProxyStakers(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileGetContents, .fileGetContents): return {
        guard case .fileGetContents(let l) = lhs, case .fileGetContents(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileGetInfo, .fileGetInfo): return {
        guard case .fileGetInfo(let l) = lhs, case .fileGetInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transactionGetReceipt, .transactionGetReceipt): return {
        guard case .transactionGetReceipt(let l) = lhs, case .transactionGetReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transactionGetRecord, .transactionGetRecord): return {
        guard case .transactionGetRecord(let l) = lhs, case .transactionGetRecord(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transactionGetFastRecord, .transactionGetFastRecord): return {
        guard case .transactionGetFastRecord(let l) = lhs, case .transactionGetFastRecord(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.consensusGetTopicInfo, .consensusGetTopicInfo): return {
        guard case .consensusGetTopicInfo(let l) = lhs, case .consensusGetTopicInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.networkGetVersionInfo, .networkGetVersionInfo): return {
        guard case .networkGetVersionInfo(let l) = lhs, case .networkGetVersionInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenGetInfo, .tokenGetInfo): return {
        guard case .tokenGetInfo(let l) = lhs, case .tokenGetInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scheduleGetInfo, .scheduleGetInfo): return {
        guard case .scheduleGetInfo(let l) = lhs, case .scheduleGetInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenGetAccountNftInfos, .tokenGetAccountNftInfos): return {
        guard case .tokenGetAccountNftInfos(let l) = lhs, case .tokenGetAccountNftInfos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenGetNftInfo, .tokenGetNftInfo): return {
        guard case .tokenGetNftInfo(let l) = lhs, case .tokenGetNftInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenGetNftInfos, .tokenGetNftInfos): return {
        guard case .tokenGetNftInfos(let l) = lhs, case .tokenGetNftInfos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.networkGetExecutionTime, .networkGetExecutionTime): return {
        guard case .networkGetExecutionTime(let l) = lhs, case .networkGetExecutionTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accountDetails, .accountDetails): return {
        guard case .accountDetails(let l) = lhs, case .accountDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_Query: @unchecked Sendable {}
extension Proto_Query.OneOf_Query: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Query"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getByKey"),
    2: .same(proto: "getBySolidityID"),
    3: .same(proto: "contractCallLocal"),
    4: .same(proto: "contractGetInfo"),
    5: .same(proto: "contractGetBytecode"),
    6: .same(proto: "ContractGetRecords"),
    7: .same(proto: "cryptogetAccountBalance"),
    8: .same(proto: "cryptoGetAccountRecords"),
    9: .same(proto: "cryptoGetInfo"),
    10: .same(proto: "cryptoGetLiveHash"),
    11: .same(proto: "cryptoGetProxyStakers"),
    12: .same(proto: "fileGetContents"),
    13: .same(proto: "fileGetInfo"),
    14: .same(proto: "transactionGetReceipt"),
    15: .same(proto: "transactionGetRecord"),
    16: .same(proto: "transactionGetFastRecord"),
    50: .same(proto: "consensusGetTopicInfo"),
    51: .same(proto: "networkGetVersionInfo"),
    52: .same(proto: "tokenGetInfo"),
    53: .same(proto: "scheduleGetInfo"),
    54: .same(proto: "tokenGetAccountNftInfos"),
    55: .same(proto: "tokenGetNftInfo"),
    56: .same(proto: "tokenGetNftInfos"),
    57: .same(proto: "networkGetExecutionTime"),
    58: .same(proto: "accountDetails"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_GetByKeyQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .getByKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .getByKey(v)
        }
      }()
      case 2: try {
        var v: Proto_GetBySolidityIDQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .getBySolidityID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .getBySolidityID(v)
        }
      }()
      case 3: try {
        var v: Proto_ContractCallLocalQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .contractCallLocal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .contractCallLocal(v)
        }
      }()
      case 4: try {
        var v: Proto_ContractGetInfoQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .contractGetInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .contractGetInfo(v)
        }
      }()
      case 5: try {
        var v: Proto_ContractGetBytecodeQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .contractGetBytecode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .contractGetBytecode(v)
        }
      }()
      case 6: try {
        var v: Proto_ContractGetRecordsQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .contractGetRecords(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .contractGetRecords(v)
        }
      }()
      case 7: try {
        var v: Proto_CryptoGetAccountBalanceQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .cryptogetAccountBalance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .cryptogetAccountBalance(v)
        }
      }()
      case 8: try {
        var v: Proto_CryptoGetAccountRecordsQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .cryptoGetAccountRecords(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .cryptoGetAccountRecords(v)
        }
      }()
      case 9: try {
        var v: Proto_CryptoGetInfoQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .cryptoGetInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .cryptoGetInfo(v)
        }
      }()
      case 10: try {
        var v: Proto_CryptoGetLiveHashQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .cryptoGetLiveHash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .cryptoGetLiveHash(v)
        }
      }()
      case 11: try {
        var v: Proto_CryptoGetStakersQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .cryptoGetProxyStakers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .cryptoGetProxyStakers(v)
        }
      }()
      case 12: try {
        var v: Proto_FileGetContentsQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .fileGetContents(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .fileGetContents(v)
        }
      }()
      case 13: try {
        var v: Proto_FileGetInfoQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .fileGetInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .fileGetInfo(v)
        }
      }()
      case 14: try {
        var v: Proto_TransactionGetReceiptQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .transactionGetReceipt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .transactionGetReceipt(v)
        }
      }()
      case 15: try {
        var v: Proto_TransactionGetRecordQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .transactionGetRecord(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .transactionGetRecord(v)
        }
      }()
      case 16: try {
        var v: Proto_TransactionGetFastRecordQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .transactionGetFastRecord(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .transactionGetFastRecord(v)
        }
      }()
      case 50: try {
        var v: Proto_ConsensusGetTopicInfoQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .consensusGetTopicInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .consensusGetTopicInfo(v)
        }
      }()
      case 51: try {
        var v: Proto_NetworkGetVersionInfoQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .networkGetVersionInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .networkGetVersionInfo(v)
        }
      }()
      case 52: try {
        var v: Proto_TokenGetInfoQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .tokenGetInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .tokenGetInfo(v)
        }
      }()
      case 53: try {
        var v: Proto_ScheduleGetInfoQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .scheduleGetInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .scheduleGetInfo(v)
        }
      }()
      case 54: try {
        var v: Proto_TokenGetAccountNftInfosQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .tokenGetAccountNftInfos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .tokenGetAccountNftInfos(v)
        }
      }()
      case 55: try {
        var v: Proto_TokenGetNftInfoQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .tokenGetNftInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .tokenGetNftInfo(v)
        }
      }()
      case 56: try {
        var v: Proto_TokenGetNftInfosQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .tokenGetNftInfos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .tokenGetNftInfos(v)
        }
      }()
      case 57: try {
        var v: Proto_NetworkGetExecutionTimeQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .networkGetExecutionTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .networkGetExecutionTime(v)
        }
      }()
      case 58: try {
        var v: Proto_GetAccountDetailsQuery?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .accountDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .accountDetails(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.query {
    case .getByKey?: try {
      guard case .getByKey(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getBySolidityID?: try {
      guard case .getBySolidityID(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .contractCallLocal?: try {
      guard case .contractCallLocal(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .contractGetInfo?: try {
      guard case .contractGetInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .contractGetBytecode?: try {
      guard case .contractGetBytecode(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .contractGetRecords?: try {
      guard case .contractGetRecords(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .cryptogetAccountBalance?: try {
      guard case .cryptogetAccountBalance(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .cryptoGetAccountRecords?: try {
      guard case .cryptoGetAccountRecords(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .cryptoGetInfo?: try {
      guard case .cryptoGetInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .cryptoGetLiveHash?: try {
      guard case .cryptoGetLiveHash(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .cryptoGetProxyStakers?: try {
      guard case .cryptoGetProxyStakers(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .fileGetContents?: try {
      guard case .fileGetContents(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .fileGetInfo?: try {
      guard case .fileGetInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .transactionGetReceipt?: try {
      guard case .transactionGetReceipt(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .transactionGetRecord?: try {
      guard case .transactionGetRecord(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .transactionGetFastRecord?: try {
      guard case .transactionGetFastRecord(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .consensusGetTopicInfo?: try {
      guard case .consensusGetTopicInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .networkGetVersionInfo?: try {
      guard case .networkGetVersionInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .tokenGetInfo?: try {
      guard case .tokenGetInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .scheduleGetInfo?: try {
      guard case .scheduleGetInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .tokenGetAccountNftInfos?: try {
      guard case .tokenGetAccountNftInfos(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .tokenGetNftInfo?: try {
      guard case .tokenGetNftInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .tokenGetNftInfos?: try {
      guard case .tokenGetNftInfos(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .networkGetExecutionTime?: try {
      guard case .networkGetExecutionTime(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .accountDetails?: try {
      guard case .accountDetails(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Query, rhs: Proto_Query) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
