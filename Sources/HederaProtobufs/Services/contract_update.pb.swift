// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: contract_update.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// At consensus, updates the fields of a smart contract to the given values.
///
/// If no value is given for a field, that field is left unchanged on the contract. For an immutable
/// smart contract (that is, a contract created without an adminKey), only the expirationTime may be
/// updated; setting any other field in this case will cause the transaction status to resolve to
/// MODIFYING_IMMUTABLE_CONTRACT.
///
/// --- Signing Requirements ---
/// 1. Whether or not a contract has an admin key, its expiry can be extended with only the
///    transaction payer's signature.
/// 2. Updating any other field of a mutable contract requires the admin key's signature.
/// 3. If the update transaction includes a new admin key, this new key must also sign <b>unless</b>
///    it is exactly an empty <tt>KeyList</tt>. This special sentinel key removes the existing admin
///    key and causes the contract to become immutable. (Other <tt>Key</tt> structures without a
///    constituent <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
/// 4. If the update transaction sets the AccountID auto_renew_account_id wrapper field to anything
///    other than the sentinel <tt>0.0.0</tt> value, then the key of the referenced account must sign.
public struct Proto_ContractUpdateTransactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The id of the contract to be updated
  public var contractID: Proto_ContractID {
    get {return _storage._contractID ?? Proto_ContractID()}
    set {_uniqueStorage()._contractID = newValue}
  }
  /// Returns true if `contractID` has been explicitly set.
  public var hasContractID: Bool {return _storage._contractID != nil}
  /// Clears the value of `contractID`. Subsequent reads from it will return its default value.
  public mutating func clearContractID() {_uniqueStorage()._contractID = nil}

  ///*
  /// The new expiry of the contract, no earlier than the current expiry (resolves to
  /// EXPIRATION_REDUCTION_NOT_ALLOWED otherwise)
  public var expirationTime: Proto_Timestamp {
    get {return _storage._expirationTime ?? Proto_Timestamp()}
    set {_uniqueStorage()._expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  public var hasExpirationTime: Bool {return _storage._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

  ///*
  /// The new key to control updates to the contract
  public var adminKey: Proto_Key {
    get {return _storage._adminKey ?? Proto_Key()}
    set {_uniqueStorage()._adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return _storage._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {_uniqueStorage()._adminKey = nil}

  ///*
  /// [Deprecated] The new id of the account to which the contract is proxy staked
  public var proxyAccountID: Proto_AccountID {
    get {return _storage._proxyAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._proxyAccountID = newValue}
  }
  /// Returns true if `proxyAccountID` has been explicitly set.
  public var hasProxyAccountID: Bool {return _storage._proxyAccountID != nil}
  /// Clears the value of `proxyAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearProxyAccountID() {_uniqueStorage()._proxyAccountID = nil}

  ///*
  /// If an auto-renew account is in use, the lifetime to be added by each auto-renewal.
  public var autoRenewPeriod: Proto_Duration {
    get {return _storage._autoRenewPeriod ?? Proto_Duration()}
    set {_uniqueStorage()._autoRenewPeriod = newValue}
  }
  /// Returns true if `autoRenewPeriod` has been explicitly set.
  public var hasAutoRenewPeriod: Bool {return _storage._autoRenewPeriod != nil}
  /// Clears the value of `autoRenewPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewPeriod() {_uniqueStorage()._autoRenewPeriod = nil}

  ///*
  /// This field is unused and will have no impact on the specified smart contract.
  public var fileID: Proto_FileID {
    get {return _storage._fileID ?? Proto_FileID()}
    set {_uniqueStorage()._fileID = newValue}
  }
  /// Returns true if `fileID` has been explicitly set.
  public var hasFileID: Bool {return _storage._fileID != nil}
  /// Clears the value of `fileID`. Subsequent reads from it will return its default value.
  public mutating func clearFileID() {_uniqueStorage()._fileID = nil}

  ///*
  /// The new contract memo, assumed to be Unicode encoded with UTF-8 (at most 100 bytes)
  public var memoField: OneOf_MemoField? {
    get {return _storage._memoField}
    set {_uniqueStorage()._memoField = newValue}
  }

  ///*
  /// [Deprecated] If set with a non-zero length, the new memo to be associated with the account
  /// (UTF-8 encoding max 100 bytes)
  public var memo: String {
    get {
      if case .memo(let v)? = _storage._memoField {return v}
      return String()
    }
    set {_uniqueStorage()._memoField = .memo(newValue)}
  }

  ///*
  /// If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
  public var memoWrapper: SwiftProtobuf.Google_Protobuf_StringValue {
    get {
      if case .memoWrapper(let v)? = _storage._memoField {return v}
      return SwiftProtobuf.Google_Protobuf_StringValue()
    }
    set {_uniqueStorage()._memoField = .memoWrapper(newValue)}
  }

  ///*
  /// If set, the new maximum number of tokens that this contract can be
  /// automatically associated with (i.e., receive air-drops from).
  public var maxAutomaticTokenAssociations: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._maxAutomaticTokenAssociations ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._maxAutomaticTokenAssociations = newValue}
  }
  /// Returns true if `maxAutomaticTokenAssociations` has been explicitly set.
  public var hasMaxAutomaticTokenAssociations: Bool {return _storage._maxAutomaticTokenAssociations != nil}
  /// Clears the value of `maxAutomaticTokenAssociations`. Subsequent reads from it will return its default value.
  public mutating func clearMaxAutomaticTokenAssociations() {_uniqueStorage()._maxAutomaticTokenAssociations = nil}

  ///*
  /// If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
  /// account. Otherwise it updates the contract's auto-renew account to the referenced account.
  public var autoRenewAccountID: Proto_AccountID {
    get {return _storage._autoRenewAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._autoRenewAccountID = newValue}
  }
  /// Returns true if `autoRenewAccountID` has been explicitly set.
  public var hasAutoRenewAccountID: Bool {return _storage._autoRenewAccountID != nil}
  /// Clears the value of `autoRenewAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewAccountID() {_uniqueStorage()._autoRenewAccountID = nil}

  ///*
  /// ID of the new account or node to which this contract is staking.
  public var stakedID: OneOf_StakedID? {
    get {return _storage._stakedID}
    set {_uniqueStorage()._stakedID = newValue}
  }

  ///*
  /// ID of the new account to which this contract is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
  /// this field removes the contract's staked account ID.
  public var stakedAccountID: Proto_AccountID {
    get {
      if case .stakedAccountID(let v)? = _storage._stakedID {return v}
      return Proto_AccountID()
    }
    set {_uniqueStorage()._stakedID = .stakedAccountID(newValue)}
  }

  ///*
  /// ID of the new node this contract is staked to. If set to the sentinel <tt>-1</tt>, this field
  /// removes the contract's staked node ID.
  public var stakedNodeID: Int64 {
    get {
      if case .stakedNodeID(let v)? = _storage._stakedID {return v}
      return 0
    }
    set {_uniqueStorage()._stakedID = .stakedNodeID(newValue)}
  }

  ///*
  /// If true, the contract declines receiving a staking reward.
  public var declineReward: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._declineReward ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._declineReward = newValue}
  }
  /// Returns true if `declineReward` has been explicitly set.
  public var hasDeclineReward: Bool {return _storage._declineReward != nil}
  /// Clears the value of `declineReward`. Subsequent reads from it will return its default value.
  public mutating func clearDeclineReward() {_uniqueStorage()._declineReward = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The new contract memo, assumed to be Unicode encoded with UTF-8 (at most 100 bytes)
  public enum OneOf_MemoField: Equatable {
    ///*
    /// [Deprecated] If set with a non-zero length, the new memo to be associated with the account
    /// (UTF-8 encoding max 100 bytes)
    case memo(String)
    ///*
    /// If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
    case memoWrapper(SwiftProtobuf.Google_Protobuf_StringValue)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_ContractUpdateTransactionBody.OneOf_MemoField, rhs: Proto_ContractUpdateTransactionBody.OneOf_MemoField) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.memo, .memo): return {
        guard case .memo(let l) = lhs, case .memo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.memoWrapper, .memoWrapper): return {
        guard case .memoWrapper(let l) = lhs, case .memoWrapper(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///*
  /// ID of the new account or node to which this contract is staking.
  public enum OneOf_StakedID: Equatable {
    ///*
    /// ID of the new account to which this contract is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
    /// this field removes the contract's staked account ID.
    case stakedAccountID(Proto_AccountID)
    ///*
    /// ID of the new node this contract is staked to. If set to the sentinel <tt>-1</tt>, this field
    /// removes the contract's staked node ID.
    case stakedNodeID(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_ContractUpdateTransactionBody.OneOf_StakedID, rhs: Proto_ContractUpdateTransactionBody.OneOf_StakedID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stakedAccountID, .stakedAccountID): return {
        guard case .stakedAccountID(let l) = lhs, case .stakedAccountID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stakedNodeID, .stakedNodeID): return {
        guard case .stakedNodeID(let l) = lhs, case .stakedNodeID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_ContractUpdateTransactionBody: @unchecked Sendable {}
extension Proto_ContractUpdateTransactionBody.OneOf_MemoField: @unchecked Sendable {}
extension Proto_ContractUpdateTransactionBody.OneOf_StakedID: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ContractUpdateTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContractUpdateTransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "expirationTime"),
    3: .same(proto: "adminKey"),
    6: .same(proto: "proxyAccountID"),
    7: .same(proto: "autoRenewPeriod"),
    8: .same(proto: "fileID"),
    9: .same(proto: "memo"),
    10: .same(proto: "memoWrapper"),
    11: .standard(proto: "max_automatic_token_associations"),
    12: .standard(proto: "auto_renew_account_id"),
    13: .standard(proto: "staked_account_id"),
    14: .standard(proto: "staked_node_id"),
    15: .standard(proto: "decline_reward"),
  ]

  fileprivate class _StorageClass {
    var _contractID: Proto_ContractID? = nil
    var _expirationTime: Proto_Timestamp? = nil
    var _adminKey: Proto_Key? = nil
    var _proxyAccountID: Proto_AccountID? = nil
    var _autoRenewPeriod: Proto_Duration? = nil
    var _fileID: Proto_FileID? = nil
    var _memoField: Proto_ContractUpdateTransactionBody.OneOf_MemoField?
    var _maxAutomaticTokenAssociations: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _autoRenewAccountID: Proto_AccountID? = nil
    var _stakedID: Proto_ContractUpdateTransactionBody.OneOf_StakedID?
    var _declineReward: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contractID = source._contractID
      _expirationTime = source._expirationTime
      _adminKey = source._adminKey
      _proxyAccountID = source._proxyAccountID
      _autoRenewPeriod = source._autoRenewPeriod
      _fileID = source._fileID
      _memoField = source._memoField
      _maxAutomaticTokenAssociations = source._maxAutomaticTokenAssociations
      _autoRenewAccountID = source._autoRenewAccountID
      _stakedID = source._stakedID
      _declineReward = source._declineReward
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._contractID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._adminKey) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._proxyAccountID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewPeriod) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._fileID) }()
        case 9: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._memoField != nil {try decoder.handleConflictingOneOf()}
            _storage._memoField = .memo(v)
          }
        }()
        case 10: try {
          var v: SwiftProtobuf.Google_Protobuf_StringValue?
          var hadOneofValue = false
          if let current = _storage._memoField {
            hadOneofValue = true
            if case .memoWrapper(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._memoField = .memoWrapper(v)
          }
        }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._maxAutomaticTokenAssociations) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewAccountID) }()
        case 13: try {
          var v: Proto_AccountID?
          var hadOneofValue = false
          if let current = _storage._stakedID {
            hadOneofValue = true
            if case .stakedAccountID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._stakedID = .stakedAccountID(v)
          }
        }()
        case 14: try {
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {
            if _storage._stakedID != nil {try decoder.handleConflictingOneOf()}
            _storage._stakedID = .stakedNodeID(v)
          }
        }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._declineReward) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._contractID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._adminKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._proxyAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._autoRenewPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._fileID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      switch _storage._memoField {
      case .memo?: try {
        guard case .memo(let v)? = _storage._memoField else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }()
      case .memoWrapper?: try {
        guard case .memoWrapper(let v)? = _storage._memoField else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
      try { if let v = _storage._maxAutomaticTokenAssociations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._autoRenewAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      switch _storage._stakedID {
      case .stakedAccountID?: try {
        guard case .stakedAccountID(let v)? = _storage._stakedID else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .stakedNodeID?: try {
        guard case .stakedNodeID(let v)? = _storage._stakedID else { preconditionFailure() }
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 14)
      }()
      case nil: break
      }
      try { if let v = _storage._declineReward {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ContractUpdateTransactionBody, rhs: Proto_ContractUpdateTransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contractID != rhs_storage._contractID {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._adminKey != rhs_storage._adminKey {return false}
        if _storage._proxyAccountID != rhs_storage._proxyAccountID {return false}
        if _storage._autoRenewPeriod != rhs_storage._autoRenewPeriod {return false}
        if _storage._fileID != rhs_storage._fileID {return false}
        if _storage._memoField != rhs_storage._memoField {return false}
        if _storage._maxAutomaticTokenAssociations != rhs_storage._maxAutomaticTokenAssociations {return false}
        if _storage._autoRenewAccountID != rhs_storage._autoRenewAccountID {return false}
        if _storage._stakedID != rhs_storage._stakedID {return false}
        if _storage._declineReward != rhs_storage._declineReward {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
