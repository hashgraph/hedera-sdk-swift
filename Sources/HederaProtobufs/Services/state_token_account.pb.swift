// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state/token/account.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Proto_Account: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The unique entity id of the account.
  public var accountID: Proto_AccountID {
    get {return _storage._accountID ?? Proto_AccountID()}
    set {_uniqueStorage()._accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return _storage._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

  ///*
  /// The alias to use for this account, if any.
  public var alias: Data {
    get {return _storage._alias}
    set {_uniqueStorage()._alias = newValue}
  }

  ///*
  /// (Optional) The key to be used to sign transactions from the account, if any.
  /// This key will not be set for hollow accounts until the account is finalized.
  /// This key should be set on all the accounts, except for immutable accounts (0.0.800 and 0.0.801).
  public var key: Proto_Key {
    get {return _storage._key ?? Proto_Key()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  ///*
  /// The expiration time of the account, in seconds since the epoch.
  public var expirationSecond: Int64 {
    get {return _storage._expirationSecond}
    set {_uniqueStorage()._expirationSecond = newValue}
  }

  ///*
  /// The balance of the account, in tiny-bars.
  public var tinybarBalance: Int64 {
    get {return _storage._tinybarBalance}
    set {_uniqueStorage()._tinybarBalance = newValue}
  }

  ///*
  /// An optional description of the account with UTF-8 encoding up to 100 bytes.
  public var memo: String {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  ///*
  /// A boolean marking if the account has been deleted.
  public var deleted: Bool {
    get {return _storage._deleted}
    set {_uniqueStorage()._deleted = newValue}
  }

  ///*
  /// The amount of hbars staked to the account.
  public var stakedToMe: Int64 {
    get {return _storage._stakedToMe}
    set {_uniqueStorage()._stakedToMe = newValue}
  }

  ///*
  /// If this account stakes to another account, its value will be -1. It will
  /// be set to the time when the account starts staking to a node.
  public var stakePeriodStart: Int64 {
    get {return _storage._stakePeriodStart}
    set {_uniqueStorage()._stakePeriodStart = newValue}
  }

  ///*
  /// ID of the account or node to which this account is staking.
  public var stakedID: OneOf_StakedID? {
    get {return _storage._stakedID}
    set {_uniqueStorage()._stakedID = newValue}
  }

  ///*
  /// ID of the new account to which this account is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
  /// this field removes this account's staked account ID.
  public var stakedAccountID: Proto_AccountID {
    get {
      if case .stakedAccountID(let v)? = _storage._stakedID {return v}
      return Proto_AccountID()
    }
    set {_uniqueStorage()._stakedID = .stakedAccountID(newValue)}
  }

  ///*
  /// ID of the new node this account is staked to. If set to the sentinel <tt>-1</tt>, this field
  /// removes this account's staked node ID.
  public var stakedNodeID: Int64 {
    get {
      if case .stakedNodeID(let v)? = _storage._stakedID {return v}
      return 0
    }
    set {_uniqueStorage()._stakedID = .stakedNodeID(newValue)}
  }

  ///*
  /// A boolean marking if the account declines rewards.
  public var declineReward: Bool {
    get {return _storage._declineReward}
    set {_uniqueStorage()._declineReward = newValue}
  }

  ///*
  /// A boolean marking if the account requires a receiver signature.
  public var receiverSigRequired: Bool {
    get {return _storage._receiverSigRequired}
    set {_uniqueStorage()._receiverSigRequired = newValue}
  }

  ///*
  /// The token ID of the head of the linked list from token relations map for the account.
  public var headTokenID: Proto_TokenID {
    get {return _storage._headTokenID ?? Proto_TokenID()}
    set {_uniqueStorage()._headTokenID = newValue}
  }
  /// Returns true if `headTokenID` has been explicitly set.
  public var hasHeadTokenID: Bool {return _storage._headTokenID != nil}
  /// Clears the value of `headTokenID`. Subsequent reads from it will return its default value.
  public mutating func clearHeadTokenID() {_uniqueStorage()._headTokenID = nil}

  ///*
  /// The NftID of the head of the linked list from unique tokens map for the account.
  public var headNftID: Proto_NftID {
    get {return _storage._headNftID ?? Proto_NftID()}
    set {_uniqueStorage()._headNftID = newValue}
  }
  /// Returns true if `headNftID` has been explicitly set.
  public var hasHeadNftID: Bool {return _storage._headNftID != nil}
  /// Clears the value of `headNftID`. Subsequent reads from it will return its default value.
  public mutating func clearHeadNftID() {_uniqueStorage()._headNftID = nil}

  ///*
  /// The serial number of the head NftID of the linked list from unique tokens map for the account.
  public var headNftSerialNumber: Int64 {
    get {return _storage._headNftSerialNumber}
    set {_uniqueStorage()._headNftSerialNumber = newValue}
  }

  ///*
  /// The number of NFTs owned by the account.
  public var numberOwnedNfts: Int64 {
    get {return _storage._numberOwnedNfts}
    set {_uniqueStorage()._numberOwnedNfts = newValue}
  }

  ///*
  /// The maximum number of tokens that can be auto-associated with the account.
  public var maxAutoAssociations: Int32 {
    get {return _storage._maxAutoAssociations}
    set {_uniqueStorage()._maxAutoAssociations = newValue}
  }

  ///*
  /// The number of used auto-association slots.
  public var usedAutoAssociations: Int32 {
    get {return _storage._usedAutoAssociations}
    set {_uniqueStorage()._usedAutoAssociations = newValue}
  }

  ///*
  /// The number of tokens associated with the account. This number is used for
  /// fee calculation during renewal of the account.
  public var numberAssociations: Int32 {
    get {return _storage._numberAssociations}
    set {_uniqueStorage()._numberAssociations = newValue}
  }

  ///*
  /// A boolean marking if the account is a smart contract.
  public var smartContract: Bool {
    get {return _storage._smartContract}
    set {_uniqueStorage()._smartContract = newValue}
  }

  ///*
  /// The number of tokens with a positive balance associated with the account.
  /// If the account has positive balance in a token, it can not be deleted.
  public var numberPositiveBalances: Int32 {
    get {return _storage._numberPositiveBalances}
    set {_uniqueStorage()._numberPositiveBalances = newValue}
  }

  ///*
  /// The nonce of the account, used for Ethereum interoperability.
  public var ethereumNonce: Int64 {
    get {return _storage._ethereumNonce}
    set {_uniqueStorage()._ethereumNonce = newValue}
  }

  ///*
  /// The amount of hbars staked to the account at the start of the last rewarded period.
  public var stakeAtStartOfLastRewardedPeriod: Int64 {
    get {return _storage._stakeAtStartOfLastRewardedPeriod}
    set {_uniqueStorage()._stakeAtStartOfLastRewardedPeriod = newValue}
  }

  ///*
  /// (Optional) The id of an auto-renew account, in the same shard and realm as the account, that
  /// has signed a transaction allowing the network to use its balance to automatically extend the account's
  /// expiration time when it passes.
  public var autoRenewAccountID: Proto_AccountID {
    get {return _storage._autoRenewAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._autoRenewAccountID = newValue}
  }
  /// Returns true if `autoRenewAccountID` has been explicitly set.
  public var hasAutoRenewAccountID: Bool {return _storage._autoRenewAccountID != nil}
  /// Clears the value of `autoRenewAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewAccountID() {_uniqueStorage()._autoRenewAccountID = nil}

  ///*
  /// The number of seconds the network should automatically extend the account's expiration by, if the
  /// account has a valid auto-renew account, and is not deleted upon expiration.
  /// If this is not provided in an allowed range on account creation, the transaction will fail with INVALID_AUTO_RENEWAL_PERIOD.
  /// The default values for the minimum period and maximum period are 30 days and 90 days, respectively.
  public var autoRenewSeconds: Int64 {
    get {return _storage._autoRenewSeconds}
    set {_uniqueStorage()._autoRenewSeconds = newValue}
  }

  ///*
  /// If this account is a smart-contract, number of key-value pairs stored on the contract.
  /// This is used to determine the storage rent for the contract.
  public var contractKvPairsNumber: Int32 {
    get {return _storage._contractKvPairsNumber}
    set {_uniqueStorage()._contractKvPairsNumber = newValue}
  }

  ///*
  /// (Optional) List of crypto allowances approved by the account.
  /// It contains account number for which the allowance is approved to and
  /// the amount approved for that account.
  public var cryptoAllowances: [Proto_AccountCryptoAllowance] {
    get {return _storage._cryptoAllowances}
    set {_uniqueStorage()._cryptoAllowances = newValue}
  }

  ///*
  /// (Optional) List of non-fungible token allowances approved for all by the account.
  /// It contains account number approved for spending all serial numbers for the given
  /// NFT token number using approved_for_all flag.
  /// Allowances for a specific serial number is stored in the NFT itself in state.
  public var approveForAllNftAllowances: [Proto_AccountApprovalForAllAllowance] {
    get {return _storage._approveForAllNftAllowances}
    set {_uniqueStorage()._approveForAllNftAllowances = newValue}
  }

  ///*
  /// (Optional) List of fungible token allowances approved by the account.
  /// It contains account number for which the allowance is approved to and  the token number.
  /// It also contains and the amount approved for that account.
  public var tokenAllowances: [Proto_AccountFungibleTokenAllowance] {
    get {return _storage._tokenAllowances}
    set {_uniqueStorage()._tokenAllowances = newValue}
  }

  ///*
  /// The number of tokens for which this account is treasury
  public var numberTreasuryTitles: UInt32 {
    get {return _storage._numberTreasuryTitles}
    set {_uniqueStorage()._numberTreasuryTitles = newValue}
  }

  ///*
  /// A flag indicating if the account is expired and pending removal.
  /// Only the entity expiration system task toggles this flag when it reaches this account
  /// and finds it expired. Before setting the flag the system task checks if the account has
  /// an auto-renew account with balance. This is done to prevent a zero-balance account with a funded
  /// auto-renew account from being treated as expired in the interval between its expiration
  /// and the time the system task actually auto-renews it.
  public var expiredAndPendingRemoval: Bool {
    get {return _storage._expiredAndPendingRemoval}
    set {_uniqueStorage()._expiredAndPendingRemoval = newValue}
  }

  ///*
  /// The first key in the doubly-linked list of this contract's storage mappings;
  /// It will be null if if the account is not a contract or the contract has no storage mappings.
  public var firstContractStorageKey: Data {
    get {return _storage._firstContractStorageKey}
    set {_uniqueStorage()._firstContractStorageKey = newValue}
  }

  ///*
  /// A pending airdrop ID at the head of the linked list for this account
  /// from the account airdrops map.<br/>
  /// The account airdrops are connected by including the "next" and "previous"
  /// `PendingAirdropID` in each `AccountAirdrop` message.
  /// <p>
  /// This value SHALL NOT be empty if this account is "sender" for any
  /// pending airdrop, and SHALL be empty otherwise.
  public var headPendingAirdropID: Proto_PendingAirdropId {
    get {return _storage._headPendingAirdropID ?? Proto_PendingAirdropId()}
    set {_uniqueStorage()._headPendingAirdropID = newValue}
  }
  /// Returns true if `headPendingAirdropID` has been explicitly set.
  public var hasHeadPendingAirdropID: Bool {return _storage._headPendingAirdropID != nil}
  /// Clears the value of `headPendingAirdropID`. Subsequent reads from it will return its default value.
  public mutating func clearHeadPendingAirdropID() {_uniqueStorage()._headPendingAirdropID = nil}

  ///*
  /// The number of pending airdrops owned by the account. This number is used to collect rent
  /// for the account.
  public var numberPendingAirdrops: UInt64 {
    get {return _storage._numberPendingAirdrops}
    set {_uniqueStorage()._numberPendingAirdrops = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// ID of the account or node to which this account is staking.
  public enum OneOf_StakedID: Equatable, Sendable {
    ///*
    /// ID of the new account to which this account is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
    /// this field removes this account's staked account ID.
    case stakedAccountID(Proto_AccountID)
    ///*
    /// ID of the new node this account is staked to. If set to the sentinel <tt>-1</tt>, this field
    /// removes this account's staked node ID.
    case stakedNodeID(Int64)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Allowance granted by this account to a spender for a specific non-fungible token
/// using ApproveForAll. This allows spender to spend all serial numbers for the given
/// non-fungible token id.
public struct Proto_AccountApprovalForAllAllowance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  public var spenderID: Proto_AccountID {
    get {return _spenderID ?? Proto_AccountID()}
    set {_spenderID = newValue}
  }
  /// Returns true if `spenderID` has been explicitly set.
  public var hasSpenderID: Bool {return self._spenderID != nil}
  /// Clears the value of `spenderID`. Subsequent reads from it will return its default value.
  public mutating func clearSpenderID() {self._spenderID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
  fileprivate var _spenderID: Proto_AccountID? = nil
}

///*
/// Allowance granted by this account to another account for a specific fungible token.
/// This also contains the amount of the token that is approved for the account.
/// This allows spender to spend the amount of tokens approved for the account.
public struct Proto_AccountFungibleTokenAllowance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  public var spenderID: Proto_AccountID {
    get {return _spenderID ?? Proto_AccountID()}
    set {_spenderID = newValue}
  }
  /// Returns true if `spenderID` has been explicitly set.
  public var hasSpenderID: Bool {return self._spenderID != nil}
  /// Clears the value of `spenderID`. Subsequent reads from it will return its default value.
  public mutating func clearSpenderID() {self._spenderID = nil}

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
  fileprivate var _spenderID: Proto_AccountID? = nil
}

///*
/// Allowance granted by this account to another account for an amount of hbars.
/// This allows spender to spend the amount of hbars approved for the account.
public struct Proto_AccountCryptoAllowance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spenderID: Proto_AccountID {
    get {return _spenderID ?? Proto_AccountID()}
    set {_spenderID = newValue}
  }
  /// Returns true if `spenderID` has been explicitly set.
  public var hasSpenderID: Bool {return self._spenderID != nil}
  /// Clears the value of `spenderID`. Subsequent reads from it will return its default value.
  public mutating func clearSpenderID() {self._spenderID = nil}

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spenderID: Proto_AccountID? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Account"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "alias"),
    3: .same(proto: "key"),
    4: .standard(proto: "expiration_second"),
    5: .standard(proto: "tinybar_balance"),
    6: .same(proto: "memo"),
    7: .same(proto: "deleted"),
    8: .standard(proto: "staked_to_me"),
    9: .standard(proto: "stake_period_start"),
    10: .standard(proto: "staked_account_id"),
    11: .standard(proto: "staked_node_id"),
    12: .standard(proto: "decline_reward"),
    13: .standard(proto: "receiver_sig_required"),
    14: .standard(proto: "head_token_id"),
    15: .standard(proto: "head_nft_id"),
    16: .standard(proto: "head_nft_serial_number"),
    17: .standard(proto: "number_owned_nfts"),
    18: .standard(proto: "max_auto_associations"),
    19: .standard(proto: "used_auto_associations"),
    20: .standard(proto: "number_associations"),
    21: .standard(proto: "smart_contract"),
    22: .standard(proto: "number_positive_balances"),
    23: .standard(proto: "ethereum_nonce"),
    24: .standard(proto: "stake_at_start_of_last_rewarded_period"),
    25: .standard(proto: "auto_renew_account_id"),
    26: .standard(proto: "auto_renew_seconds"),
    27: .standard(proto: "contract_kv_pairs_number"),
    28: .standard(proto: "crypto_allowances"),
    29: .standard(proto: "approve_for_all_nft_allowances"),
    30: .standard(proto: "token_allowances"),
    31: .standard(proto: "number_treasury_titles"),
    32: .standard(proto: "expired_and_pending_removal"),
    33: .standard(proto: "first_contract_storage_key"),
    34: .standard(proto: "head_pending_airdrop_id"),
    35: .standard(proto: "number_pending_airdrops"),
  ]

  fileprivate class _StorageClass {
    var _accountID: Proto_AccountID? = nil
    var _alias: Data = Data()
    var _key: Proto_Key? = nil
    var _expirationSecond: Int64 = 0
    var _tinybarBalance: Int64 = 0
    var _memo: String = String()
    var _deleted: Bool = false
    var _stakedToMe: Int64 = 0
    var _stakePeriodStart: Int64 = 0
    var _stakedID: Proto_Account.OneOf_StakedID?
    var _declineReward: Bool = false
    var _receiverSigRequired: Bool = false
    var _headTokenID: Proto_TokenID? = nil
    var _headNftID: Proto_NftID? = nil
    var _headNftSerialNumber: Int64 = 0
    var _numberOwnedNfts: Int64 = 0
    var _maxAutoAssociations: Int32 = 0
    var _usedAutoAssociations: Int32 = 0
    var _numberAssociations: Int32 = 0
    var _smartContract: Bool = false
    var _numberPositiveBalances: Int32 = 0
    var _ethereumNonce: Int64 = 0
    var _stakeAtStartOfLastRewardedPeriod: Int64 = 0
    var _autoRenewAccountID: Proto_AccountID? = nil
    var _autoRenewSeconds: Int64 = 0
    var _contractKvPairsNumber: Int32 = 0
    var _cryptoAllowances: [Proto_AccountCryptoAllowance] = []
    var _approveForAllNftAllowances: [Proto_AccountApprovalForAllAllowance] = []
    var _tokenAllowances: [Proto_AccountFungibleTokenAllowance] = []
    var _numberTreasuryTitles: UInt32 = 0
    var _expiredAndPendingRemoval: Bool = false
    var _firstContractStorageKey: Data = Data()
    var _headPendingAirdropID: Proto_PendingAirdropId? = nil
    var _numberPendingAirdrops: UInt64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _alias = source._alias
      _key = source._key
      _expirationSecond = source._expirationSecond
      _tinybarBalance = source._tinybarBalance
      _memo = source._memo
      _deleted = source._deleted
      _stakedToMe = source._stakedToMe
      _stakePeriodStart = source._stakePeriodStart
      _stakedID = source._stakedID
      _declineReward = source._declineReward
      _receiverSigRequired = source._receiverSigRequired
      _headTokenID = source._headTokenID
      _headNftID = source._headNftID
      _headNftSerialNumber = source._headNftSerialNumber
      _numberOwnedNfts = source._numberOwnedNfts
      _maxAutoAssociations = source._maxAutoAssociations
      _usedAutoAssociations = source._usedAutoAssociations
      _numberAssociations = source._numberAssociations
      _smartContract = source._smartContract
      _numberPositiveBalances = source._numberPositiveBalances
      _ethereumNonce = source._ethereumNonce
      _stakeAtStartOfLastRewardedPeriod = source._stakeAtStartOfLastRewardedPeriod
      _autoRenewAccountID = source._autoRenewAccountID
      _autoRenewSeconds = source._autoRenewSeconds
      _contractKvPairsNumber = source._contractKvPairsNumber
      _cryptoAllowances = source._cryptoAllowances
      _approveForAllNftAllowances = source._approveForAllNftAllowances
      _tokenAllowances = source._tokenAllowances
      _numberTreasuryTitles = source._numberTreasuryTitles
      _expiredAndPendingRemoval = source._expiredAndPendingRemoval
      _firstContractStorageKey = source._firstContractStorageKey
      _headPendingAirdropID = source._headPendingAirdropID
      _numberPendingAirdrops = source._numberPendingAirdrops
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._accountID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._alias) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._expirationSecond) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._tinybarBalance) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._deleted) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._stakedToMe) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._stakePeriodStart) }()
        case 10: try {
          var v: Proto_AccountID?
          var hadOneofValue = false
          if let current = _storage._stakedID {
            hadOneofValue = true
            if case .stakedAccountID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._stakedID = .stakedAccountID(v)
          }
        }()
        case 11: try {
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {
            if _storage._stakedID != nil {try decoder.handleConflictingOneOf()}
            _storage._stakedID = .stakedNodeID(v)
          }
        }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._declineReward) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._receiverSigRequired) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._headTokenID) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._headNftID) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._headNftSerialNumber) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._numberOwnedNfts) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._maxAutoAssociations) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._usedAutoAssociations) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._numberAssociations) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._smartContract) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._numberPositiveBalances) }()
        case 23: try { try decoder.decodeSingularInt64Field(value: &_storage._ethereumNonce) }()
        case 24: try { try decoder.decodeSingularInt64Field(value: &_storage._stakeAtStartOfLastRewardedPeriod) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewAccountID) }()
        case 26: try { try decoder.decodeSingularInt64Field(value: &_storage._autoRenewSeconds) }()
        case 27: try { try decoder.decodeSingularInt32Field(value: &_storage._contractKvPairsNumber) }()
        case 28: try { try decoder.decodeRepeatedMessageField(value: &_storage._cryptoAllowances) }()
        case 29: try { try decoder.decodeRepeatedMessageField(value: &_storage._approveForAllNftAllowances) }()
        case 30: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokenAllowances) }()
        case 31: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberTreasuryTitles) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._expiredAndPendingRemoval) }()
        case 33: try { try decoder.decodeSingularBytesField(value: &_storage._firstContractStorageKey) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._headPendingAirdropID) }()
        case 35: try { try decoder.decodeSingularUInt64Field(value: &_storage._numberPendingAirdrops) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._alias.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._alias, fieldNumber: 2)
      }
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._expirationSecond != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expirationSecond, fieldNumber: 4)
      }
      if _storage._tinybarBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tinybarBalance, fieldNumber: 5)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 6)
      }
      if _storage._deleted != false {
        try visitor.visitSingularBoolField(value: _storage._deleted, fieldNumber: 7)
      }
      if _storage._stakedToMe != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stakedToMe, fieldNumber: 8)
      }
      if _storage._stakePeriodStart != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stakePeriodStart, fieldNumber: 9)
      }
      switch _storage._stakedID {
      case .stakedAccountID?: try {
        guard case .stakedAccountID(let v)? = _storage._stakedID else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .stakedNodeID?: try {
        guard case .stakedNodeID(let v)? = _storage._stakedID else { preconditionFailure() }
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 11)
      }()
      case nil: break
      }
      if _storage._declineReward != false {
        try visitor.visitSingularBoolField(value: _storage._declineReward, fieldNumber: 12)
      }
      if _storage._receiverSigRequired != false {
        try visitor.visitSingularBoolField(value: _storage._receiverSigRequired, fieldNumber: 13)
      }
      try { if let v = _storage._headTokenID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._headNftID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._headNftSerialNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._headNftSerialNumber, fieldNumber: 16)
      }
      if _storage._numberOwnedNfts != 0 {
        try visitor.visitSingularInt64Field(value: _storage._numberOwnedNfts, fieldNumber: 17)
      }
      if _storage._maxAutoAssociations != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxAutoAssociations, fieldNumber: 18)
      }
      if _storage._usedAutoAssociations != 0 {
        try visitor.visitSingularInt32Field(value: _storage._usedAutoAssociations, fieldNumber: 19)
      }
      if _storage._numberAssociations != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numberAssociations, fieldNumber: 20)
      }
      if _storage._smartContract != false {
        try visitor.visitSingularBoolField(value: _storage._smartContract, fieldNumber: 21)
      }
      if _storage._numberPositiveBalances != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numberPositiveBalances, fieldNumber: 22)
      }
      if _storage._ethereumNonce != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ethereumNonce, fieldNumber: 23)
      }
      if _storage._stakeAtStartOfLastRewardedPeriod != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stakeAtStartOfLastRewardedPeriod, fieldNumber: 24)
      }
      try { if let v = _storage._autoRenewAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      if _storage._autoRenewSeconds != 0 {
        try visitor.visitSingularInt64Field(value: _storage._autoRenewSeconds, fieldNumber: 26)
      }
      if _storage._contractKvPairsNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._contractKvPairsNumber, fieldNumber: 27)
      }
      if !_storage._cryptoAllowances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cryptoAllowances, fieldNumber: 28)
      }
      if !_storage._approveForAllNftAllowances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._approveForAllNftAllowances, fieldNumber: 29)
      }
      if !_storage._tokenAllowances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokenAllowances, fieldNumber: 30)
      }
      if _storage._numberTreasuryTitles != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numberTreasuryTitles, fieldNumber: 31)
      }
      if _storage._expiredAndPendingRemoval != false {
        try visitor.visitSingularBoolField(value: _storage._expiredAndPendingRemoval, fieldNumber: 32)
      }
      if !_storage._firstContractStorageKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._firstContractStorageKey, fieldNumber: 33)
      }
      try { if let v = _storage._headPendingAirdropID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      if _storage._numberPendingAirdrops != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numberPendingAirdrops, fieldNumber: 35)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Account, rhs: Proto_Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._expirationSecond != rhs_storage._expirationSecond {return false}
        if _storage._tinybarBalance != rhs_storage._tinybarBalance {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._deleted != rhs_storage._deleted {return false}
        if _storage._stakedToMe != rhs_storage._stakedToMe {return false}
        if _storage._stakePeriodStart != rhs_storage._stakePeriodStart {return false}
        if _storage._stakedID != rhs_storage._stakedID {return false}
        if _storage._declineReward != rhs_storage._declineReward {return false}
        if _storage._receiverSigRequired != rhs_storage._receiverSigRequired {return false}
        if _storage._headTokenID != rhs_storage._headTokenID {return false}
        if _storage._headNftID != rhs_storage._headNftID {return false}
        if _storage._headNftSerialNumber != rhs_storage._headNftSerialNumber {return false}
        if _storage._numberOwnedNfts != rhs_storage._numberOwnedNfts {return false}
        if _storage._maxAutoAssociations != rhs_storage._maxAutoAssociations {return false}
        if _storage._usedAutoAssociations != rhs_storage._usedAutoAssociations {return false}
        if _storage._numberAssociations != rhs_storage._numberAssociations {return false}
        if _storage._smartContract != rhs_storage._smartContract {return false}
        if _storage._numberPositiveBalances != rhs_storage._numberPositiveBalances {return false}
        if _storage._ethereumNonce != rhs_storage._ethereumNonce {return false}
        if _storage._stakeAtStartOfLastRewardedPeriod != rhs_storage._stakeAtStartOfLastRewardedPeriod {return false}
        if _storage._autoRenewAccountID != rhs_storage._autoRenewAccountID {return false}
        if _storage._autoRenewSeconds != rhs_storage._autoRenewSeconds {return false}
        if _storage._contractKvPairsNumber != rhs_storage._contractKvPairsNumber {return false}
        if _storage._cryptoAllowances != rhs_storage._cryptoAllowances {return false}
        if _storage._approveForAllNftAllowances != rhs_storage._approveForAllNftAllowances {return false}
        if _storage._tokenAllowances != rhs_storage._tokenAllowances {return false}
        if _storage._numberTreasuryTitles != rhs_storage._numberTreasuryTitles {return false}
        if _storage._expiredAndPendingRemoval != rhs_storage._expiredAndPendingRemoval {return false}
        if _storage._firstContractStorageKey != rhs_storage._firstContractStorageKey {return false}
        if _storage._headPendingAirdropID != rhs_storage._headPendingAirdropID {return false}
        if _storage._numberPendingAirdrops != rhs_storage._numberPendingAirdrops {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountApprovalForAllAllowance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountApprovalForAllAllowance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .standard(proto: "spender_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spenderID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spenderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AccountApprovalForAllAllowance, rhs: Proto_AccountApprovalForAllAllowance) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs._spenderID != rhs._spenderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountFungibleTokenAllowance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountFungibleTokenAllowance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .standard(proto: "spender_id"),
    3: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spenderID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spenderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AccountFungibleTokenAllowance, rhs: Proto_AccountFungibleTokenAllowance) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs._spenderID != rhs._spenderID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountCryptoAllowance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountCryptoAllowance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spender_id"),
    2: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spenderID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spenderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AccountCryptoAllowance, rhs: Proto_AccountCryptoAllowance) -> Bool {
    if lhs._spenderID != rhs._spenderID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
