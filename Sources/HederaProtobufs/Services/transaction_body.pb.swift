// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction_body.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A single transaction. All transaction types are possible here.
public struct Proto_TransactionBody: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The ID for this transaction, which includes the payer's account (the account paying the
  /// transaction fee). If two transactions have the same transactionID, they won't both have an
  /// effect
  public var transactionID: Proto_TransactionID {
    get {return _storage._transactionID ?? Proto_TransactionID()}
    set {_uniqueStorage()._transactionID = newValue}
  }
  /// Returns true if `transactionID` has been explicitly set.
  public var hasTransactionID: Bool {return _storage._transactionID != nil}
  /// Clears the value of `transactionID`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionID() {_uniqueStorage()._transactionID = nil}

  ///*
  /// The account of the node that submits the client's transaction to the network
  public var nodeAccountID: Proto_AccountID {
    get {return _storage._nodeAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._nodeAccountID = newValue}
  }
  /// Returns true if `nodeAccountID` has been explicitly set.
  public var hasNodeAccountID: Bool {return _storage._nodeAccountID != nil}
  /// Clears the value of `nodeAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeAccountID() {_uniqueStorage()._nodeAccountID = nil}

  ///*
  /// The maximum transaction fee the client is willing to pay
  public var transactionFee: UInt64 {
    get {return _storage._transactionFee}
    set {_uniqueStorage()._transactionFee = newValue}
  }

  ///*
  /// The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart +
  /// transactionValidDuration
  public var transactionValidDuration: Proto_Duration {
    get {return _storage._transactionValidDuration ?? Proto_Duration()}
    set {_uniqueStorage()._transactionValidDuration = newValue}
  }
  /// Returns true if `transactionValidDuration` has been explicitly set.
  public var hasTransactionValidDuration: Bool {return _storage._transactionValidDuration != nil}
  /// Clears the value of `transactionValidDuration`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionValidDuration() {_uniqueStorage()._transactionValidDuration = nil}

  ///*
  /// Should a record of this transaction be generated? (A receipt is always generated, but the
  /// record is optional)
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var generateRecord: Bool {
    get {return _storage._generateRecord}
    set {_uniqueStorage()._generateRecord = newValue}
  }

  ///*
  /// Any notes or descriptions that should be put into the record (max length 100)
  public var memo: String {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  ///*
  /// The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
  public var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  ///*
  /// Calls a function of a contract instance
  public var contractCall: Proto_ContractCallTransactionBody {
    get {
      if case .contractCall(let v)? = _storage._data {return v}
      return Proto_ContractCallTransactionBody()
    }
    set {_uniqueStorage()._data = .contractCall(newValue)}
  }

  ///*
  /// Creates a contract instance
  public var contractCreateInstance: Proto_ContractCreateTransactionBody {
    get {
      if case .contractCreateInstance(let v)? = _storage._data {return v}
      return Proto_ContractCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .contractCreateInstance(newValue)}
  }

  ///*
  /// Updates a contract
  public var contractUpdateInstance: Proto_ContractUpdateTransactionBody {
    get {
      if case .contractUpdateInstance(let v)? = _storage._data {return v}
      return Proto_ContractUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .contractUpdateInstance(newValue)}
  }

  ///*
  /// Attach a new livehash to an account
  public var cryptoAddLiveHash: Proto_CryptoAddLiveHashTransactionBody {
    get {
      if case .cryptoAddLiveHash(let v)? = _storage._data {return v}
      return Proto_CryptoAddLiveHashTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoAddLiveHash(newValue)}
  }

  ///*
  /// Create a new cryptocurrency account
  public var cryptoCreateAccount: Proto_CryptoCreateTransactionBody {
    get {
      if case .cryptoCreateAccount(let v)? = _storage._data {return v}
      return Proto_CryptoCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoCreateAccount(newValue)}
  }

  ///*
  /// Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
  public var cryptoDelete: Proto_CryptoDeleteTransactionBody {
    get {
      if case .cryptoDelete(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDelete(newValue)}
  }

  ///*
  /// Remove a livehash from an account
  public var cryptoDeleteLiveHash: Proto_CryptoDeleteLiveHashTransactionBody {
    get {
      if case .cryptoDeleteLiveHash(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteLiveHashTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDeleteLiveHash(newValue)}
  }

  ///*
  /// Transfer amount between accounts
  public var cryptoTransfer: Proto_CryptoTransferTransactionBody {
    get {
      if case .cryptoTransfer(let v)? = _storage._data {return v}
      return Proto_CryptoTransferTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoTransfer(newValue)}
  }

  ///*
  /// Modify information such as the expiration date for an account
  public var cryptoUpdateAccount: Proto_CryptoUpdateTransactionBody {
    get {
      if case .cryptoUpdateAccount(let v)? = _storage._data {return v}
      return Proto_CryptoUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoUpdateAccount(newValue)}
  }

  ///*
  /// Add bytes to the end of the contents of a file
  public var fileAppend: Proto_FileAppendTransactionBody {
    get {
      if case .fileAppend(let v)? = _storage._data {return v}
      return Proto_FileAppendTransactionBody()
    }
    set {_uniqueStorage()._data = .fileAppend(newValue)}
  }

  ///*
  /// Create a new file
  public var fileCreate: Proto_FileCreateTransactionBody {
    get {
      if case .fileCreate(let v)? = _storage._data {return v}
      return Proto_FileCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .fileCreate(newValue)}
  }

  ///*
  /// Delete a file (remove contents and mark as deleted until it expires)
  public var fileDelete: Proto_FileDeleteTransactionBody {
    get {
      if case .fileDelete(let v)? = _storage._data {return v}
      return Proto_FileDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .fileDelete(newValue)}
  }

  ///*
  /// Modify information such as the expiration date for a file
  public var fileUpdate: Proto_FileUpdateTransactionBody {
    get {
      if case .fileUpdate(let v)? = _storage._data {return v}
      return Proto_FileUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .fileUpdate(newValue)}
  }

  ///*
  /// Hedera administrative deletion of a file or smart contract
  public var systemDelete: Proto_SystemDeleteTransactionBody {
    get {
      if case .systemDelete(let v)? = _storage._data {return v}
      return Proto_SystemDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .systemDelete(newValue)}
  }

  ///*
  /// To undelete an entity deleted by SystemDelete
  public var systemUndelete: Proto_SystemUndeleteTransactionBody {
    get {
      if case .systemUndelete(let v)? = _storage._data {return v}
      return Proto_SystemUndeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .systemUndelete(newValue)}
  }

  ///*
  /// Delete contract and transfer remaining balance into specified account
  public var contractDeleteInstance: Proto_ContractDeleteTransactionBody {
    get {
      if case .contractDeleteInstance(let v)? = _storage._data {return v}
      return Proto_ContractDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .contractDeleteInstance(newValue)}
  }

  ///*
  /// Freeze the nodes
  public var freeze: Proto_FreezeTransactionBody {
    get {
      if case .freeze(let v)? = _storage._data {return v}
      return Proto_FreezeTransactionBody()
    }
    set {_uniqueStorage()._data = .freeze(newValue)}
  }

  ///*
  /// Creates a topic
  public var consensusCreateTopic: Proto_ConsensusCreateTopicTransactionBody {
    get {
      if case .consensusCreateTopic(let v)? = _storage._data {return v}
      return Proto_ConsensusCreateTopicTransactionBody()
    }
    set {_uniqueStorage()._data = .consensusCreateTopic(newValue)}
  }

  ///*
  /// Updates a topic
  public var consensusUpdateTopic: Proto_ConsensusUpdateTopicTransactionBody {
    get {
      if case .consensusUpdateTopic(let v)? = _storage._data {return v}
      return Proto_ConsensusUpdateTopicTransactionBody()
    }
    set {_uniqueStorage()._data = .consensusUpdateTopic(newValue)}
  }

  ///*
  /// Deletes a topic
  public var consensusDeleteTopic: Proto_ConsensusDeleteTopicTransactionBody {
    get {
      if case .consensusDeleteTopic(let v)? = _storage._data {return v}
      return Proto_ConsensusDeleteTopicTransactionBody()
    }
    set {_uniqueStorage()._data = .consensusDeleteTopic(newValue)}
  }

  ///*
  /// Submits message to a topic
  public var consensusSubmitMessage: Proto_ConsensusSubmitMessageTransactionBody {
    get {
      if case .consensusSubmitMessage(let v)? = _storage._data {return v}
      return Proto_ConsensusSubmitMessageTransactionBody()
    }
    set {_uniqueStorage()._data = .consensusSubmitMessage(newValue)}
  }

  ///*
  /// UNDOCUMENTED
  public var uncheckedSubmit: Proto_UncheckedSubmitBody {
    get {
      if case .uncheckedSubmit(let v)? = _storage._data {return v}
      return Proto_UncheckedSubmitBody()
    }
    set {_uniqueStorage()._data = .uncheckedSubmit(newValue)}
  }

  ///*
  /// Creates a token instance
  public var tokenCreation: Proto_TokenCreateTransactionBody {
    get {
      if case .tokenCreation(let v)? = _storage._data {return v}
      return Proto_TokenCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenCreation(newValue)}
  }

  ///*
  /// Freezes account not to be able to transact with a token
  public var tokenFreeze: Proto_TokenFreezeAccountTransactionBody {
    get {
      if case .tokenFreeze(let v)? = _storage._data {return v}
      return Proto_TokenFreezeAccountTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenFreeze(newValue)}
  }

  ///*
  /// Unfreezes account for a token
  public var tokenUnfreeze: Proto_TokenUnfreezeAccountTransactionBody {
    get {
      if case .tokenUnfreeze(let v)? = _storage._data {return v}
      return Proto_TokenUnfreezeAccountTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenUnfreeze(newValue)}
  }

  ///*
  /// Grants KYC to an account for a token
  public var tokenGrantKyc: Proto_TokenGrantKycTransactionBody {
    get {
      if case .tokenGrantKyc(let v)? = _storage._data {return v}
      return Proto_TokenGrantKycTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenGrantKyc(newValue)}
  }

  ///*
  /// Revokes KYC of an account for a token
  public var tokenRevokeKyc: Proto_TokenRevokeKycTransactionBody {
    get {
      if case .tokenRevokeKyc(let v)? = _storage._data {return v}
      return Proto_TokenRevokeKycTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenRevokeKyc(newValue)}
  }

  ///*
  /// Deletes a token instance
  public var tokenDeletion: Proto_TokenDeleteTransactionBody {
    get {
      if case .tokenDeletion(let v)? = _storage._data {return v}
      return Proto_TokenDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenDeletion(newValue)}
  }

  ///*
  /// Updates a token instance
  public var tokenUpdate: Proto_TokenUpdateTransactionBody {
    get {
      if case .tokenUpdate(let v)? = _storage._data {return v}
      return Proto_TokenUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenUpdate(newValue)}
  }

  ///*
  /// Mints new tokens to a token's treasury account
  public var tokenMint: Proto_TokenMintTransactionBody {
    get {
      if case .tokenMint(let v)? = _storage._data {return v}
      return Proto_TokenMintTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenMint(newValue)}
  }

  ///*
  /// Burns tokens from a token's treasury account
  public var tokenBurn: Proto_TokenBurnTransactionBody {
    get {
      if case .tokenBurn(let v)? = _storage._data {return v}
      return Proto_TokenBurnTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenBurn(newValue)}
  }

  ///*
  /// Wipes amount of tokens from an account
  public var tokenWipe: Proto_TokenWipeAccountTransactionBody {
    get {
      if case .tokenWipe(let v)? = _storage._data {return v}
      return Proto_TokenWipeAccountTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenWipe(newValue)}
  }

  ///*
  /// Associate tokens to an account
  public var tokenAssociate: Proto_TokenAssociateTransactionBody {
    get {
      if case .tokenAssociate(let v)? = _storage._data {return v}
      return Proto_TokenAssociateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenAssociate(newValue)}
  }

  ///*
  /// Dissociate tokens from an account
  public var tokenDissociate: Proto_TokenDissociateTransactionBody {
    get {
      if case .tokenDissociate(let v)? = _storage._data {return v}
      return Proto_TokenDissociateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenDissociate(newValue)}
  }

  ///*
  /// Creates a schedule in the network's action queue
  public var scheduleCreate: Proto_ScheduleCreateTransactionBody {
    get {
      if case .scheduleCreate(let v)? = _storage._data {return v}
      return Proto_ScheduleCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .scheduleCreate(newValue)}
  }

  ///*
  /// Deletes a schedule from the network's action queue
  public var scheduleDelete: Proto_ScheduleDeleteTransactionBody {
    get {
      if case .scheduleDelete(let v)? = _storage._data {return v}
      return Proto_ScheduleDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .scheduleDelete(newValue)}
  }

  ///*
  /// Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction
  public var scheduleSign: Proto_ScheduleSignTransactionBody {
    get {
      if case .scheduleSign(let v)? = _storage._data {return v}
      return Proto_ScheduleSignTransactionBody()
    }
    set {_uniqueStorage()._data = .scheduleSign(newValue)}
  }

  ///*
  /// Updates a token's custom fee schedule
  public var tokenFeeScheduleUpdate: Proto_TokenFeeScheduleUpdateTransactionBody {
    get {
      if case .tokenFeeScheduleUpdate(let v)? = _storage._data {return v}
      return Proto_TokenFeeScheduleUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenFeeScheduleUpdate(newValue)}
  }

  ///*
  /// Pauses the Token
  public var tokenPause: Proto_TokenPauseTransactionBody {
    get {
      if case .tokenPause(let v)? = _storage._data {return v}
      return Proto_TokenPauseTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenPause(newValue)}
  }

  ///*
  /// Unpauses the Token
  public var tokenUnpause: Proto_TokenUnpauseTransactionBody {
    get {
      if case .tokenUnpause(let v)? = _storage._data {return v}
      return Proto_TokenUnpauseTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenUnpause(newValue)}
  }

  ///*
  /// Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
  public var cryptoApproveAllowance: Proto_CryptoApproveAllowanceTransactionBody {
    get {
      if case .cryptoApproveAllowance(let v)? = _storage._data {return v}
      return Proto_CryptoApproveAllowanceTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoApproveAllowance(newValue)}
  }

  ///*
  /// Deletes one or more of the specific approved NFT serial numbers on an owner account.
  public var cryptoDeleteAllowance: Proto_CryptoDeleteAllowanceTransactionBody {
    get {
      if case .cryptoDeleteAllowance(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteAllowanceTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDeleteAllowance(newValue)}
  }

  ///*
  /// An Ethereum encoded transaction.
  public var ethereumTransaction: Proto_EthereumTransactionBody {
    get {
      if case .ethereumTransaction(let v)? = _storage._data {return v}
      return Proto_EthereumTransactionBody()
    }
    set {_uniqueStorage()._data = .ethereumTransaction(newValue)}
  }

  ///*
  /// Updates the staking info at the end of staking period to indicate new staking period has started.
  public var nodeStakeUpdate: Proto_NodeStakeUpdateTransactionBody {
    get {
      if case .nodeStakeUpdate(let v)? = _storage._data {return v}
      return Proto_NodeStakeUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .nodeStakeUpdate(newValue)}
  }

  ///*
  /// Generates a pseudorandom number.
  public var utilPrng: Proto_UtilPrngTransactionBody {
    get {
      if case .utilPrng(let v)? = _storage._data {return v}
      return Proto_UtilPrngTransactionBody()
    }
    set {_uniqueStorage()._data = .utilPrng(newValue)}
  }

  ///*
  /// Update the metadata of one or more NFT's of a specific token type.
  public var tokenUpdateNfts: Proto_TokenUpdateNftsTransactionBody {
    get {
      if case .tokenUpdateNfts(let v)? = _storage._data {return v}
      return Proto_TokenUpdateNftsTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenUpdateNfts(newValue)}
  }

  ///*
  /// A transaction body for a `createNode` request.
  /// <p>
  /// This transaction SHALL create a new consensus node record and add
  /// that record to the network address book.
  public var nodeCreate: Com_Hedera_Hapi_Node_Addressbook_NodeCreateTransactionBody {
    get {
      if case .nodeCreate(let v)? = _storage._data {return v}
      return Com_Hedera_Hapi_Node_Addressbook_NodeCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .nodeCreate(newValue)}
  }

  ///*
  /// A transaction body for an `updateNode` request.
  /// <p>
  /// This transaction SHALL update an existing consensus node record in
  /// the network address book.
  public var nodeUpdate: Com_Hedera_Hapi_Node_Addressbook_NodeUpdateTransactionBody {
    get {
      if case .nodeUpdate(let v)? = _storage._data {return v}
      return Com_Hedera_Hapi_Node_Addressbook_NodeUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .nodeUpdate(newValue)}
  }

  ///*
  /// A transaction body for a `deleteNode` request.
  /// <p>
  /// This transaction SHALL remove an existing consensus node record from
  /// the network address book.
  public var nodeDelete: Com_Hedera_Hapi_Node_Addressbook_NodeDeleteTransactionBody {
    get {
      if case .nodeDelete(let v)? = _storage._data {return v}
      return Com_Hedera_Hapi_Node_Addressbook_NodeDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .nodeDelete(newValue)}
  }

  ///*
  /// A transaction body to "reject" undesired tokens.<br/>
  /// This transaction will transfer one or more tokens or token
  /// balances held by the requesting account to the treasury
  /// for each token type.
  /// <p>
  /// Each transfer MUST be one of the following:
  /// <ul>
  ///   <li>A single non-fungible/unique token.</li>
  ///   <li>The full balance held for a fungible/common
  ///       token type.</li>
  /// </ul>
  /// When complete, the requesting account SHALL NOT hold the
  /// rejected tokens.<br/>
  /// Custom fees and royalties defined for the tokens rejected
  /// SHALL NOT be charged for this transaction.
  public var tokenReject: Proto_TokenRejectTransactionBody {
    get {
      if case .tokenReject(let v)? = _storage._data {return v}
      return Proto_TokenRejectTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenReject(newValue)}
  }

  ///*
  /// A transaction body for a `tokenAirdrop` request.
  public var tokenAirdrop: Proto_TokenAirdropTransactionBody {
    get {
      if case .tokenAirdrop(let v)? = _storage._data {return v}
      return Proto_TokenAirdropTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenAirdrop(newValue)}
  }

  ///*
  /// A transaction body for a `cancelAirdrop` request.
  public var tokenCancelAirdrop: Proto_TokenCancelAirdropTransactionBody {
    get {
      if case .tokenCancelAirdrop(let v)? = _storage._data {return v}
      return Proto_TokenCancelAirdropTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenCancelAirdrop(newValue)}
  }

  ///*
  /// A transaction body for a `claimAirdrop` request.
  public var tokenClaimAirdrop: Proto_TokenClaimAirdropTransactionBody {
    get {
      if case .tokenClaimAirdrop(let v)? = _storage._data {return v}
      return Proto_TokenClaimAirdropTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenClaimAirdrop(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
  public enum OneOf_Data: Equatable, Sendable {
    ///*
    /// Calls a function of a contract instance
    case contractCall(Proto_ContractCallTransactionBody)
    ///*
    /// Creates a contract instance
    case contractCreateInstance(Proto_ContractCreateTransactionBody)
    ///*
    /// Updates a contract
    case contractUpdateInstance(Proto_ContractUpdateTransactionBody)
    ///*
    /// Attach a new livehash to an account
    case cryptoAddLiveHash(Proto_CryptoAddLiveHashTransactionBody)
    ///*
    /// Create a new cryptocurrency account
    case cryptoCreateAccount(Proto_CryptoCreateTransactionBody)
    ///*
    /// Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
    case cryptoDelete(Proto_CryptoDeleteTransactionBody)
    ///*
    /// Remove a livehash from an account
    case cryptoDeleteLiveHash(Proto_CryptoDeleteLiveHashTransactionBody)
    ///*
    /// Transfer amount between accounts
    case cryptoTransfer(Proto_CryptoTransferTransactionBody)
    ///*
    /// Modify information such as the expiration date for an account
    case cryptoUpdateAccount(Proto_CryptoUpdateTransactionBody)
    ///*
    /// Add bytes to the end of the contents of a file
    case fileAppend(Proto_FileAppendTransactionBody)
    ///*
    /// Create a new file
    case fileCreate(Proto_FileCreateTransactionBody)
    ///*
    /// Delete a file (remove contents and mark as deleted until it expires)
    case fileDelete(Proto_FileDeleteTransactionBody)
    ///*
    /// Modify information such as the expiration date for a file
    case fileUpdate(Proto_FileUpdateTransactionBody)
    ///*
    /// Hedera administrative deletion of a file or smart contract
    case systemDelete(Proto_SystemDeleteTransactionBody)
    ///*
    /// To undelete an entity deleted by SystemDelete
    case systemUndelete(Proto_SystemUndeleteTransactionBody)
    ///*
    /// Delete contract and transfer remaining balance into specified account
    case contractDeleteInstance(Proto_ContractDeleteTransactionBody)
    ///*
    /// Freeze the nodes
    case freeze(Proto_FreezeTransactionBody)
    ///*
    /// Creates a topic
    case consensusCreateTopic(Proto_ConsensusCreateTopicTransactionBody)
    ///*
    /// Updates a topic
    case consensusUpdateTopic(Proto_ConsensusUpdateTopicTransactionBody)
    ///*
    /// Deletes a topic
    case consensusDeleteTopic(Proto_ConsensusDeleteTopicTransactionBody)
    ///*
    /// Submits message to a topic
    case consensusSubmitMessage(Proto_ConsensusSubmitMessageTransactionBody)
    ///*
    /// UNDOCUMENTED
    case uncheckedSubmit(Proto_UncheckedSubmitBody)
    ///*
    /// Creates a token instance
    case tokenCreation(Proto_TokenCreateTransactionBody)
    ///*
    /// Freezes account not to be able to transact with a token
    case tokenFreeze(Proto_TokenFreezeAccountTransactionBody)
    ///*
    /// Unfreezes account for a token
    case tokenUnfreeze(Proto_TokenUnfreezeAccountTransactionBody)
    ///*
    /// Grants KYC to an account for a token
    case tokenGrantKyc(Proto_TokenGrantKycTransactionBody)
    ///*
    /// Revokes KYC of an account for a token
    case tokenRevokeKyc(Proto_TokenRevokeKycTransactionBody)
    ///*
    /// Deletes a token instance
    case tokenDeletion(Proto_TokenDeleteTransactionBody)
    ///*
    /// Updates a token instance
    case tokenUpdate(Proto_TokenUpdateTransactionBody)
    ///*
    /// Mints new tokens to a token's treasury account
    case tokenMint(Proto_TokenMintTransactionBody)
    ///*
    /// Burns tokens from a token's treasury account
    case tokenBurn(Proto_TokenBurnTransactionBody)
    ///*
    /// Wipes amount of tokens from an account
    case tokenWipe(Proto_TokenWipeAccountTransactionBody)
    ///*
    /// Associate tokens to an account
    case tokenAssociate(Proto_TokenAssociateTransactionBody)
    ///*
    /// Dissociate tokens from an account
    case tokenDissociate(Proto_TokenDissociateTransactionBody)
    ///*
    /// Creates a schedule in the network's action queue
    case scheduleCreate(Proto_ScheduleCreateTransactionBody)
    ///*
    /// Deletes a schedule from the network's action queue
    case scheduleDelete(Proto_ScheduleDeleteTransactionBody)
    ///*
    /// Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction
    case scheduleSign(Proto_ScheduleSignTransactionBody)
    ///*
    /// Updates a token's custom fee schedule
    case tokenFeeScheduleUpdate(Proto_TokenFeeScheduleUpdateTransactionBody)
    ///*
    /// Pauses the Token
    case tokenPause(Proto_TokenPauseTransactionBody)
    ///*
    /// Unpauses the Token
    case tokenUnpause(Proto_TokenUnpauseTransactionBody)
    ///*
    /// Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
    case cryptoApproveAllowance(Proto_CryptoApproveAllowanceTransactionBody)
    ///*
    /// Deletes one or more of the specific approved NFT serial numbers on an owner account.
    case cryptoDeleteAllowance(Proto_CryptoDeleteAllowanceTransactionBody)
    ///*
    /// An Ethereum encoded transaction.
    case ethereumTransaction(Proto_EthereumTransactionBody)
    ///*
    /// Updates the staking info at the end of staking period to indicate new staking period has started.
    case nodeStakeUpdate(Proto_NodeStakeUpdateTransactionBody)
    ///*
    /// Generates a pseudorandom number.
    case utilPrng(Proto_UtilPrngTransactionBody)
    ///*
    /// Update the metadata of one or more NFT's of a specific token type.
    case tokenUpdateNfts(Proto_TokenUpdateNftsTransactionBody)
    ///*
    /// A transaction body for a `createNode` request.
    /// <p>
    /// This transaction SHALL create a new consensus node record and add
    /// that record to the network address book.
    case nodeCreate(Com_Hedera_Hapi_Node_Addressbook_NodeCreateTransactionBody)
    ///*
    /// A transaction body for an `updateNode` request.
    /// <p>
    /// This transaction SHALL update an existing consensus node record in
    /// the network address book.
    case nodeUpdate(Com_Hedera_Hapi_Node_Addressbook_NodeUpdateTransactionBody)
    ///*
    /// A transaction body for a `deleteNode` request.
    /// <p>
    /// This transaction SHALL remove an existing consensus node record from
    /// the network address book.
    case nodeDelete(Com_Hedera_Hapi_Node_Addressbook_NodeDeleteTransactionBody)
    ///*
    /// A transaction body to "reject" undesired tokens.<br/>
    /// This transaction will transfer one or more tokens or token
    /// balances held by the requesting account to the treasury
    /// for each token type.
    /// <p>
    /// Each transfer MUST be one of the following:
    /// <ul>
    ///   <li>A single non-fungible/unique token.</li>
    ///   <li>The full balance held for a fungible/common
    ///       token type.</li>
    /// </ul>
    /// When complete, the requesting account SHALL NOT hold the
    /// rejected tokens.<br/>
    /// Custom fees and royalties defined for the tokens rejected
    /// SHALL NOT be charged for this transaction.
    case tokenReject(Proto_TokenRejectTransactionBody)
    ///*
    /// A transaction body for a `tokenAirdrop` request.
    case tokenAirdrop(Proto_TokenAirdropTransactionBody)
    ///*
    /// A transaction body for a `cancelAirdrop` request.
    case tokenCancelAirdrop(Proto_TokenCancelAirdropTransactionBody)
    ///*
    /// A transaction body for a `claimAirdrop` request.
    case tokenClaimAirdrop(Proto_TokenClaimAirdropTransactionBody)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_TransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionID"),
    2: .same(proto: "nodeAccountID"),
    3: .same(proto: "transactionFee"),
    4: .same(proto: "transactionValidDuration"),
    5: .same(proto: "generateRecord"),
    6: .same(proto: "memo"),
    7: .same(proto: "contractCall"),
    8: .same(proto: "contractCreateInstance"),
    9: .same(proto: "contractUpdateInstance"),
    10: .same(proto: "cryptoAddLiveHash"),
    11: .same(proto: "cryptoCreateAccount"),
    12: .same(proto: "cryptoDelete"),
    13: .same(proto: "cryptoDeleteLiveHash"),
    14: .same(proto: "cryptoTransfer"),
    15: .same(proto: "cryptoUpdateAccount"),
    16: .same(proto: "fileAppend"),
    17: .same(proto: "fileCreate"),
    18: .same(proto: "fileDelete"),
    19: .same(proto: "fileUpdate"),
    20: .same(proto: "systemDelete"),
    21: .same(proto: "systemUndelete"),
    22: .same(proto: "contractDeleteInstance"),
    23: .same(proto: "freeze"),
    24: .same(proto: "consensusCreateTopic"),
    25: .same(proto: "consensusUpdateTopic"),
    26: .same(proto: "consensusDeleteTopic"),
    27: .same(proto: "consensusSubmitMessage"),
    28: .same(proto: "uncheckedSubmit"),
    29: .same(proto: "tokenCreation"),
    31: .same(proto: "tokenFreeze"),
    32: .same(proto: "tokenUnfreeze"),
    33: .same(proto: "tokenGrantKyc"),
    34: .same(proto: "tokenRevokeKyc"),
    35: .same(proto: "tokenDeletion"),
    36: .same(proto: "tokenUpdate"),
    37: .same(proto: "tokenMint"),
    38: .same(proto: "tokenBurn"),
    39: .same(proto: "tokenWipe"),
    40: .same(proto: "tokenAssociate"),
    41: .same(proto: "tokenDissociate"),
    42: .same(proto: "scheduleCreate"),
    43: .same(proto: "scheduleDelete"),
    44: .same(proto: "scheduleSign"),
    45: .standard(proto: "token_fee_schedule_update"),
    46: .standard(proto: "token_pause"),
    47: .standard(proto: "token_unpause"),
    48: .same(proto: "cryptoApproveAllowance"),
    49: .same(proto: "cryptoDeleteAllowance"),
    50: .same(proto: "ethereumTransaction"),
    51: .standard(proto: "node_stake_update"),
    52: .standard(proto: "util_prng"),
    53: .standard(proto: "token_update_nfts"),
    54: .same(proto: "nodeCreate"),
    55: .same(proto: "nodeUpdate"),
    56: .same(proto: "nodeDelete"),
    57: .same(proto: "tokenReject"),
    58: .same(proto: "tokenAirdrop"),
    59: .same(proto: "tokenCancelAirdrop"),
    60: .same(proto: "tokenClaimAirdrop"),
  ]

  fileprivate class _StorageClass {
    var _transactionID: Proto_TransactionID? = nil
    var _nodeAccountID: Proto_AccountID? = nil
    var _transactionFee: UInt64 = 0
    var _transactionValidDuration: Proto_Duration? = nil
    var _generateRecord: Bool = false
    var _memo: String = String()
    var _data: Proto_TransactionBody.OneOf_Data?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _transactionID = source._transactionID
      _nodeAccountID = source._nodeAccountID
      _transactionFee = source._transactionFee
      _transactionValidDuration = source._transactionValidDuration
      _generateRecord = source._generateRecord
      _memo = source._memo
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._transactionID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nodeAccountID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._transactionFee) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._transactionValidDuration) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._generateRecord) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 7: try {
          var v: Proto_ContractCallTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .contractCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .contractCall(v)
          }
        }()
        case 8: try {
          var v: Proto_ContractCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .contractCreateInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .contractCreateInstance(v)
          }
        }()
        case 9: try {
          var v: Proto_ContractUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .contractUpdateInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .contractUpdateInstance(v)
          }
        }()
        case 10: try {
          var v: Proto_CryptoAddLiveHashTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoAddLiveHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoAddLiveHash(v)
          }
        }()
        case 11: try {
          var v: Proto_CryptoCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoCreateAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoCreateAccount(v)
          }
        }()
        case 12: try {
          var v: Proto_CryptoDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoDelete(v)
          }
        }()
        case 13: try {
          var v: Proto_CryptoDeleteLiveHashTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoDeleteLiveHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoDeleteLiveHash(v)
          }
        }()
        case 14: try {
          var v: Proto_CryptoTransferTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoTransfer(v)
          }
        }()
        case 15: try {
          var v: Proto_CryptoUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoUpdateAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoUpdateAccount(v)
          }
        }()
        case 16: try {
          var v: Proto_FileAppendTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .fileAppend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .fileAppend(v)
          }
        }()
        case 17: try {
          var v: Proto_FileCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .fileCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .fileCreate(v)
          }
        }()
        case 18: try {
          var v: Proto_FileDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .fileDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .fileDelete(v)
          }
        }()
        case 19: try {
          var v: Proto_FileUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .fileUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .fileUpdate(v)
          }
        }()
        case 20: try {
          var v: Proto_SystemDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .systemDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .systemDelete(v)
          }
        }()
        case 21: try {
          var v: Proto_SystemUndeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .systemUndelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .systemUndelete(v)
          }
        }()
        case 22: try {
          var v: Proto_ContractDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .contractDeleteInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .contractDeleteInstance(v)
          }
        }()
        case 23: try {
          var v: Proto_FreezeTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .freeze(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .freeze(v)
          }
        }()
        case 24: try {
          var v: Proto_ConsensusCreateTopicTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .consensusCreateTopic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .consensusCreateTopic(v)
          }
        }()
        case 25: try {
          var v: Proto_ConsensusUpdateTopicTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .consensusUpdateTopic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .consensusUpdateTopic(v)
          }
        }()
        case 26: try {
          var v: Proto_ConsensusDeleteTopicTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .consensusDeleteTopic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .consensusDeleteTopic(v)
          }
        }()
        case 27: try {
          var v: Proto_ConsensusSubmitMessageTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .consensusSubmitMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .consensusSubmitMessage(v)
          }
        }()
        case 28: try {
          var v: Proto_UncheckedSubmitBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .uncheckedSubmit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .uncheckedSubmit(v)
          }
        }()
        case 29: try {
          var v: Proto_TokenCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenCreation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenCreation(v)
          }
        }()
        case 31: try {
          var v: Proto_TokenFreezeAccountTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenFreeze(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenFreeze(v)
          }
        }()
        case 32: try {
          var v: Proto_TokenUnfreezeAccountTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenUnfreeze(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenUnfreeze(v)
          }
        }()
        case 33: try {
          var v: Proto_TokenGrantKycTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenGrantKyc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenGrantKyc(v)
          }
        }()
        case 34: try {
          var v: Proto_TokenRevokeKycTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenRevokeKyc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenRevokeKyc(v)
          }
        }()
        case 35: try {
          var v: Proto_TokenDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenDeletion(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenDeletion(v)
          }
        }()
        case 36: try {
          var v: Proto_TokenUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenUpdate(v)
          }
        }()
        case 37: try {
          var v: Proto_TokenMintTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenMint(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenMint(v)
          }
        }()
        case 38: try {
          var v: Proto_TokenBurnTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenBurn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenBurn(v)
          }
        }()
        case 39: try {
          var v: Proto_TokenWipeAccountTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenWipe(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenWipe(v)
          }
        }()
        case 40: try {
          var v: Proto_TokenAssociateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenAssociate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenAssociate(v)
          }
        }()
        case 41: try {
          var v: Proto_TokenDissociateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenDissociate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenDissociate(v)
          }
        }()
        case 42: try {
          var v: Proto_ScheduleCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .scheduleCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .scheduleCreate(v)
          }
        }()
        case 43: try {
          var v: Proto_ScheduleDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .scheduleDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .scheduleDelete(v)
          }
        }()
        case 44: try {
          var v: Proto_ScheduleSignTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .scheduleSign(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .scheduleSign(v)
          }
        }()
        case 45: try {
          var v: Proto_TokenFeeScheduleUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenFeeScheduleUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenFeeScheduleUpdate(v)
          }
        }()
        case 46: try {
          var v: Proto_TokenPauseTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenPause(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenPause(v)
          }
        }()
        case 47: try {
          var v: Proto_TokenUnpauseTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenUnpause(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenUnpause(v)
          }
        }()
        case 48: try {
          var v: Proto_CryptoApproveAllowanceTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoApproveAllowance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoApproveAllowance(v)
          }
        }()
        case 49: try {
          var v: Proto_CryptoDeleteAllowanceTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoDeleteAllowance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoDeleteAllowance(v)
          }
        }()
        case 50: try {
          var v: Proto_EthereumTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .ethereumTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .ethereumTransaction(v)
          }
        }()
        case 51: try {
          var v: Proto_NodeStakeUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .nodeStakeUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .nodeStakeUpdate(v)
          }
        }()
        case 52: try {
          var v: Proto_UtilPrngTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .utilPrng(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .utilPrng(v)
          }
        }()
        case 53: try {
          var v: Proto_TokenUpdateNftsTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenUpdateNfts(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenUpdateNfts(v)
          }
        }()
        case 54: try {
          var v: Com_Hedera_Hapi_Node_Addressbook_NodeCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .nodeCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .nodeCreate(v)
          }
        }()
        case 55: try {
          var v: Com_Hedera_Hapi_Node_Addressbook_NodeUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .nodeUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .nodeUpdate(v)
          }
        }()
        case 56: try {
          var v: Com_Hedera_Hapi_Node_Addressbook_NodeDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .nodeDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .nodeDelete(v)
          }
        }()
        case 57: try {
          var v: Proto_TokenRejectTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenReject(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenReject(v)
          }
        }()
        case 58: try {
          var v: Proto_TokenAirdropTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenAirdrop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenAirdrop(v)
          }
        }()
        case 59: try {
          var v: Proto_TokenCancelAirdropTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenCancelAirdrop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenCancelAirdrop(v)
          }
        }()
        case 60: try {
          var v: Proto_TokenClaimAirdropTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenClaimAirdrop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenClaimAirdrop(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._transactionID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._nodeAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._transactionFee != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._transactionFee, fieldNumber: 3)
      }
      try { if let v = _storage._transactionValidDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._generateRecord != false {
        try visitor.visitSingularBoolField(value: _storage._generateRecord, fieldNumber: 5)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 6)
      }
      switch _storage._data {
      case .contractCall?: try {
        guard case .contractCall(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .contractCreateInstance?: try {
        guard case .contractCreateInstance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .contractUpdateInstance?: try {
        guard case .contractUpdateInstance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .cryptoAddLiveHash?: try {
        guard case .cryptoAddLiveHash(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .cryptoCreateAccount?: try {
        guard case .cryptoCreateAccount(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .cryptoDelete?: try {
        guard case .cryptoDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .cryptoDeleteLiveHash?: try {
        guard case .cryptoDeleteLiveHash(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .cryptoTransfer?: try {
        guard case .cryptoTransfer(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .cryptoUpdateAccount?: try {
        guard case .cryptoUpdateAccount(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .fileAppend?: try {
        guard case .fileAppend(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .fileCreate?: try {
        guard case .fileCreate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .fileDelete?: try {
        guard case .fileDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .fileUpdate?: try {
        guard case .fileUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .systemDelete?: try {
        guard case .systemDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .systemUndelete?: try {
        guard case .systemUndelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .contractDeleteInstance?: try {
        guard case .contractDeleteInstance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .freeze?: try {
        guard case .freeze(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .consensusCreateTopic?: try {
        guard case .consensusCreateTopic(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .consensusUpdateTopic?: try {
        guard case .consensusUpdateTopic(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .consensusDeleteTopic?: try {
        guard case .consensusDeleteTopic(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .consensusSubmitMessage?: try {
        guard case .consensusSubmitMessage(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .uncheckedSubmit?: try {
        guard case .uncheckedSubmit(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .tokenCreation?: try {
        guard case .tokenCreation(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .tokenFreeze?: try {
        guard case .tokenFreeze(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .tokenUnfreeze?: try {
        guard case .tokenUnfreeze(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .tokenGrantKyc?: try {
        guard case .tokenGrantKyc(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .tokenRevokeKyc?: try {
        guard case .tokenRevokeKyc(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .tokenDeletion?: try {
        guard case .tokenDeletion(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .tokenUpdate?: try {
        guard case .tokenUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .tokenMint?: try {
        guard case .tokenMint(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .tokenBurn?: try {
        guard case .tokenBurn(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .tokenWipe?: try {
        guard case .tokenWipe(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .tokenAssociate?: try {
        guard case .tokenAssociate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .tokenDissociate?: try {
        guard case .tokenDissociate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .scheduleCreate?: try {
        guard case .scheduleCreate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .scheduleDelete?: try {
        guard case .scheduleDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .scheduleSign?: try {
        guard case .scheduleSign(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .tokenFeeScheduleUpdate?: try {
        guard case .tokenFeeScheduleUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .tokenPause?: try {
        guard case .tokenPause(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .tokenUnpause?: try {
        guard case .tokenUnpause(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .cryptoApproveAllowance?: try {
        guard case .cryptoApproveAllowance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .cryptoDeleteAllowance?: try {
        guard case .cryptoDeleteAllowance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .ethereumTransaction?: try {
        guard case .ethereumTransaction(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .nodeStakeUpdate?: try {
        guard case .nodeStakeUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .utilPrng?: try {
        guard case .utilPrng(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .tokenUpdateNfts?: try {
        guard case .tokenUpdateNfts(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .nodeCreate?: try {
        guard case .nodeCreate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case .nodeUpdate?: try {
        guard case .nodeUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      }()
      case .nodeDelete?: try {
        guard case .nodeDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      }()
      case .tokenReject?: try {
        guard case .tokenReject(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      }()
      case .tokenAirdrop?: try {
        guard case .tokenAirdrop(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      }()
      case .tokenCancelAirdrop?: try {
        guard case .tokenCancelAirdrop(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      }()
      case .tokenClaimAirdrop?: try {
        guard case .tokenClaimAirdrop(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionBody, rhs: Proto_TransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._nodeAccountID != rhs_storage._nodeAccountID {return false}
        if _storage._transactionFee != rhs_storage._transactionFee {return false}
        if _storage._transactionValidDuration != rhs_storage._transactionValidDuration {return false}
        if _storage._generateRecord != rhs_storage._generateRecord {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
