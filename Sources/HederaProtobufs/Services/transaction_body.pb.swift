// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction_body.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A single transaction. All transaction types are possible here.
public struct Proto_TransactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The ID for this transaction, which includes the payer's account (the account paying the
  /// transaction fee). If two transactions have the same transactionID, they won't both have an
  /// effect
  public var transactionID: Proto_TransactionID {
    get {return _storage._transactionID ?? Proto_TransactionID()}
    set {_uniqueStorage()._transactionID = newValue}
  }
  /// Returns true if `transactionID` has been explicitly set.
  public var hasTransactionID: Bool {return _storage._transactionID != nil}
  /// Clears the value of `transactionID`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionID() {_uniqueStorage()._transactionID = nil}

  ///*
  /// The account of the node that submits the client's transaction to the network
  public var nodeAccountID: Proto_AccountID {
    get {return _storage._nodeAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._nodeAccountID = newValue}
  }
  /// Returns true if `nodeAccountID` has been explicitly set.
  public var hasNodeAccountID: Bool {return _storage._nodeAccountID != nil}
  /// Clears the value of `nodeAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeAccountID() {_uniqueStorage()._nodeAccountID = nil}

  ///*
  /// The maximum transaction fee the client is willing to pay
  public var transactionFee: UInt64 {
    get {return _storage._transactionFee}
    set {_uniqueStorage()._transactionFee = newValue}
  }

  ///*
  /// The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart +
  /// transactionValidDuration
  public var transactionValidDuration: Proto_Duration {
    get {return _storage._transactionValidDuration ?? Proto_Duration()}
    set {_uniqueStorage()._transactionValidDuration = newValue}
  }
  /// Returns true if `transactionValidDuration` has been explicitly set.
  public var hasTransactionValidDuration: Bool {return _storage._transactionValidDuration != nil}
  /// Clears the value of `transactionValidDuration`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionValidDuration() {_uniqueStorage()._transactionValidDuration = nil}

  ///*
  /// Should a record of this transaction be generated? (A receipt is always generated, but the
  /// record is optional)
  public var generateRecord: Bool {
    get {return _storage._generateRecord}
    set {_uniqueStorage()._generateRecord = newValue}
  }

  ///*
  /// Any notes or descriptions that should be put into the record (max length 100)
  public var memo: String {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  ///*
  /// The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
  public var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  ///*
  /// Calls a function of a contract instance
  public var contractCall: Proto_ContractCallTransactionBody {
    get {
      if case .contractCall(let v)? = _storage._data {return v}
      return Proto_ContractCallTransactionBody()
    }
    set {_uniqueStorage()._data = .contractCall(newValue)}
  }

  ///*
  /// Creates a contract instance
  public var contractCreateInstance: Proto_ContractCreateTransactionBody {
    get {
      if case .contractCreateInstance(let v)? = _storage._data {return v}
      return Proto_ContractCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .contractCreateInstance(newValue)}
  }

  ///*
  /// Updates a contract
  public var contractUpdateInstance: Proto_ContractUpdateTransactionBody {
    get {
      if case .contractUpdateInstance(let v)? = _storage._data {return v}
      return Proto_ContractUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .contractUpdateInstance(newValue)}
  }

  ///*
  /// Delete contract and transfer remaining balance into specified account
  public var contractDeleteInstance: Proto_ContractDeleteTransactionBody {
    get {
      if case .contractDeleteInstance(let v)? = _storage._data {return v}
      return Proto_ContractDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .contractDeleteInstance(newValue)}
  }

  ///*
  /// An Ethereum encoded transaction.
  public var ethereumTransaction: Proto_EthereumTransactionBody {
    get {
      if case .ethereumTransaction(let v)? = _storage._data {return v}
      return Proto_EthereumTransactionBody()
    }
    set {_uniqueStorage()._data = .ethereumTransaction(newValue)}
  }

  ///*
  /// Attach a new livehash to an account
  public var cryptoAddLiveHash: Proto_CryptoAddLiveHashTransactionBody {
    get {
      if case .cryptoAddLiveHash(let v)? = _storage._data {return v}
      return Proto_CryptoAddLiveHashTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoAddLiveHash(newValue)}
  }

  ///*
  /// Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
  public var cryptoApproveAllowance: Proto_CryptoApproveAllowanceTransactionBody {
    get {
      if case .cryptoApproveAllowance(let v)? = _storage._data {return v}
      return Proto_CryptoApproveAllowanceTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoApproveAllowance(newValue)}
  }

  ///*
  /// Deletes one or more of the specific approved NFT serial numbers on an owner account.
  public var cryptoDeleteAllowance: Proto_CryptoDeleteAllowanceTransactionBody {
    get {
      if case .cryptoDeleteAllowance(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteAllowanceTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDeleteAllowance(newValue)}
  }

  ///*
  /// Create a new cryptocurrency account
  public var cryptoCreateAccount: Proto_CryptoCreateTransactionBody {
    get {
      if case .cryptoCreateAccount(let v)? = _storage._data {return v}
      return Proto_CryptoCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoCreateAccount(newValue)}
  }

  ///*
  /// Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
  public var cryptoDelete: Proto_CryptoDeleteTransactionBody {
    get {
      if case .cryptoDelete(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDelete(newValue)}
  }

  ///*
  /// Remove a livehash from an account
  public var cryptoDeleteLiveHash: Proto_CryptoDeleteLiveHashTransactionBody {
    get {
      if case .cryptoDeleteLiveHash(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteLiveHashTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDeleteLiveHash(newValue)}
  }

  ///*
  /// Transfer amount between accounts
  public var cryptoTransfer: Proto_CryptoTransferTransactionBody {
    get {
      if case .cryptoTransfer(let v)? = _storage._data {return v}
      return Proto_CryptoTransferTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoTransfer(newValue)}
  }

  ///*
  /// Modify information such as the expiration date for an account
  public var cryptoUpdateAccount: Proto_CryptoUpdateTransactionBody {
    get {
      if case .cryptoUpdateAccount(let v)? = _storage._data {return v}
      return Proto_CryptoUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoUpdateAccount(newValue)}
  }

  ///*
  /// Add bytes to the end of the contents of a file
  public var fileAppend: Proto_FileAppendTransactionBody {
    get {
      if case .fileAppend(let v)? = _storage._data {return v}
      return Proto_FileAppendTransactionBody()
    }
    set {_uniqueStorage()._data = .fileAppend(newValue)}
  }

  ///*
  /// Create a new file
  public var fileCreate: Proto_FileCreateTransactionBody {
    get {
      if case .fileCreate(let v)? = _storage._data {return v}
      return Proto_FileCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .fileCreate(newValue)}
  }

  ///*
  /// Delete a file (remove contents and mark as deleted until it expires)
  public var fileDelete: Proto_FileDeleteTransactionBody {
    get {
      if case .fileDelete(let v)? = _storage._data {return v}
      return Proto_FileDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .fileDelete(newValue)}
  }

  ///*
  /// Modify information such as the expiration date for a file
  public var fileUpdate: Proto_FileUpdateTransactionBody {
    get {
      if case .fileUpdate(let v)? = _storage._data {return v}
      return Proto_FileUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .fileUpdate(newValue)}
  }

  ///*
  /// Hedera administrative deletion of a file or smart contract
  public var systemDelete: Proto_SystemDeleteTransactionBody {
    get {
      if case .systemDelete(let v)? = _storage._data {return v}
      return Proto_SystemDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .systemDelete(newValue)}
  }

  ///*
  /// To undelete an entity deleted by SystemDelete
  public var systemUndelete: Proto_SystemUndeleteTransactionBody {
    get {
      if case .systemUndelete(let v)? = _storage._data {return v}
      return Proto_SystemUndeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .systemUndelete(newValue)}
  }

  ///*
  /// Freeze the nodes
  public var freeze: Proto_FreezeTransactionBody {
    get {
      if case .freeze(let v)? = _storage._data {return v}
      return Proto_FreezeTransactionBody()
    }
    set {_uniqueStorage()._data = .freeze(newValue)}
  }

  ///*
  /// Creates a topic
  public var consensusCreateTopic: Proto_ConsensusCreateTopicTransactionBody {
    get {
      if case .consensusCreateTopic(let v)? = _storage._data {return v}
      return Proto_ConsensusCreateTopicTransactionBody()
    }
    set {_uniqueStorage()._data = .consensusCreateTopic(newValue)}
  }

  ///*
  /// Updates a topic
  public var consensusUpdateTopic: Proto_ConsensusUpdateTopicTransactionBody {
    get {
      if case .consensusUpdateTopic(let v)? = _storage._data {return v}
      return Proto_ConsensusUpdateTopicTransactionBody()
    }
    set {_uniqueStorage()._data = .consensusUpdateTopic(newValue)}
  }

  ///*
  /// Deletes a topic
  public var consensusDeleteTopic: Proto_ConsensusDeleteTopicTransactionBody {
    get {
      if case .consensusDeleteTopic(let v)? = _storage._data {return v}
      return Proto_ConsensusDeleteTopicTransactionBody()
    }
    set {_uniqueStorage()._data = .consensusDeleteTopic(newValue)}
  }

  ///*
  /// Submits message to a topic
  public var consensusSubmitMessage: Proto_ConsensusSubmitMessageTransactionBody {
    get {
      if case .consensusSubmitMessage(let v)? = _storage._data {return v}
      return Proto_ConsensusSubmitMessageTransactionBody()
    }
    set {_uniqueStorage()._data = .consensusSubmitMessage(newValue)}
  }

  ///*
  /// UNDOCUMENTED
  public var uncheckedSubmit: Proto_UncheckedSubmitBody {
    get {
      if case .uncheckedSubmit(let v)? = _storage._data {return v}
      return Proto_UncheckedSubmitBody()
    }
    set {_uniqueStorage()._data = .uncheckedSubmit(newValue)}
  }

  ///*
  /// Creates a token instance
  public var tokenCreation: Proto_TokenCreateTransactionBody {
    get {
      if case .tokenCreation(let v)? = _storage._data {return v}
      return Proto_TokenCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenCreation(newValue)}
  }

  ///*
  /// Freezes account not to be able to transact with a token
  public var tokenFreeze: Proto_TokenFreezeAccountTransactionBody {
    get {
      if case .tokenFreeze(let v)? = _storage._data {return v}
      return Proto_TokenFreezeAccountTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenFreeze(newValue)}
  }

  ///*
  /// Unfreezes account for a token
  public var tokenUnfreeze: Proto_TokenUnfreezeAccountTransactionBody {
    get {
      if case .tokenUnfreeze(let v)? = _storage._data {return v}
      return Proto_TokenUnfreezeAccountTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenUnfreeze(newValue)}
  }

  ///*
  /// Grants KYC to an account for a token
  public var tokenGrantKyc: Proto_TokenGrantKycTransactionBody {
    get {
      if case .tokenGrantKyc(let v)? = _storage._data {return v}
      return Proto_TokenGrantKycTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenGrantKyc(newValue)}
  }

  ///*
  /// Revokes KYC of an account for a token
  public var tokenRevokeKyc: Proto_TokenRevokeKycTransactionBody {
    get {
      if case .tokenRevokeKyc(let v)? = _storage._data {return v}
      return Proto_TokenRevokeKycTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenRevokeKyc(newValue)}
  }

  ///*
  /// Deletes a token instance
  public var tokenDeletion: Proto_TokenDeleteTransactionBody {
    get {
      if case .tokenDeletion(let v)? = _storage._data {return v}
      return Proto_TokenDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenDeletion(newValue)}
  }

  ///*
  /// Updates a token instance
  public var tokenUpdate: Proto_TokenUpdateTransactionBody {
    get {
      if case .tokenUpdate(let v)? = _storage._data {return v}
      return Proto_TokenUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenUpdate(newValue)}
  }

  ///*
  /// Mints new tokens to a token's treasury account
  public var tokenMint: Proto_TokenMintTransactionBody {
    get {
      if case .tokenMint(let v)? = _storage._data {return v}
      return Proto_TokenMintTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenMint(newValue)}
  }

  ///*
  /// Burns tokens from a token's treasury account
  public var tokenBurn: Proto_TokenBurnTransactionBody {
    get {
      if case .tokenBurn(let v)? = _storage._data {return v}
      return Proto_TokenBurnTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenBurn(newValue)}
  }

  ///*
  /// Wipes amount of tokens from an account
  public var tokenWipe: Proto_TokenWipeAccountTransactionBody {
    get {
      if case .tokenWipe(let v)? = _storage._data {return v}
      return Proto_TokenWipeAccountTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenWipe(newValue)}
  }

  ///*
  /// Associate tokens to an account
  public var tokenAssociate: Proto_TokenAssociateTransactionBody {
    get {
      if case .tokenAssociate(let v)? = _storage._data {return v}
      return Proto_TokenAssociateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenAssociate(newValue)}
  }

  ///*
  /// Dissociate tokens from an account
  public var tokenDissociate: Proto_TokenDissociateTransactionBody {
    get {
      if case .tokenDissociate(let v)? = _storage._data {return v}
      return Proto_TokenDissociateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenDissociate(newValue)}
  }

  ///*
  /// Updates a token's custom fee schedule
  public var tokenFeeScheduleUpdate: Proto_TokenFeeScheduleUpdateTransactionBody {
    get {
      if case .tokenFeeScheduleUpdate(let v)? = _storage._data {return v}
      return Proto_TokenFeeScheduleUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenFeeScheduleUpdate(newValue)}
  }

  ///*
  /// Pauses the Token
  public var tokenPause: Proto_TokenPauseTransactionBody {
    get {
      if case .tokenPause(let v)? = _storage._data {return v}
      return Proto_TokenPauseTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenPause(newValue)}
  }

  ///*
  /// Unpauses the Token
  public var tokenUnpause: Proto_TokenUnpauseTransactionBody {
    get {
      if case .tokenUnpause(let v)? = _storage._data {return v}
      return Proto_TokenUnpauseTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenUnpause(newValue)}
  }

  ///*
  /// Creates a schedule in the network's action queue
  public var scheduleCreate: Proto_ScheduleCreateTransactionBody {
    get {
      if case .scheduleCreate(let v)? = _storage._data {return v}
      return Proto_ScheduleCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .scheduleCreate(newValue)}
  }

  ///*
  /// Deletes a schedule from the network's action queue
  public var scheduleDelete: Proto_ScheduleDeleteTransactionBody {
    get {
      if case .scheduleDelete(let v)? = _storage._data {return v}
      return Proto_ScheduleDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .scheduleDelete(newValue)}
  }

  ///*
  /// Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction
  public var scheduleSign: Proto_ScheduleSignTransactionBody {
    get {
      if case .scheduleSign(let v)? = _storage._data {return v}
      return Proto_ScheduleSignTransactionBody()
    }
    set {_uniqueStorage()._data = .scheduleSign(newValue)}
  }

  ///*
  /// Updates the staking info at the end of staking period to indicate new staking period has started.
  public var nodeStakeUpdate: Proto_NodeStakeUpdateTransactionBody {
    get {
      if case .nodeStakeUpdate(let v)? = _storage._data {return v}
      return Proto_NodeStakeUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .nodeStakeUpdate(newValue)}
  }

  ///*
  /// Generates a pseudorandom number.
  public var utilPrng: Proto_UtilPrngTransactionBody {
    get {
      if case .utilPrng(let v)? = _storage._data {return v}
      return Proto_UtilPrngTransactionBody()
    }
    set {_uniqueStorage()._data = .utilPrng(newValue)}
  }

  ///*
  /// Update the metadata of one or more NFT's of a specific token type.
  public var tokenUpdateNfts: Proto_TokenUpdateNftsTransactionBody {
    get {
      if case .tokenUpdateNfts(let v)? = _storage._data {return v}
      return Proto_TokenUpdateNftsTransactionBody()
    }
    set {_uniqueStorage()._data = .tokenUpdateNfts(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
  public enum OneOf_Data: Equatable {
    ///*
    /// Calls a function of a contract instance
    case contractCall(Proto_ContractCallTransactionBody)
    ///*
    /// Creates a contract instance
    case contractCreateInstance(Proto_ContractCreateTransactionBody)
    ///*
    /// Updates a contract
    case contractUpdateInstance(Proto_ContractUpdateTransactionBody)
    ///*
    /// Delete contract and transfer remaining balance into specified account
    case contractDeleteInstance(Proto_ContractDeleteTransactionBody)
    ///*
    /// An Ethereum encoded transaction.
    case ethereumTransaction(Proto_EthereumTransactionBody)
    ///*
    /// Attach a new livehash to an account
    case cryptoAddLiveHash(Proto_CryptoAddLiveHashTransactionBody)
    ///*
    /// Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
    case cryptoApproveAllowance(Proto_CryptoApproveAllowanceTransactionBody)
    ///*
    /// Deletes one or more of the specific approved NFT serial numbers on an owner account.
    case cryptoDeleteAllowance(Proto_CryptoDeleteAllowanceTransactionBody)
    ///*
    /// Create a new cryptocurrency account
    case cryptoCreateAccount(Proto_CryptoCreateTransactionBody)
    ///*
    /// Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
    case cryptoDelete(Proto_CryptoDeleteTransactionBody)
    ///*
    /// Remove a livehash from an account
    case cryptoDeleteLiveHash(Proto_CryptoDeleteLiveHashTransactionBody)
    ///*
    /// Transfer amount between accounts
    case cryptoTransfer(Proto_CryptoTransferTransactionBody)
    ///*
    /// Modify information such as the expiration date for an account
    case cryptoUpdateAccount(Proto_CryptoUpdateTransactionBody)
    ///*
    /// Add bytes to the end of the contents of a file
    case fileAppend(Proto_FileAppendTransactionBody)
    ///*
    /// Create a new file
    case fileCreate(Proto_FileCreateTransactionBody)
    ///*
    /// Delete a file (remove contents and mark as deleted until it expires)
    case fileDelete(Proto_FileDeleteTransactionBody)
    ///*
    /// Modify information such as the expiration date for a file
    case fileUpdate(Proto_FileUpdateTransactionBody)
    ///*
    /// Hedera administrative deletion of a file or smart contract
    case systemDelete(Proto_SystemDeleteTransactionBody)
    ///*
    /// To undelete an entity deleted by SystemDelete
    case systemUndelete(Proto_SystemUndeleteTransactionBody)
    ///*
    /// Freeze the nodes
    case freeze(Proto_FreezeTransactionBody)
    ///*
    /// Creates a topic
    case consensusCreateTopic(Proto_ConsensusCreateTopicTransactionBody)
    ///*
    /// Updates a topic
    case consensusUpdateTopic(Proto_ConsensusUpdateTopicTransactionBody)
    ///*
    /// Deletes a topic
    case consensusDeleteTopic(Proto_ConsensusDeleteTopicTransactionBody)
    ///*
    /// Submits message to a topic
    case consensusSubmitMessage(Proto_ConsensusSubmitMessageTransactionBody)
    ///*
    /// UNDOCUMENTED
    case uncheckedSubmit(Proto_UncheckedSubmitBody)
    ///*
    /// Creates a token instance
    case tokenCreation(Proto_TokenCreateTransactionBody)
    ///*
    /// Freezes account not to be able to transact with a token
    case tokenFreeze(Proto_TokenFreezeAccountTransactionBody)
    ///*
    /// Unfreezes account for a token
    case tokenUnfreeze(Proto_TokenUnfreezeAccountTransactionBody)
    ///*
    /// Grants KYC to an account for a token
    case tokenGrantKyc(Proto_TokenGrantKycTransactionBody)
    ///*
    /// Revokes KYC of an account for a token
    case tokenRevokeKyc(Proto_TokenRevokeKycTransactionBody)
    ///*
    /// Deletes a token instance
    case tokenDeletion(Proto_TokenDeleteTransactionBody)
    ///*
    /// Updates a token instance
    case tokenUpdate(Proto_TokenUpdateTransactionBody)
    ///*
    /// Mints new tokens to a token's treasury account
    case tokenMint(Proto_TokenMintTransactionBody)
    ///*
    /// Burns tokens from a token's treasury account
    case tokenBurn(Proto_TokenBurnTransactionBody)
    ///*
    /// Wipes amount of tokens from an account
    case tokenWipe(Proto_TokenWipeAccountTransactionBody)
    ///*
    /// Associate tokens to an account
    case tokenAssociate(Proto_TokenAssociateTransactionBody)
    ///*
    /// Dissociate tokens from an account
    case tokenDissociate(Proto_TokenDissociateTransactionBody)
    ///*
    /// Updates a token's custom fee schedule
    case tokenFeeScheduleUpdate(Proto_TokenFeeScheduleUpdateTransactionBody)
    ///*
    /// Pauses the Token
    case tokenPause(Proto_TokenPauseTransactionBody)
    ///*
    /// Unpauses the Token
    case tokenUnpause(Proto_TokenUnpauseTransactionBody)
    ///*
    /// Creates a schedule in the network's action queue
    case scheduleCreate(Proto_ScheduleCreateTransactionBody)
    ///*
    /// Deletes a schedule from the network's action queue
    case scheduleDelete(Proto_ScheduleDeleteTransactionBody)
    ///*
    /// Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction
    case scheduleSign(Proto_ScheduleSignTransactionBody)
    ///*
    /// Updates the staking info at the end of staking period to indicate new staking period has started.
    case nodeStakeUpdate(Proto_NodeStakeUpdateTransactionBody)
    ///*
    /// Generates a pseudorandom number.
    case utilPrng(Proto_UtilPrngTransactionBody)
    ///*
    /// Update the metadata of one or more NFT's of a specific token type.
    case tokenUpdateNfts(Proto_TokenUpdateNftsTransactionBody)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_TransactionBody.OneOf_Data, rhs: Proto_TransactionBody.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contractCall, .contractCall): return {
        guard case .contractCall(let l) = lhs, case .contractCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractCreateInstance, .contractCreateInstance): return {
        guard case .contractCreateInstance(let l) = lhs, case .contractCreateInstance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractUpdateInstance, .contractUpdateInstance): return {
        guard case .contractUpdateInstance(let l) = lhs, case .contractUpdateInstance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractDeleteInstance, .contractDeleteInstance): return {
        guard case .contractDeleteInstance(let l) = lhs, case .contractDeleteInstance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ethereumTransaction, .ethereumTransaction): return {
        guard case .ethereumTransaction(let l) = lhs, case .ethereumTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoAddLiveHash, .cryptoAddLiveHash): return {
        guard case .cryptoAddLiveHash(let l) = lhs, case .cryptoAddLiveHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoApproveAllowance, .cryptoApproveAllowance): return {
        guard case .cryptoApproveAllowance(let l) = lhs, case .cryptoApproveAllowance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoDeleteAllowance, .cryptoDeleteAllowance): return {
        guard case .cryptoDeleteAllowance(let l) = lhs, case .cryptoDeleteAllowance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoCreateAccount, .cryptoCreateAccount): return {
        guard case .cryptoCreateAccount(let l) = lhs, case .cryptoCreateAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoDelete, .cryptoDelete): return {
        guard case .cryptoDelete(let l) = lhs, case .cryptoDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoDeleteLiveHash, .cryptoDeleteLiveHash): return {
        guard case .cryptoDeleteLiveHash(let l) = lhs, case .cryptoDeleteLiveHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoTransfer, .cryptoTransfer): return {
        guard case .cryptoTransfer(let l) = lhs, case .cryptoTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoUpdateAccount, .cryptoUpdateAccount): return {
        guard case .cryptoUpdateAccount(let l) = lhs, case .cryptoUpdateAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileAppend, .fileAppend): return {
        guard case .fileAppend(let l) = lhs, case .fileAppend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileCreate, .fileCreate): return {
        guard case .fileCreate(let l) = lhs, case .fileCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileDelete, .fileDelete): return {
        guard case .fileDelete(let l) = lhs, case .fileDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileUpdate, .fileUpdate): return {
        guard case .fileUpdate(let l) = lhs, case .fileUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemDelete, .systemDelete): return {
        guard case .systemDelete(let l) = lhs, case .systemDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemUndelete, .systemUndelete): return {
        guard case .systemUndelete(let l) = lhs, case .systemUndelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.freeze, .freeze): return {
        guard case .freeze(let l) = lhs, case .freeze(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.consensusCreateTopic, .consensusCreateTopic): return {
        guard case .consensusCreateTopic(let l) = lhs, case .consensusCreateTopic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.consensusUpdateTopic, .consensusUpdateTopic): return {
        guard case .consensusUpdateTopic(let l) = lhs, case .consensusUpdateTopic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.consensusDeleteTopic, .consensusDeleteTopic): return {
        guard case .consensusDeleteTopic(let l) = lhs, case .consensusDeleteTopic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.consensusSubmitMessage, .consensusSubmitMessage): return {
        guard case .consensusSubmitMessage(let l) = lhs, case .consensusSubmitMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uncheckedSubmit, .uncheckedSubmit): return {
        guard case .uncheckedSubmit(let l) = lhs, case .uncheckedSubmit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenCreation, .tokenCreation): return {
        guard case .tokenCreation(let l) = lhs, case .tokenCreation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenFreeze, .tokenFreeze): return {
        guard case .tokenFreeze(let l) = lhs, case .tokenFreeze(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenUnfreeze, .tokenUnfreeze): return {
        guard case .tokenUnfreeze(let l) = lhs, case .tokenUnfreeze(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenGrantKyc, .tokenGrantKyc): return {
        guard case .tokenGrantKyc(let l) = lhs, case .tokenGrantKyc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenRevokeKyc, .tokenRevokeKyc): return {
        guard case .tokenRevokeKyc(let l) = lhs, case .tokenRevokeKyc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenDeletion, .tokenDeletion): return {
        guard case .tokenDeletion(let l) = lhs, case .tokenDeletion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenUpdate, .tokenUpdate): return {
        guard case .tokenUpdate(let l) = lhs, case .tokenUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenMint, .tokenMint): return {
        guard case .tokenMint(let l) = lhs, case .tokenMint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenBurn, .tokenBurn): return {
        guard case .tokenBurn(let l) = lhs, case .tokenBurn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenWipe, .tokenWipe): return {
        guard case .tokenWipe(let l) = lhs, case .tokenWipe(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenAssociate, .tokenAssociate): return {
        guard case .tokenAssociate(let l) = lhs, case .tokenAssociate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenDissociate, .tokenDissociate): return {
        guard case .tokenDissociate(let l) = lhs, case .tokenDissociate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenFeeScheduleUpdate, .tokenFeeScheduleUpdate): return {
        guard case .tokenFeeScheduleUpdate(let l) = lhs, case .tokenFeeScheduleUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenPause, .tokenPause): return {
        guard case .tokenPause(let l) = lhs, case .tokenPause(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenUnpause, .tokenUnpause): return {
        guard case .tokenUnpause(let l) = lhs, case .tokenUnpause(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scheduleCreate, .scheduleCreate): return {
        guard case .scheduleCreate(let l) = lhs, case .scheduleCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scheduleDelete, .scheduleDelete): return {
        guard case .scheduleDelete(let l) = lhs, case .scheduleDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scheduleSign, .scheduleSign): return {
        guard case .scheduleSign(let l) = lhs, case .scheduleSign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nodeStakeUpdate, .nodeStakeUpdate): return {
        guard case .nodeStakeUpdate(let l) = lhs, case .nodeStakeUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.utilPrng, .utilPrng): return {
        guard case .utilPrng(let l) = lhs, case .utilPrng(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenUpdateNfts, .tokenUpdateNfts): return {
        guard case .tokenUpdateNfts(let l) = lhs, case .tokenUpdateNfts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_TransactionBody: @unchecked Sendable {}
extension Proto_TransactionBody.OneOf_Data: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_TransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionID"),
    2: .same(proto: "nodeAccountID"),
    3: .same(proto: "transactionFee"),
    4: .same(proto: "transactionValidDuration"),
    5: .same(proto: "generateRecord"),
    6: .same(proto: "memo"),
    7: .same(proto: "contractCall"),
    8: .same(proto: "contractCreateInstance"),
    9: .same(proto: "contractUpdateInstance"),
    22: .same(proto: "contractDeleteInstance"),
    50: .same(proto: "ethereumTransaction"),
    10: .same(proto: "cryptoAddLiveHash"),
    48: .same(proto: "cryptoApproveAllowance"),
    49: .same(proto: "cryptoDeleteAllowance"),
    11: .same(proto: "cryptoCreateAccount"),
    12: .same(proto: "cryptoDelete"),
    13: .same(proto: "cryptoDeleteLiveHash"),
    14: .same(proto: "cryptoTransfer"),
    15: .same(proto: "cryptoUpdateAccount"),
    16: .same(proto: "fileAppend"),
    17: .same(proto: "fileCreate"),
    18: .same(proto: "fileDelete"),
    19: .same(proto: "fileUpdate"),
    20: .same(proto: "systemDelete"),
    21: .same(proto: "systemUndelete"),
    23: .same(proto: "freeze"),
    24: .same(proto: "consensusCreateTopic"),
    25: .same(proto: "consensusUpdateTopic"),
    26: .same(proto: "consensusDeleteTopic"),
    27: .same(proto: "consensusSubmitMessage"),
    28: .same(proto: "uncheckedSubmit"),
    29: .same(proto: "tokenCreation"),
    31: .same(proto: "tokenFreeze"),
    32: .same(proto: "tokenUnfreeze"),
    33: .same(proto: "tokenGrantKyc"),
    34: .same(proto: "tokenRevokeKyc"),
    35: .same(proto: "tokenDeletion"),
    36: .same(proto: "tokenUpdate"),
    37: .same(proto: "tokenMint"),
    38: .same(proto: "tokenBurn"),
    39: .same(proto: "tokenWipe"),
    40: .same(proto: "tokenAssociate"),
    41: .same(proto: "tokenDissociate"),
    45: .standard(proto: "token_fee_schedule_update"),
    46: .standard(proto: "token_pause"),
    47: .standard(proto: "token_unpause"),
    42: .same(proto: "scheduleCreate"),
    43: .same(proto: "scheduleDelete"),
    44: .same(proto: "scheduleSign"),
    51: .standard(proto: "node_stake_update"),
    52: .standard(proto: "util_prng"),
    53: .standard(proto: "token_update_nfts"),
  ]

  fileprivate class _StorageClass {
    var _transactionID: Proto_TransactionID? = nil
    var _nodeAccountID: Proto_AccountID? = nil
    var _transactionFee: UInt64 = 0
    var _transactionValidDuration: Proto_Duration? = nil
    var _generateRecord: Bool = false
    var _memo: String = String()
    var _data: Proto_TransactionBody.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionID = source._transactionID
      _nodeAccountID = source._nodeAccountID
      _transactionFee = source._transactionFee
      _transactionValidDuration = source._transactionValidDuration
      _generateRecord = source._generateRecord
      _memo = source._memo
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._transactionID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nodeAccountID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._transactionFee) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._transactionValidDuration) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._generateRecord) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 7: try {
          var v: Proto_ContractCallTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .contractCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .contractCall(v)
          }
        }()
        case 8: try {
          var v: Proto_ContractCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .contractCreateInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .contractCreateInstance(v)
          }
        }()
        case 9: try {
          var v: Proto_ContractUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .contractUpdateInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .contractUpdateInstance(v)
          }
        }()
        case 10: try {
          var v: Proto_CryptoAddLiveHashTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoAddLiveHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoAddLiveHash(v)
          }
        }()
        case 11: try {
          var v: Proto_CryptoCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoCreateAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoCreateAccount(v)
          }
        }()
        case 12: try {
          var v: Proto_CryptoDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoDelete(v)
          }
        }()
        case 13: try {
          var v: Proto_CryptoDeleteLiveHashTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoDeleteLiveHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoDeleteLiveHash(v)
          }
        }()
        case 14: try {
          var v: Proto_CryptoTransferTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoTransfer(v)
          }
        }()
        case 15: try {
          var v: Proto_CryptoUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoUpdateAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoUpdateAccount(v)
          }
        }()
        case 16: try {
          var v: Proto_FileAppendTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .fileAppend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .fileAppend(v)
          }
        }()
        case 17: try {
          var v: Proto_FileCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .fileCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .fileCreate(v)
          }
        }()
        case 18: try {
          var v: Proto_FileDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .fileDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .fileDelete(v)
          }
        }()
        case 19: try {
          var v: Proto_FileUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .fileUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .fileUpdate(v)
          }
        }()
        case 20: try {
          var v: Proto_SystemDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .systemDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .systemDelete(v)
          }
        }()
        case 21: try {
          var v: Proto_SystemUndeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .systemUndelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .systemUndelete(v)
          }
        }()
        case 22: try {
          var v: Proto_ContractDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .contractDeleteInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .contractDeleteInstance(v)
          }
        }()
        case 23: try {
          var v: Proto_FreezeTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .freeze(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .freeze(v)
          }
        }()
        case 24: try {
          var v: Proto_ConsensusCreateTopicTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .consensusCreateTopic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .consensusCreateTopic(v)
          }
        }()
        case 25: try {
          var v: Proto_ConsensusUpdateTopicTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .consensusUpdateTopic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .consensusUpdateTopic(v)
          }
        }()
        case 26: try {
          var v: Proto_ConsensusDeleteTopicTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .consensusDeleteTopic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .consensusDeleteTopic(v)
          }
        }()
        case 27: try {
          var v: Proto_ConsensusSubmitMessageTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .consensusSubmitMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .consensusSubmitMessage(v)
          }
        }()
        case 28: try {
          var v: Proto_UncheckedSubmitBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .uncheckedSubmit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .uncheckedSubmit(v)
          }
        }()
        case 29: try {
          var v: Proto_TokenCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenCreation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenCreation(v)
          }
        }()
        case 31: try {
          var v: Proto_TokenFreezeAccountTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenFreeze(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenFreeze(v)
          }
        }()
        case 32: try {
          var v: Proto_TokenUnfreezeAccountTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenUnfreeze(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenUnfreeze(v)
          }
        }()
        case 33: try {
          var v: Proto_TokenGrantKycTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenGrantKyc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenGrantKyc(v)
          }
        }()
        case 34: try {
          var v: Proto_TokenRevokeKycTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenRevokeKyc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenRevokeKyc(v)
          }
        }()
        case 35: try {
          var v: Proto_TokenDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenDeletion(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenDeletion(v)
          }
        }()
        case 36: try {
          var v: Proto_TokenUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenUpdate(v)
          }
        }()
        case 37: try {
          var v: Proto_TokenMintTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenMint(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenMint(v)
          }
        }()
        case 38: try {
          var v: Proto_TokenBurnTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenBurn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenBurn(v)
          }
        }()
        case 39: try {
          var v: Proto_TokenWipeAccountTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenWipe(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenWipe(v)
          }
        }()
        case 40: try {
          var v: Proto_TokenAssociateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenAssociate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenAssociate(v)
          }
        }()
        case 41: try {
          var v: Proto_TokenDissociateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenDissociate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenDissociate(v)
          }
        }()
        case 42: try {
          var v: Proto_ScheduleCreateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .scheduleCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .scheduleCreate(v)
          }
        }()
        case 43: try {
          var v: Proto_ScheduleDeleteTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .scheduleDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .scheduleDelete(v)
          }
        }()
        case 44: try {
          var v: Proto_ScheduleSignTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .scheduleSign(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .scheduleSign(v)
          }
        }()
        case 45: try {
          var v: Proto_TokenFeeScheduleUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenFeeScheduleUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenFeeScheduleUpdate(v)
          }
        }()
        case 46: try {
          var v: Proto_TokenPauseTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenPause(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenPause(v)
          }
        }()
        case 47: try {
          var v: Proto_TokenUnpauseTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenUnpause(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenUnpause(v)
          }
        }()
        case 48: try {
          var v: Proto_CryptoApproveAllowanceTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoApproveAllowance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoApproveAllowance(v)
          }
        }()
        case 49: try {
          var v: Proto_CryptoDeleteAllowanceTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .cryptoDeleteAllowance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .cryptoDeleteAllowance(v)
          }
        }()
        case 50: try {
          var v: Proto_EthereumTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .ethereumTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .ethereumTransaction(v)
          }
        }()
        case 51: try {
          var v: Proto_NodeStakeUpdateTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .nodeStakeUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .nodeStakeUpdate(v)
          }
        }()
        case 52: try {
          var v: Proto_UtilPrngTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .utilPrng(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .utilPrng(v)
          }
        }()
        case 53: try {
          var v: Proto_TokenUpdateNftsTransactionBody?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .tokenUpdateNfts(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .tokenUpdateNfts(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._transactionID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._nodeAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._transactionFee != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._transactionFee, fieldNumber: 3)
      }
      try { if let v = _storage._transactionValidDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._generateRecord != false {
        try visitor.visitSingularBoolField(value: _storage._generateRecord, fieldNumber: 5)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 6)
      }
      switch _storage._data {
      case .contractCall?: try {
        guard case .contractCall(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .contractCreateInstance?: try {
        guard case .contractCreateInstance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .contractUpdateInstance?: try {
        guard case .contractUpdateInstance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .cryptoAddLiveHash?: try {
        guard case .cryptoAddLiveHash(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .cryptoCreateAccount?: try {
        guard case .cryptoCreateAccount(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .cryptoDelete?: try {
        guard case .cryptoDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .cryptoDeleteLiveHash?: try {
        guard case .cryptoDeleteLiveHash(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .cryptoTransfer?: try {
        guard case .cryptoTransfer(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .cryptoUpdateAccount?: try {
        guard case .cryptoUpdateAccount(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .fileAppend?: try {
        guard case .fileAppend(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .fileCreate?: try {
        guard case .fileCreate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .fileDelete?: try {
        guard case .fileDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .fileUpdate?: try {
        guard case .fileUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .systemDelete?: try {
        guard case .systemDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .systemUndelete?: try {
        guard case .systemUndelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .contractDeleteInstance?: try {
        guard case .contractDeleteInstance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .freeze?: try {
        guard case .freeze(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .consensusCreateTopic?: try {
        guard case .consensusCreateTopic(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .consensusUpdateTopic?: try {
        guard case .consensusUpdateTopic(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .consensusDeleteTopic?: try {
        guard case .consensusDeleteTopic(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .consensusSubmitMessage?: try {
        guard case .consensusSubmitMessage(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .uncheckedSubmit?: try {
        guard case .uncheckedSubmit(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .tokenCreation?: try {
        guard case .tokenCreation(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .tokenFreeze?: try {
        guard case .tokenFreeze(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .tokenUnfreeze?: try {
        guard case .tokenUnfreeze(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .tokenGrantKyc?: try {
        guard case .tokenGrantKyc(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .tokenRevokeKyc?: try {
        guard case .tokenRevokeKyc(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .tokenDeletion?: try {
        guard case .tokenDeletion(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .tokenUpdate?: try {
        guard case .tokenUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .tokenMint?: try {
        guard case .tokenMint(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .tokenBurn?: try {
        guard case .tokenBurn(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .tokenWipe?: try {
        guard case .tokenWipe(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .tokenAssociate?: try {
        guard case .tokenAssociate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .tokenDissociate?: try {
        guard case .tokenDissociate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .scheduleCreate?: try {
        guard case .scheduleCreate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .scheduleDelete?: try {
        guard case .scheduleDelete(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .scheduleSign?: try {
        guard case .scheduleSign(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .tokenFeeScheduleUpdate?: try {
        guard case .tokenFeeScheduleUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .tokenPause?: try {
        guard case .tokenPause(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .tokenUnpause?: try {
        guard case .tokenUnpause(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .cryptoApproveAllowance?: try {
        guard case .cryptoApproveAllowance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .cryptoDeleteAllowance?: try {
        guard case .cryptoDeleteAllowance(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .ethereumTransaction?: try {
        guard case .ethereumTransaction(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .nodeStakeUpdate?: try {
        guard case .nodeStakeUpdate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .utilPrng?: try {
        guard case .utilPrng(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .tokenUpdateNfts?: try {
        guard case .tokenUpdateNfts(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionBody, rhs: Proto_TransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._nodeAccountID != rhs_storage._nodeAccountID {return false}
        if _storage._transactionFee != rhs_storage._transactionFee {return false}
        if _storage._transactionValidDuration != rhs_storage._transactionValidDuration {return false}
        if _storage._generateRecord != rhs_storage._generateRecord {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
