// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction_receipt.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// The summary of a transaction's result so far. If the transaction has not reached consensus, this
/// result will be necessarily incomplete.
public struct Proto_TransactionReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if
  /// the associated transaction did not have a valid payer signature
  public var status: Proto_ResponseCodeEnum {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  ///*
  /// In the receipt of a CryptoCreate, the id of the newly created account
  public var accountID: Proto_AccountID {
    get {return _storage._accountID ?? Proto_AccountID()}
    set {_uniqueStorage()._accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return _storage._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

  ///*
  /// In the receipt of a FileCreate, the id of the newly created file
  public var fileID: Proto_FileID {
    get {return _storage._fileID ?? Proto_FileID()}
    set {_uniqueStorage()._fileID = newValue}
  }
  /// Returns true if `fileID` has been explicitly set.
  public var hasFileID: Bool {return _storage._fileID != nil}
  /// Clears the value of `fileID`. Subsequent reads from it will return its default value.
  public mutating func clearFileID() {_uniqueStorage()._fileID = nil}

  ///*
  /// In the receipt of a ContractCreate, the id of the newly created contract
  public var contractID: Proto_ContractID {
    get {return _storage._contractID ?? Proto_ContractID()}
    set {_uniqueStorage()._contractID = newValue}
  }
  /// Returns true if `contractID` has been explicitly set.
  public var hasContractID: Bool {return _storage._contractID != nil}
  /// Clears the value of `contractID`. Subsequent reads from it will return its default value.
  public mutating func clearContractID() {_uniqueStorage()._contractID = nil}

  ///*
  /// The exchange rates in effect when the transaction reached consensus
  public var exchangeRate: Proto_ExchangeRateSet {
    get {return _storage._exchangeRate ?? Proto_ExchangeRateSet()}
    set {_uniqueStorage()._exchangeRate = newValue}
  }
  /// Returns true if `exchangeRate` has been explicitly set.
  public var hasExchangeRate: Bool {return _storage._exchangeRate != nil}
  /// Clears the value of `exchangeRate`. Subsequent reads from it will return its default value.
  public mutating func clearExchangeRate() {_uniqueStorage()._exchangeRate = nil}

  ///*
  /// In the receipt of a ConsensusCreateTopic, the id of the newly created topic.
  public var topicID: Proto_TopicID {
    get {return _storage._topicID ?? Proto_TopicID()}
    set {_uniqueStorage()._topicID = newValue}
  }
  /// Returns true if `topicID` has been explicitly set.
  public var hasTopicID: Bool {return _storage._topicID != nil}
  /// Clears the value of `topicID`. Subsequent reads from it will return its default value.
  public mutating func clearTopicID() {_uniqueStorage()._topicID = nil}

  ///*
  /// In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that
  /// received the message
  public var topicSequenceNumber: UInt64 {
    get {return _storage._topicSequenceNumber}
    set {_uniqueStorage()._topicSequenceNumber = newValue}
  }

  ///*
  /// In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received
  /// the message.  This 48-byte field is the output of a particular SHA-384 digest whose input
  /// data are determined by the value of the topicRunningHashVersion below. The bytes of each
  /// uint64 or uint32 are to be in Big-Endian format.
  ///
  /// IF the topicRunningHashVersion is '0' or '1', then the input data to the SHA-384 digest are,
  /// in order:
  /// ---
  /// 1. The previous running hash of the topic (48 bytes)
  /// 2. The topic's shard (8 bytes)
  /// 3. The topic's realm (8 bytes)
  /// 4. The topic's number (8 bytes)
  /// 5. The number of seconds since the epoch before the ConsensusSubmitMessage reached
  ///    consensus (8 bytes)
  /// 6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached
  ///    consensus (4 bytes)
  /// 7. The topicSequenceNumber from above (8 bytes)
  /// 8. The message bytes from the ConsensusSubmitMessage (variable).
  ///
  /// IF the topicRunningHashVersion is '2', then the input data to the SHA-384 digest are, in
  /// order:
  /// ---
  /// 1. The previous running hash of the topic (48 bytes)
  /// 2. The topicRunningHashVersion below (8 bytes)
  /// 3. The topic's shard (8 bytes)
  /// 4. The topic's realm (8 bytes)
  /// 5. The topic's number (8 bytes)
  /// 6. The number of seconds since the epoch before the ConsensusSubmitMessage reached
  ///    consensus (8 bytes)
  /// 7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached
  ///    consensus (4 bytes)
  /// 8. The topicSequenceNumber from above (8 bytes)
  /// 9. The output of the SHA-384 digest of the message bytes from the
  ///    consensusSubmitMessage (48 bytes)
  ///
  /// Otherwise, IF the topicRunningHashVersion is '3', then the input data to the SHA-384 digest
  /// are, in order:
  /// ---
  /// 1. The previous running hash of the topic (48 bytes)
  /// 2. The topicRunningHashVersion below (8 bytes)
  /// 3. The payer account's shard (8 bytes)
  /// 4. The payer account's realm (8 bytes)
  /// 5. The payer account's number (8 bytes)
  /// 6. The topic's shard (8 bytes)
  /// 7. The topic's realm (8 bytes)
  /// 8. The topic's number (8 bytes)
  /// 9. The number of seconds since the epoch before the ConsensusSubmitMessage reached
  ///    consensus (8 bytes)
  /// 10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached
  ///     consensus (4 bytes)
  /// 11. The topicSequenceNumber from above (8 bytes)
  /// 12. The output of the SHA-384 digest of the message bytes from the
  ///     consensusSubmitMessage (48 bytes)
  public var topicRunningHash: Data {
    get {return _storage._topicRunningHash}
    set {_uniqueStorage()._topicRunningHash = newValue}
  }

  ///*
  /// In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update
  /// the running hash.
  public var topicRunningHashVersion: UInt64 {
    get {return _storage._topicRunningHashVersion}
    set {_uniqueStorage()._topicRunningHashVersion = newValue}
  }

  ///*
  /// In the receipt of a CreateToken, the id of the newly created token
  public var tokenID: Proto_TokenID {
    get {return _storage._tokenID ?? Proto_TokenID()}
    set {_uniqueStorage()._tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return _storage._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {_uniqueStorage()._tokenID = nil}

  ///*
  /// In the receipt of TokenMint, TokenWipe, TokenBurn, For fungible tokens - the current total
  /// supply of this token. For non fungible tokens - the total number of NFTs issued for a given
  /// tokenID
  public var newTotalSupply: UInt64 {
    get {return _storage._newTotalSupply}
    set {_uniqueStorage()._newTotalSupply = newValue}
  }

  ///*
  /// In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity
  public var scheduleID: Proto_ScheduleID {
    get {return _storage._scheduleID ?? Proto_ScheduleID()}
    set {_uniqueStorage()._scheduleID = newValue}
  }
  /// Returns true if `scheduleID` has been explicitly set.
  public var hasScheduleID: Bool {return _storage._scheduleID != nil}
  /// Clears the value of `scheduleID`. Subsequent reads from it will return its default value.
  public mutating func clearScheduleID() {_uniqueStorage()._scheduleID = nil}

  ///*
  /// In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the
  /// TransactionID that should be used to query for the receipt or record of the relevant
  /// scheduled transaction
  public var scheduledTransactionID: Proto_TransactionID {
    get {return _storage._scheduledTransactionID ?? Proto_TransactionID()}
    set {_uniqueStorage()._scheduledTransactionID = newValue}
  }
  /// Returns true if `scheduledTransactionID` has been explicitly set.
  public var hasScheduledTransactionID: Bool {return _storage._scheduledTransactionID != nil}
  /// Clears the value of `scheduledTransactionID`. Subsequent reads from it will return its default value.
  public mutating func clearScheduledTransactionID() {_uniqueStorage()._scheduledTransactionID = nil}

  ///*
  /// In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of
  /// the newly created NFTs
  public var serialNumbers: [Int64] {
    get {return _storage._serialNumbers}
    set {_uniqueStorage()._serialNumbers = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_TransactionReceipt: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_TransactionReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "accountID"),
    3: .same(proto: "fileID"),
    4: .same(proto: "contractID"),
    5: .same(proto: "exchangeRate"),
    6: .same(proto: "topicID"),
    7: .same(proto: "topicSequenceNumber"),
    8: .same(proto: "topicRunningHash"),
    9: .same(proto: "topicRunningHashVersion"),
    10: .same(proto: "tokenID"),
    11: .same(proto: "newTotalSupply"),
    12: .same(proto: "scheduleID"),
    13: .same(proto: "scheduledTransactionID"),
    14: .same(proto: "serialNumbers"),
  ]

  fileprivate class _StorageClass {
    var _status: Proto_ResponseCodeEnum = .ok
    var _accountID: Proto_AccountID? = nil
    var _fileID: Proto_FileID? = nil
    var _contractID: Proto_ContractID? = nil
    var _exchangeRate: Proto_ExchangeRateSet? = nil
    var _topicID: Proto_TopicID? = nil
    var _topicSequenceNumber: UInt64 = 0
    var _topicRunningHash: Data = Data()
    var _topicRunningHashVersion: UInt64 = 0
    var _tokenID: Proto_TokenID? = nil
    var _newTotalSupply: UInt64 = 0
    var _scheduleID: Proto_ScheduleID? = nil
    var _scheduledTransactionID: Proto_TransactionID? = nil
    var _serialNumbers: [Int64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _accountID = source._accountID
      _fileID = source._fileID
      _contractID = source._contractID
      _exchangeRate = source._exchangeRate
      _topicID = source._topicID
      _topicSequenceNumber = source._topicSequenceNumber
      _topicRunningHash = source._topicRunningHash
      _topicRunningHashVersion = source._topicRunningHashVersion
      _tokenID = source._tokenID
      _newTotalSupply = source._newTotalSupply
      _scheduleID = source._scheduleID
      _scheduledTransactionID = source._scheduledTransactionID
      _serialNumbers = source._serialNumbers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._accountID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._fileID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._contractID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._exchangeRate) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._topicID) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._topicSequenceNumber) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._topicRunningHash) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._topicRunningHashVersion) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._tokenID) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._newTotalSupply) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleID) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTransactionID) }()
        case 14: try { try decoder.decodeRepeatedInt64Field(value: &_storage._serialNumbers) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._status != .ok {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 1)
      }
      try { if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._fileID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._contractID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._exchangeRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._topicID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._topicSequenceNumber != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._topicSequenceNumber, fieldNumber: 7)
      }
      if !_storage._topicRunningHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._topicRunningHash, fieldNumber: 8)
      }
      if _storage._topicRunningHashVersion != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._topicRunningHashVersion, fieldNumber: 9)
      }
      try { if let v = _storage._tokenID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._newTotalSupply != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._newTotalSupply, fieldNumber: 11)
      }
      try { if let v = _storage._scheduleID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._scheduledTransactionID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._serialNumbers.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._serialNumbers, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionReceipt, rhs: Proto_TransactionReceipt) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._fileID != rhs_storage._fileID {return false}
        if _storage._contractID != rhs_storage._contractID {return false}
        if _storage._exchangeRate != rhs_storage._exchangeRate {return false}
        if _storage._topicID != rhs_storage._topicID {return false}
        if _storage._topicSequenceNumber != rhs_storage._topicSequenceNumber {return false}
        if _storage._topicRunningHash != rhs_storage._topicRunningHash {return false}
        if _storage._topicRunningHashVersion != rhs_storage._topicRunningHashVersion {return false}
        if _storage._tokenID != rhs_storage._tokenID {return false}
        if _storage._newTotalSupply != rhs_storage._newTotalSupply {return false}
        if _storage._scheduleID != rhs_storage._scheduleID {return false}
        if _storage._scheduledTransactionID != rhs_storage._scheduledTransactionID {return false}
        if _storage._serialNumbers != rhs_storage._serialNumbers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
