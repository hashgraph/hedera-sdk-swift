// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state/blockrecords/block_info.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Information about ongoing, most recently completed, and last 256 blocks.
public struct Proto_BlockInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The last block number, this is the last completed immutable block.
  public var lastBlockNumber: Int64 = 0

  ///*
  /// The consensus time of the first transaction of the last block, this is the last completed immutable block.
  public var firstConsTimeOfLastBlock: Proto_Timestamp {
    get {return _firstConsTimeOfLastBlock ?? Proto_Timestamp()}
    set {_firstConsTimeOfLastBlock = newValue}
  }
  /// Returns true if `firstConsTimeOfLastBlock` has been explicitly set.
  public var hasFirstConsTimeOfLastBlock: Bool {return self._firstConsTimeOfLastBlock != nil}
  /// Clears the value of `firstConsTimeOfLastBlock`. Subsequent reads from it will return its default value.
  public mutating func clearFirstConsTimeOfLastBlock() {self._firstConsTimeOfLastBlock = nil}

  ///*
  /// SHA384 48 byte hashes of the last 256 blocks in single byte array.
  /// First 48 bytes is the oldest block.
  /// Last 48 bytes is the newest block, which is the last fully completed immutable block.
  /// If we are shortly after genesis and there are less than 256 blocks then this could contain less than 256 hashes.
  public var blockHashes: Data = Data()

  ///*
  /// The consensus time of the last transaction that was handled by the node. This property is how we 'advance the
  /// consensus clock', i.e. continually setting this property to the latest consensus timestamp (and thus transaction)
  /// handled by the node.
  public var consTimeOfLastHandledTxn: Proto_Timestamp {
    get {return _consTimeOfLastHandledTxn ?? Proto_Timestamp()}
    set {_consTimeOfLastHandledTxn = newValue}
  }
  /// Returns true if `consTimeOfLastHandledTxn` has been explicitly set.
  public var hasConsTimeOfLastHandledTxn: Bool {return self._consTimeOfLastHandledTxn != nil}
  /// Clears the value of `consTimeOfLastHandledTxn`. Subsequent reads from it will return its default value.
  public mutating func clearConsTimeOfLastHandledTxn() {self._consTimeOfLastHandledTxn = nil}

  ///*
  /// A flag indicating whether migration records have been published. This property should be marked 'false'
  /// immediately following a node upgrade, and marked 'true' once the migration records (if any) are published, which
  /// should happen during the first transaction handled by the node.
  public var migrationRecordsStreamed: Bool = false

  ///*
  /// The consensus time of the first transaction in the current block; necessary for reconnecting nodes to detect
  /// when the current block is finished.
  public var firstConsTimeOfCurrentBlock: Proto_Timestamp {
    get {return _firstConsTimeOfCurrentBlock ?? Proto_Timestamp()}
    set {_firstConsTimeOfCurrentBlock = newValue}
  }
  /// Returns true if `firstConsTimeOfCurrentBlock` has been explicitly set.
  public var hasFirstConsTimeOfCurrentBlock: Bool {return self._firstConsTimeOfCurrentBlock != nil}
  /// Clears the value of `firstConsTimeOfCurrentBlock`. Subsequent reads from it will return its default value.
  public mutating func clearFirstConsTimeOfCurrentBlock() {self._firstConsTimeOfCurrentBlock = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _firstConsTimeOfLastBlock: Proto_Timestamp? = nil
  fileprivate var _consTimeOfLastHandledTxn: Proto_Timestamp? = nil
  fileprivate var _firstConsTimeOfCurrentBlock: Proto_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_BlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_block_number"),
    2: .standard(proto: "first_cons_time_of_last_block"),
    3: .standard(proto: "block_hashes"),
    4: .standard(proto: "cons_time_of_last_handled_txn"),
    5: .standard(proto: "migration_records_streamed"),
    6: .standard(proto: "first_cons_time_of_current_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lastBlockNumber) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._firstConsTimeOfLastBlock) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.blockHashes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._consTimeOfLastHandledTxn) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.migrationRecordsStreamed) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._firstConsTimeOfCurrentBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.lastBlockNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.lastBlockNumber, fieldNumber: 1)
    }
    try { if let v = self._firstConsTimeOfLastBlock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.blockHashes.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHashes, fieldNumber: 3)
    }
    try { if let v = self._consTimeOfLastHandledTxn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.migrationRecordsStreamed != false {
      try visitor.visitSingularBoolField(value: self.migrationRecordsStreamed, fieldNumber: 5)
    }
    try { if let v = self._firstConsTimeOfCurrentBlock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_BlockInfo, rhs: Proto_BlockInfo) -> Bool {
    if lhs.lastBlockNumber != rhs.lastBlockNumber {return false}
    if lhs._firstConsTimeOfLastBlock != rhs._firstConsTimeOfLastBlock {return false}
    if lhs.blockHashes != rhs.blockHashes {return false}
    if lhs._consTimeOfLastHandledTxn != rhs._consTimeOfLastHandledTxn {return false}
    if lhs.migrationRecordsStreamed != rhs.migrationRecordsStreamed {return false}
    if lhs._firstConsTimeOfCurrentBlock != rhs._firstConsTimeOfCurrentBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
