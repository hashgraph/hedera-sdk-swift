// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state/schedule/schedule.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Representation of a Hedera Schedule entry in the network Merkle tree.
///
/// As with all network entities, a schedule has a unique entity number, which is usually given along
/// with the network's shard and realm in the form of a shard.realm.number id.
public struct Proto_Schedule: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// This schedule's unique ID within the global network state.
  public var scheduleID: Proto_ScheduleID {
    get {return _storage._scheduleID ?? Proto_ScheduleID()}
    set {_uniqueStorage()._scheduleID = newValue}
  }
  /// Returns true if `scheduleID` has been explicitly set.
  public var hasScheduleID: Bool {return _storage._scheduleID != nil}
  /// Clears the value of `scheduleID`. Subsequent reads from it will return its default value.
  public mutating func clearScheduleID() {_uniqueStorage()._scheduleID = nil}

  ///*
  /// The schedule deleted flag
  /// A schedule will either be executed or deleted, but never both.
  public var deleted: Bool {
    get {return _storage._deleted}
    set {_uniqueStorage()._deleted = newValue}
  }

  ///*
  /// The schedule executed flag
  /// A schedule will either be executed or deleted, but never both.
  public var executed: Bool {
    get {return _storage._executed}
    set {_uniqueStorage()._executed = newValue}
  }

  ///*
  /// The schedule flag to wait for expiration
  /// A schedule will be executed immediately when all necessary signatures are gathered, unless
  /// this flag is set.  If this flag is set, the schedule will wait until the consensus time
  /// reaches expiration_time_provided, when signatures will again be verified, and if all
  /// required signatures are present at that time, the schedule will be executed.  Otherwise
  /// the schedule will expire without execution.
  /// Note that a schedule is always removed from state when it expires, regardless of whether it
  /// was executed or not.
  public var waitForExpiry: Bool {
    get {return _storage._waitForExpiry}
    set {_uniqueStorage()._waitForExpiry = newValue}
  }

  ///*
  /// The memo associated with this schedule.
  public var memo: String {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  ///*
  /// The schedule account for this schedule.  This is the account that submitted the original
  /// ScheduleCreate transaction.
  public var schedulerAccountID: Proto_AccountID {
    get {return _storage._schedulerAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._schedulerAccountID = newValue}
  }
  /// Returns true if `schedulerAccountID` has been explicitly set.
  public var hasSchedulerAccountID: Bool {return _storage._schedulerAccountID != nil}
  /// Clears the value of `schedulerAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearSchedulerAccountID() {_uniqueStorage()._schedulerAccountID = nil}

  ///*
  /// The explicit payer account for the scheduled transaction.
  /// This account is added to the accounts that must sign the schedule before it will execute.
  public var payerAccountID: Proto_AccountID {
    get {return _storage._payerAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._payerAccountID = newValue}
  }
  /// Returns true if `payerAccountID` has been explicitly set.
  public var hasPayerAccountID: Bool {return _storage._payerAccountID != nil}
  /// Clears the value of `payerAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearPayerAccountID() {_uniqueStorage()._payerAccountID = nil}

  ///*
  /// The admin key for this schedule.
  /// If this is not set, then the schedule cannot be deleted.
  public var adminKey: Proto_Key {
    get {return _storage._adminKey ?? Proto_Key()}
    set {_uniqueStorage()._adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return _storage._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {_uniqueStorage()._adminKey = nil}

  ///*
  /// The transaction valid start value from the transaction that created this schedule.
  public var scheduleValidStart: Proto_Timestamp {
    get {return _storage._scheduleValidStart ?? Proto_Timestamp()}
    set {_uniqueStorage()._scheduleValidStart = newValue}
  }
  /// Returns true if `scheduleValidStart` has been explicitly set.
  public var hasScheduleValidStart: Bool {return _storage._scheduleValidStart != nil}
  /// Clears the value of `scheduleValidStart`. Subsequent reads from it will return its default value.
  public mutating func clearScheduleValidStart() {_uniqueStorage()._scheduleValidStart = nil}

  ///*
  /// The requested expiration time of the schedule as provided by the user.
  /// The actual calculated expiration time may be "earlier" than this, but will not be later.
  public var providedExpirationSecond: Int64 {
    get {return _storage._providedExpirationSecond}
    set {_uniqueStorage()._providedExpirationSecond = newValue}
  }

  ///*
  /// The calculated expiration time of the schedule.  This is calculated based on the requested
  /// expiration time from the create transaction, and the maximum expiration permitted by the
  /// network.
  /// The schedule will be removed from global network state after the network reaches a consensus
  /// time greater than or equal to this value.
  public var calculatedExpirationSecond: Int64 {
    get {return _storage._calculatedExpirationSecond}
    set {_uniqueStorage()._calculatedExpirationSecond = newValue}
  }

  ///*
  /// The consensus timestamp of the transaction that executed or deleted this schedule.
  public var resolutionTime: Proto_Timestamp {
    get {return _storage._resolutionTime ?? Proto_Timestamp()}
    set {_uniqueStorage()._resolutionTime = newValue}
  }
  /// Returns true if `resolutionTime` has been explicitly set.
  public var hasResolutionTime: Bool {return _storage._resolutionTime != nil}
  /// Clears the value of `resolutionTime`. Subsequent reads from it will return its default value.
  public mutating func clearResolutionTime() {_uniqueStorage()._resolutionTime = nil}

  ///*
  /// The scheduled transaction to execute.
  public var scheduledTransaction: Proto_SchedulableTransactionBody {
    get {return _storage._scheduledTransaction ?? Proto_SchedulableTransactionBody()}
    set {_uniqueStorage()._scheduledTransaction = newValue}
  }
  /// Returns true if `scheduledTransaction` has been explicitly set.
  public var hasScheduledTransaction: Bool {return _storage._scheduledTransaction != nil}
  /// Clears the value of `scheduledTransaction`. Subsequent reads from it will return its default value.
  public mutating func clearScheduledTransaction() {_uniqueStorage()._scheduledTransaction = nil}

  ///*
  /// The full transaction that created this schedule.  This is primarily used for duplicate
  /// schedule create detection.  This is also the source of the parent transaction ID, from
  /// which the child transaction ID is derived.
  public var originalCreateTransaction: Proto_TransactionBody {
    get {return _storage._originalCreateTransaction ?? Proto_TransactionBody()}
    set {_uniqueStorage()._originalCreateTransaction = newValue}
  }
  /// Returns true if `originalCreateTransaction` has been explicitly set.
  public var hasOriginalCreateTransaction: Bool {return _storage._originalCreateTransaction != nil}
  /// Clears the value of `originalCreateTransaction`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalCreateTransaction() {_uniqueStorage()._originalCreateTransaction = nil}

  ///*
  /// All the primitive keys that have already signed this schedule.
  /// The scheduled transaction will not be executed before this list is
  /// sufficient to "activate" the required keys for the scheduled transaction.
  public var signatories: [Proto_Key] {
    get {return _storage._signatories}
    set {_uniqueStorage()._signatories = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A message for storing a list of schedules in state.
/// This is used to store lists of schedules that expire at a particular time or that have the same
/// simplified hash code.
public struct Proto_ScheduleList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// a list of schedules, in no particular order.
  public var schedules: [Proto_Schedule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Schedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "schedule_id"),
    2: .same(proto: "deleted"),
    3: .same(proto: "executed"),
    4: .standard(proto: "wait_for_expiry"),
    5: .same(proto: "memo"),
    6: .standard(proto: "scheduler_account_id"),
    7: .standard(proto: "payer_account_id"),
    8: .standard(proto: "admin_key"),
    9: .standard(proto: "schedule_valid_start"),
    10: .standard(proto: "provided_expiration_second"),
    11: .standard(proto: "calculated_expiration_second"),
    12: .standard(proto: "resolution_time"),
    13: .standard(proto: "scheduled_transaction"),
    14: .standard(proto: "original_create_transaction"),
    15: .same(proto: "signatories"),
  ]

  fileprivate class _StorageClass {
    var _scheduleID: Proto_ScheduleID? = nil
    var _deleted: Bool = false
    var _executed: Bool = false
    var _waitForExpiry: Bool = false
    var _memo: String = String()
    var _schedulerAccountID: Proto_AccountID? = nil
    var _payerAccountID: Proto_AccountID? = nil
    var _adminKey: Proto_Key? = nil
    var _scheduleValidStart: Proto_Timestamp? = nil
    var _providedExpirationSecond: Int64 = 0
    var _calculatedExpirationSecond: Int64 = 0
    var _resolutionTime: Proto_Timestamp? = nil
    var _scheduledTransaction: Proto_SchedulableTransactionBody? = nil
    var _originalCreateTransaction: Proto_TransactionBody? = nil
    var _signatories: [Proto_Key] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _scheduleID = source._scheduleID
      _deleted = source._deleted
      _executed = source._executed
      _waitForExpiry = source._waitForExpiry
      _memo = source._memo
      _schedulerAccountID = source._schedulerAccountID
      _payerAccountID = source._payerAccountID
      _adminKey = source._adminKey
      _scheduleValidStart = source._scheduleValidStart
      _providedExpirationSecond = source._providedExpirationSecond
      _calculatedExpirationSecond = source._calculatedExpirationSecond
      _resolutionTime = source._resolutionTime
      _scheduledTransaction = source._scheduledTransaction
      _originalCreateTransaction = source._originalCreateTransaction
      _signatories = source._signatories
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleID) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._deleted) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._executed) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._waitForExpiry) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._schedulerAccountID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._payerAccountID) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._adminKey) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleValidStart) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._providedExpirationSecond) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._calculatedExpirationSecond) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._resolutionTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTransaction) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._originalCreateTransaction) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._signatories) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._scheduleID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._deleted != false {
        try visitor.visitSingularBoolField(value: _storage._deleted, fieldNumber: 2)
      }
      if _storage._executed != false {
        try visitor.visitSingularBoolField(value: _storage._executed, fieldNumber: 3)
      }
      if _storage._waitForExpiry != false {
        try visitor.visitSingularBoolField(value: _storage._waitForExpiry, fieldNumber: 4)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 5)
      }
      try { if let v = _storage._schedulerAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._payerAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._adminKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._scheduleValidStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._providedExpirationSecond != 0 {
        try visitor.visitSingularInt64Field(value: _storage._providedExpirationSecond, fieldNumber: 10)
      }
      if _storage._calculatedExpirationSecond != 0 {
        try visitor.visitSingularInt64Field(value: _storage._calculatedExpirationSecond, fieldNumber: 11)
      }
      try { if let v = _storage._resolutionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._scheduledTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._originalCreateTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._signatories.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signatories, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Schedule, rhs: Proto_Schedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scheduleID != rhs_storage._scheduleID {return false}
        if _storage._deleted != rhs_storage._deleted {return false}
        if _storage._executed != rhs_storage._executed {return false}
        if _storage._waitForExpiry != rhs_storage._waitForExpiry {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._schedulerAccountID != rhs_storage._schedulerAccountID {return false}
        if _storage._payerAccountID != rhs_storage._payerAccountID {return false}
        if _storage._adminKey != rhs_storage._adminKey {return false}
        if _storage._scheduleValidStart != rhs_storage._scheduleValidStart {return false}
        if _storage._providedExpirationSecond != rhs_storage._providedExpirationSecond {return false}
        if _storage._calculatedExpirationSecond != rhs_storage._calculatedExpirationSecond {return false}
        if _storage._resolutionTime != rhs_storage._resolutionTime {return false}
        if _storage._scheduledTransaction != rhs_storage._scheduledTransaction {return false}
        if _storage._originalCreateTransaction != rhs_storage._originalCreateTransaction {return false}
        if _storage._signatories != rhs_storage._signatories {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ScheduleList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScheduleList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schedules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.schedules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schedules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.schedules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ScheduleList, rhs: Proto_ScheduleList) -> Bool {
    if lhs.schedules != rhs.schedules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
