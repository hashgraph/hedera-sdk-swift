// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state/token/token.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Proto_Token: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The unique entity id of this token.
  public var tokenID: Proto_TokenID {
    get {return _storage._tokenID ?? Proto_TokenID()}
    set {_uniqueStorage()._tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return _storage._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {_uniqueStorage()._tokenID = nil}

  ///*
  /// The human-readable name of this token. Need not be unique. Maximum length allowed is 100 bytes.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///*
  /// The human-readable symbol for the token. It is not necessarily unique. Maximum length allowed is 100 bytes.
  public var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  ///*
  /// The number of decimal places of this token. If decimals are 8 or 11, then the number of whole
  /// tokens can be at most a few billions or millions, respectively. For example, it could match
  /// Bitcoin (21 million whole tokens with 8 decimals) or hbars (50 billion whole tokens with 8 decimals).
  /// It could even match Bitcoin with milli-satoshis (21 million whole tokens with 11 decimals).
  public var decimals: Int32 {
    get {return _storage._decimals}
    set {_uniqueStorage()._decimals = newValue}
  }

  ///*
  /// The total supply of this token.
  public var totalSupply: Int64 {
    get {return _storage._totalSupply}
    set {_uniqueStorage()._totalSupply = newValue}
  }

  ///*
  /// The treasury account id of this token. This account receives the initial supply of
  /// tokens as well as the tokens from the Token Mint operation once executed. The balance
  /// of the treasury account is decreased when the Token Burn operation is executed.
  public var treasuryAccountID: Proto_AccountID {
    get {return _storage._treasuryAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._treasuryAccountID = newValue}
  }
  /// Returns true if `treasuryAccountID` has been explicitly set.
  public var hasTreasuryAccountID: Bool {return _storage._treasuryAccountID != nil}
  /// Clears the value of `treasuryAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearTreasuryAccountID() {_uniqueStorage()._treasuryAccountID = nil}

  ///*
  /// (Optional) The admin key of this token. If this key is set, the token is mutable.
  /// A mutable token can be modified.
  /// If this key is not set on token creation, it cannot be modified.
  public var adminKey: Proto_Key {
    get {return _storage._adminKey ?? Proto_Key()}
    set {_uniqueStorage()._adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return _storage._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {_uniqueStorage()._adminKey = nil}

  ///*
  /// (Optional) The kyc key of this token.
  /// If this key is not set on token creation, it can only be set if the token has admin key set.
  public var kycKey: Proto_Key {
    get {return _storage._kycKey ?? Proto_Key()}
    set {_uniqueStorage()._kycKey = newValue}
  }
  /// Returns true if `kycKey` has been explicitly set.
  public var hasKycKey: Bool {return _storage._kycKey != nil}
  /// Clears the value of `kycKey`. Subsequent reads from it will return its default value.
  public mutating func clearKycKey() {_uniqueStorage()._kycKey = nil}

  ///*
  /// (Optional) The freeze key of this token. This key is needed for freezing the token.
  /// If this key is not set on token creation, it can only be set if the token has admin key set.
  public var freezeKey: Proto_Key {
    get {return _storage._freezeKey ?? Proto_Key()}
    set {_uniqueStorage()._freezeKey = newValue}
  }
  /// Returns true if `freezeKey` has been explicitly set.
  public var hasFreezeKey: Bool {return _storage._freezeKey != nil}
  /// Clears the value of `freezeKey`. Subsequent reads from it will return its default value.
  public mutating func clearFreezeKey() {_uniqueStorage()._freezeKey = nil}

  ///*
  /// (Optional) The wipe key of this token. This key is needed for wiping the token.
  /// If this key is not set on token creation, it can only be set if the token has admin key set.
  public var wipeKey: Proto_Key {
    get {return _storage._wipeKey ?? Proto_Key()}
    set {_uniqueStorage()._wipeKey = newValue}
  }
  /// Returns true if `wipeKey` has been explicitly set.
  public var hasWipeKey: Bool {return _storage._wipeKey != nil}
  /// Clears the value of `wipeKey`. Subsequent reads from it will return its default value.
  public mutating func clearWipeKey() {_uniqueStorage()._wipeKey = nil}

  ///*
  /// (Optional) The supply key of this token. This key is needed for minting or burning token.
  /// If this key is not set on token creation, it can only be set if the token has admin key set.
  public var supplyKey: Proto_Key {
    get {return _storage._supplyKey ?? Proto_Key()}
    set {_uniqueStorage()._supplyKey = newValue}
  }
  /// Returns true if `supplyKey` has been explicitly set.
  public var hasSupplyKey: Bool {return _storage._supplyKey != nil}
  /// Clears the value of `supplyKey`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyKey() {_uniqueStorage()._supplyKey = nil}

  ///*
  /// (Optional) The fee schedule key of this token. This key should be set, in order to make any
  /// changes to the custom fee schedule.
  /// If this key is not set on token creation, it can only be set if the token has admin key set.
  public var feeScheduleKey: Proto_Key {
    get {return _storage._feeScheduleKey ?? Proto_Key()}
    set {_uniqueStorage()._feeScheduleKey = newValue}
  }
  /// Returns true if `feeScheduleKey` has been explicitly set.
  public var hasFeeScheduleKey: Bool {return _storage._feeScheduleKey != nil}
  /// Clears the value of `feeScheduleKey`. Subsequent reads from it will return its default value.
  public mutating func clearFeeScheduleKey() {_uniqueStorage()._feeScheduleKey = nil}

  ///*
  /// (Optional) The pause key of this token. This key is needed for pausing the token.
  /// If this key is not set on token creation, it can only be set if the token has admin key set.
  public var pauseKey: Proto_Key {
    get {return _storage._pauseKey ?? Proto_Key()}
    set {_uniqueStorage()._pauseKey = newValue}
  }
  /// Returns true if `pauseKey` has been explicitly set.
  public var hasPauseKey: Bool {return _storage._pauseKey != nil}
  /// Clears the value of `pauseKey`. Subsequent reads from it will return its default value.
  public mutating func clearPauseKey() {_uniqueStorage()._pauseKey = nil}

  ///*
  /// The last used serial number of this token.
  public var lastUsedSerialNumber: Int64 {
    get {return _storage._lastUsedSerialNumber}
    set {_uniqueStorage()._lastUsedSerialNumber = newValue}
  }

  ///*
  /// The flag indicating if this token is deleted.
  public var deleted: Bool {
    get {return _storage._deleted}
    set {_uniqueStorage()._deleted = newValue}
  }

  ///*
  /// The type of this token. A token can be either FUNGIBLE_COMMON or NON_FUNGIBLE_UNIQUE.
  /// If it has been omitted during token creation, FUNGIBLE_COMMON type is used.
  public var tokenType: Proto_TokenType {
    get {return _storage._tokenType}
    set {_uniqueStorage()._tokenType = newValue}
  }

  ///*
  /// The supply type of this token.A token can have either INFINITE or FINITE supply type.
  /// If it has been omitted during token creation, INFINITE type is used.
  public var supplyType: Proto_TokenSupplyType {
    get {return _storage._supplyType}
    set {_uniqueStorage()._supplyType = newValue}
  }

  ///*
  /// The id of the account (if any) that the network will attempt to charge for the
  /// token's auto-renewal upon expiration.
  public var autoRenewAccountID: Proto_AccountID {
    get {return _storage._autoRenewAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._autoRenewAccountID = newValue}
  }
  /// Returns true if `autoRenewAccountID` has been explicitly set.
  public var hasAutoRenewAccountID: Bool {return _storage._autoRenewAccountID != nil}
  /// Clears the value of `autoRenewAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewAccountID() {_uniqueStorage()._autoRenewAccountID = nil}

  ///*
  /// The number of seconds the network should automatically extend the token's expiration by, if the
  /// token has a valid auto-renew account, and is not deleted upon expiration.
  /// If this is not provided in a allowed range on token creation, the transaction will fail with INVALID_AUTO_RENEWAL_PERIOD.
  /// The default values for the minimum period and maximum period are 30 days and 90 days, respectively.
  public var autoRenewSeconds: Int64 {
    get {return _storage._autoRenewSeconds}
    set {_uniqueStorage()._autoRenewSeconds = newValue}
  }

  ///*
  /// The expiration time of the token, in seconds since the epoch.
  public var expirationSecond: Int64 {
    get {return _storage._expirationSecond}
    set {_uniqueStorage()._expirationSecond = newValue}
  }

  ///*
  /// An optional description of the token with UTF-8 encoding up to 100 bytes.
  public var memo: String {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  ///*
  /// The maximum supply of this token.
  public var maxSupply: Int64 {
    get {return _storage._maxSupply}
    set {_uniqueStorage()._maxSupply = newValue}
  }

  ///*
  /// The flag indicating if this token is paused.
  public var paused: Bool {
    get {return _storage._paused}
    set {_uniqueStorage()._paused = newValue}
  }

  ///*
  /// The flag indicating if this token has accounts associated to it that are frozen by default.
  public var accountsFrozenByDefault: Bool {
    get {return _storage._accountsFrozenByDefault}
    set {_uniqueStorage()._accountsFrozenByDefault = newValue}
  }

  ///*
  /// The flag indicating if this token has accounts associated with it that are KYC granted by default.
  public var accountsKycGrantedByDefault: Bool {
    get {return _storage._accountsKycGrantedByDefault}
    set {_uniqueStorage()._accountsKycGrantedByDefault = newValue}
  }

  ///*
  /// (Optional) The custom fees of this token.
  public var customFees: [Proto_CustomFee] {
    get {return _storage._customFees}
    set {_uniqueStorage()._customFees = newValue}
  }

  ///*
  /// Metadata of the created token definition
  public var metadata: Data {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  ///*
  /// The key which can change the metadata of a token
  /// (token definition and individual NFTs).
  public var metadataKey: Proto_Key {
    get {return _storage._metadataKey ?? Proto_Key()}
    set {_uniqueStorage()._metadataKey = newValue}
  }
  /// Returns true if `metadataKey` has been explicitly set.
  public var hasMetadataKey: Bool {return _storage._metadataKey != nil}
  /// Clears the value of `metadataKey`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataKey() {_uniqueStorage()._metadataKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Token"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .same(proto: "name"),
    3: .same(proto: "symbol"),
    4: .same(proto: "decimals"),
    5: .standard(proto: "total_supply"),
    6: .standard(proto: "treasury_account_id"),
    7: .standard(proto: "admin_key"),
    8: .standard(proto: "kyc_key"),
    9: .standard(proto: "freeze_key"),
    10: .standard(proto: "wipe_key"),
    11: .standard(proto: "supply_key"),
    12: .standard(proto: "fee_schedule_key"),
    13: .standard(proto: "pause_key"),
    14: .standard(proto: "last_used_serial_number"),
    15: .same(proto: "deleted"),
    16: .standard(proto: "token_type"),
    17: .standard(proto: "supply_type"),
    18: .standard(proto: "auto_renew_account_id"),
    19: .standard(proto: "auto_renew_seconds"),
    20: .standard(proto: "expiration_second"),
    21: .same(proto: "memo"),
    22: .standard(proto: "max_supply"),
    23: .same(proto: "paused"),
    24: .standard(proto: "accounts_frozen_by_default"),
    25: .standard(proto: "accounts_kyc_granted_by_default"),
    26: .standard(proto: "custom_fees"),
    27: .same(proto: "metadata"),
    28: .standard(proto: "metadata_key"),
  ]

  fileprivate class _StorageClass {
    var _tokenID: Proto_TokenID? = nil
    var _name: String = String()
    var _symbol: String = String()
    var _decimals: Int32 = 0
    var _totalSupply: Int64 = 0
    var _treasuryAccountID: Proto_AccountID? = nil
    var _adminKey: Proto_Key? = nil
    var _kycKey: Proto_Key? = nil
    var _freezeKey: Proto_Key? = nil
    var _wipeKey: Proto_Key? = nil
    var _supplyKey: Proto_Key? = nil
    var _feeScheduleKey: Proto_Key? = nil
    var _pauseKey: Proto_Key? = nil
    var _lastUsedSerialNumber: Int64 = 0
    var _deleted: Bool = false
    var _tokenType: Proto_TokenType = .fungibleCommon
    var _supplyType: Proto_TokenSupplyType = .infinite
    var _autoRenewAccountID: Proto_AccountID? = nil
    var _autoRenewSeconds: Int64 = 0
    var _expirationSecond: Int64 = 0
    var _memo: String = String()
    var _maxSupply: Int64 = 0
    var _paused: Bool = false
    var _accountsFrozenByDefault: Bool = false
    var _accountsKycGrantedByDefault: Bool = false
    var _customFees: [Proto_CustomFee] = []
    var _metadata: Data = Data()
    var _metadataKey: Proto_Key? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _tokenID = source._tokenID
      _name = source._name
      _symbol = source._symbol
      _decimals = source._decimals
      _totalSupply = source._totalSupply
      _treasuryAccountID = source._treasuryAccountID
      _adminKey = source._adminKey
      _kycKey = source._kycKey
      _freezeKey = source._freezeKey
      _wipeKey = source._wipeKey
      _supplyKey = source._supplyKey
      _feeScheduleKey = source._feeScheduleKey
      _pauseKey = source._pauseKey
      _lastUsedSerialNumber = source._lastUsedSerialNumber
      _deleted = source._deleted
      _tokenType = source._tokenType
      _supplyType = source._supplyType
      _autoRenewAccountID = source._autoRenewAccountID
      _autoRenewSeconds = source._autoRenewSeconds
      _expirationSecond = source._expirationSecond
      _memo = source._memo
      _maxSupply = source._maxSupply
      _paused = source._paused
      _accountsFrozenByDefault = source._accountsFrozenByDefault
      _accountsKycGrantedByDefault = source._accountsKycGrantedByDefault
      _customFees = source._customFees
      _metadata = source._metadata
      _metadataKey = source._metadataKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tokenID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._symbol) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._decimals) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._totalSupply) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._treasuryAccountID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._adminKey) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kycKey) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._freezeKey) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._wipeKey) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._supplyKey) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._feeScheduleKey) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._pauseKey) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._lastUsedSerialNumber) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._deleted) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._tokenType) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._supplyType) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewAccountID) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._autoRenewSeconds) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._expirationSecond) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._maxSupply) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._paused) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._accountsFrozenByDefault) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._accountsKycGrantedByDefault) }()
        case 26: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFees) }()
        case 27: try { try decoder.decodeSingularBytesField(value: &_storage._metadata) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._metadataKey) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._tokenID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 3)
      }
      if _storage._decimals != 0 {
        try visitor.visitSingularInt32Field(value: _storage._decimals, fieldNumber: 4)
      }
      if _storage._totalSupply != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSupply, fieldNumber: 5)
      }
      try { if let v = _storage._treasuryAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._adminKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kycKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._freezeKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._wipeKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._supplyKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._feeScheduleKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._pauseKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._lastUsedSerialNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastUsedSerialNumber, fieldNumber: 14)
      }
      if _storage._deleted != false {
        try visitor.visitSingularBoolField(value: _storage._deleted, fieldNumber: 15)
      }
      if _storage._tokenType != .fungibleCommon {
        try visitor.visitSingularEnumField(value: _storage._tokenType, fieldNumber: 16)
      }
      if _storage._supplyType != .infinite {
        try visitor.visitSingularEnumField(value: _storage._supplyType, fieldNumber: 17)
      }
      try { if let v = _storage._autoRenewAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if _storage._autoRenewSeconds != 0 {
        try visitor.visitSingularInt64Field(value: _storage._autoRenewSeconds, fieldNumber: 19)
      }
      if _storage._expirationSecond != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expirationSecond, fieldNumber: 20)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 21)
      }
      if _storage._maxSupply != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxSupply, fieldNumber: 22)
      }
      if _storage._paused != false {
        try visitor.visitSingularBoolField(value: _storage._paused, fieldNumber: 23)
      }
      if _storage._accountsFrozenByDefault != false {
        try visitor.visitSingularBoolField(value: _storage._accountsFrozenByDefault, fieldNumber: 24)
      }
      if _storage._accountsKycGrantedByDefault != false {
        try visitor.visitSingularBoolField(value: _storage._accountsKycGrantedByDefault, fieldNumber: 25)
      }
      if !_storage._customFees.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFees, fieldNumber: 26)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._metadata, fieldNumber: 27)
      }
      try { if let v = _storage._metadataKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Token, rhs: Proto_Token) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tokenID != rhs_storage._tokenID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        if _storage._decimals != rhs_storage._decimals {return false}
        if _storage._totalSupply != rhs_storage._totalSupply {return false}
        if _storage._treasuryAccountID != rhs_storage._treasuryAccountID {return false}
        if _storage._adminKey != rhs_storage._adminKey {return false}
        if _storage._kycKey != rhs_storage._kycKey {return false}
        if _storage._freezeKey != rhs_storage._freezeKey {return false}
        if _storage._wipeKey != rhs_storage._wipeKey {return false}
        if _storage._supplyKey != rhs_storage._supplyKey {return false}
        if _storage._feeScheduleKey != rhs_storage._feeScheduleKey {return false}
        if _storage._pauseKey != rhs_storage._pauseKey {return false}
        if _storage._lastUsedSerialNumber != rhs_storage._lastUsedSerialNumber {return false}
        if _storage._deleted != rhs_storage._deleted {return false}
        if _storage._tokenType != rhs_storage._tokenType {return false}
        if _storage._supplyType != rhs_storage._supplyType {return false}
        if _storage._autoRenewAccountID != rhs_storage._autoRenewAccountID {return false}
        if _storage._autoRenewSeconds != rhs_storage._autoRenewSeconds {return false}
        if _storage._expirationSecond != rhs_storage._expirationSecond {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._maxSupply != rhs_storage._maxSupply {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._accountsFrozenByDefault != rhs_storage._accountsFrozenByDefault {return false}
        if _storage._accountsKycGrantedByDefault != rhs_storage._accountsKycGrantedByDefault {return false}
        if _storage._customFees != rhs_storage._customFees {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._metadataKey != rhs_storage._metadataKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
