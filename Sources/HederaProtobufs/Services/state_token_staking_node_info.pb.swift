// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state/token/staking_node_info.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Representation of a Hedera Token Service staking info entity in the network Merkle tree.
///
/// As with all network entities, staking info is per node and has a unique entity number represented as shard.realm.X.
public struct Proto_StakingNodeInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The unique entity number of the node. The shard and realm numbers are implied, based on the network
  /// this entity came from.
  public var nodeNumber: Int64 = 0

  ///*
  /// The minimum stake on this node that is required for this node to have a non-zero weight to
  /// participate in the network consensus.
  public var minStake: Int64 = 0

  ///*
  /// The maximum stake on this node that is considered to calculate its weight to participate in the network consensus.
  public var maxStake: Int64 = 0

  ///*
  /// The sum of balances of all accounts staked to this node who have opted to receive rewards.
  public var stakeToReward: Int64 = 0

  ///*
  /// The sum of balances of all accounts staked to this node who have opted to decline rewards.
  public var stakeToNotReward: Int64 = 0

  ///*
  /// The snapshot of stake_to_reward value at the beginning of the current staking period.
  /// This is needed for calculating rewards for current staking period without considering changes to
  /// stake_to_reward in the current staking period. It is reset at the beginning of every period.
  public var stakeRewardStart: Int64 = 0

  ///*
  /// Tracks how much stake from stakeRewardStart will have unclaimed rewards due to accounts changing their staking
  /// metadata in a way that disqualifies them for the current period; It is reset at the beginning of every period
  public var unclaimedStakeRewardStart: Int64 = 0

  ///*
  /// The total amount of effective hbar staked to this node. This is sum of stake_to_reward and stake_to_not_reward.
  /// If the sum is greater than max_stake, then the effective stake is max_stake.
  /// If the sum is less than min_stake, then the effective stake is 0.
  public var stake: Int64 = 0

  ///*
  /// An running sum of reward rates per hbar for the last 365+1 staking periods. The first element is the
  /// is the reward up to and including the last full period that finished before the present. Second element is
  /// the reward up to and including the period before that
  public var rewardSumHistory: [Int64] = []

  ///*
  /// The consensus weight of this node in the network. This is computed based on the stake of this node
  /// at midnight UTC of the current day. If the stake of this node is less than minStake, then the weight is 0.
  /// Sum of all weights of nodes in the network should be less than 500.
  /// If the stake of this node A is greater than minStake, then the weight of this node A is calculated as:
  /// (node A stake * 500/ total stake of all nodes)
  public var weight: Int32 = 0

  ///*
  /// The total staking rewards in tinybars that COULD be collected by all accounts staking to the current node after the end
  /// of this staking period; assuming that no account "renounces" its rewards by, for example, setting declineReward=true.
  /// When the current node is deleted, this amount will be subtracted from the total pending rewards of all accounts staking
  /// to all nodes in the network in NetworkStakingRewards.
  public var pendingRewards: Int64 = 0

  ///*
  /// True if this node has been deleted from network.
  public var deleted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_StakingNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakingNodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_number"),
    2: .standard(proto: "min_stake"),
    3: .standard(proto: "max_stake"),
    4: .standard(proto: "stake_to_reward"),
    5: .standard(proto: "stake_to_not_reward"),
    6: .standard(proto: "stake_reward_start"),
    7: .standard(proto: "unclaimed_stake_reward_start"),
    8: .same(proto: "stake"),
    9: .standard(proto: "reward_sum_history"),
    10: .same(proto: "weight"),
    11: .standard(proto: "pending_rewards"),
    12: .same(proto: "deleted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.nodeNumber) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.minStake) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.maxStake) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.stakeToReward) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.stakeToNotReward) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.stakeRewardStart) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.unclaimedStakeRewardStart) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.stake) }()
      case 9: try { try decoder.decodeRepeatedInt64Field(value: &self.rewardSumHistory) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.weight) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.pendingRewards) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.nodeNumber, fieldNumber: 1)
    }
    if self.minStake != 0 {
      try visitor.visitSingularInt64Field(value: self.minStake, fieldNumber: 2)
    }
    if self.maxStake != 0 {
      try visitor.visitSingularInt64Field(value: self.maxStake, fieldNumber: 3)
    }
    if self.stakeToReward != 0 {
      try visitor.visitSingularInt64Field(value: self.stakeToReward, fieldNumber: 4)
    }
    if self.stakeToNotReward != 0 {
      try visitor.visitSingularInt64Field(value: self.stakeToNotReward, fieldNumber: 5)
    }
    if self.stakeRewardStart != 0 {
      try visitor.visitSingularInt64Field(value: self.stakeRewardStart, fieldNumber: 6)
    }
    if self.unclaimedStakeRewardStart != 0 {
      try visitor.visitSingularInt64Field(value: self.unclaimedStakeRewardStart, fieldNumber: 7)
    }
    if self.stake != 0 {
      try visitor.visitSingularInt64Field(value: self.stake, fieldNumber: 8)
    }
    if !self.rewardSumHistory.isEmpty {
      try visitor.visitPackedInt64Field(value: self.rewardSumHistory, fieldNumber: 9)
    }
    if self.weight != 0 {
      try visitor.visitSingularInt32Field(value: self.weight, fieldNumber: 10)
    }
    if self.pendingRewards != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingRewards, fieldNumber: 11)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_StakingNodeInfo, rhs: Proto_StakingNodeInfo) -> Bool {
    if lhs.nodeNumber != rhs.nodeNumber {return false}
    if lhs.minStake != rhs.minStake {return false}
    if lhs.maxStake != rhs.maxStake {return false}
    if lhs.stakeToReward != rhs.stakeToReward {return false}
    if lhs.stakeToNotReward != rhs.stakeToNotReward {return false}
    if lhs.stakeRewardStart != rhs.stakeRewardStart {return false}
    if lhs.unclaimedStakeRewardStart != rhs.unclaimedStakeRewardStart {return false}
    if lhs.stake != rhs.stake {return false}
    if lhs.rewardSumHistory != rhs.rewardSumHistory {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.pendingRewards != rhs.pendingRewards {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
