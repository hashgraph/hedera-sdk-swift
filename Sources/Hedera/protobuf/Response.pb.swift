// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Response.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A single response, which is returned from the node to the client, after the client sent the node a query. This includes all responses. 
struct Proto_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  /// Get all entities associated with a given key
  var getByKey: Proto_GetByKeyResponse {
    get {
      if case .getByKey(let v)? = _storage._response {return v}
      return Proto_GetByKeyResponse()
    }
    set {_uniqueStorage()._response = .getByKey(newValue)}
  }

  /// Get the IDs in the format used in transactions, given the format used in Solidity
  var getBySolidityID: Proto_GetBySolidityIDResponse {
    get {
      if case .getBySolidityID(let v)? = _storage._response {return v}
      return Proto_GetBySolidityIDResponse()
    }
    set {_uniqueStorage()._response = .getBySolidityID(newValue)}
  }

  /// Response to call a function of a smart contract instance
  var contractCallLocal: Proto_ContractCallLocalResponse {
    get {
      if case .contractCallLocal(let v)? = _storage._response {return v}
      return Proto_ContractCallLocalResponse()
    }
    set {_uniqueStorage()._response = .contractCallLocal(newValue)}
  }

  /// Get the bytecode for a smart contract instance
  var contractGetBytecodeResponse: Proto_ContractGetBytecodeResponse {
    get {
      if case .contractGetBytecodeResponse(let v)? = _storage._response {return v}
      return Proto_ContractGetBytecodeResponse()
    }
    set {_uniqueStorage()._response = .contractGetBytecodeResponse(newValue)}
  }

  /// Get information about a smart contract instance
  var contractGetInfo: Proto_ContractGetInfoResponse {
    get {
      if case .contractGetInfo(let v)? = _storage._response {return v}
      return Proto_ContractGetInfoResponse()
    }
    set {_uniqueStorage()._response = .contractGetInfo(newValue)}
  }

  ///Get all existing records for a smart contract instance
  var contractGetRecordsResponse: Proto_ContractGetRecordsResponse {
    get {
      if case .contractGetRecordsResponse(let v)? = _storage._response {return v}
      return Proto_ContractGetRecordsResponse()
    }
    set {_uniqueStorage()._response = .contractGetRecordsResponse(newValue)}
  }

  /// Get the current balance in a cryptocurrency account
  var cryptogetAccountBalance: Proto_CryptoGetAccountBalanceResponse {
    get {
      if case .cryptogetAccountBalance(let v)? = _storage._response {return v}
      return Proto_CryptoGetAccountBalanceResponse()
    }
    set {_uniqueStorage()._response = .cryptogetAccountBalance(newValue)}
  }

  /// Get all the records that currently exist for transactions involving an account
  var cryptoGetAccountRecords: Proto_CryptoGetAccountRecordsResponse {
    get {
      if case .cryptoGetAccountRecords(let v)? = _storage._response {return v}
      return Proto_CryptoGetAccountRecordsResponse()
    }
    set {_uniqueStorage()._response = .cryptoGetAccountRecords(newValue)}
  }

  /// Get all information about an account
  var cryptoGetInfo: Proto_CryptoGetInfoResponse {
    get {
      if case .cryptoGetInfo(let v)? = _storage._response {return v}
      return Proto_CryptoGetInfoResponse()
    }
    set {_uniqueStorage()._response = .cryptoGetInfo(newValue)}
  }

  /// Get a single claim from a single account (or null if it doesn't exist)
  var cryptoGetClaim: Proto_CryptoGetClaimResponse {
    get {
      if case .cryptoGetClaim(let v)? = _storage._response {return v}
      return Proto_CryptoGetClaimResponse()
    }
    set {_uniqueStorage()._response = .cryptoGetClaim(newValue)}
  }

  /// Get all the accounts that proxy stake to a given account, and how much they proxy stake
  var cryptoGetProxyStakers: Proto_CryptoGetStakersResponse {
    get {
      if case .cryptoGetProxyStakers(let v)? = _storage._response {return v}
      return Proto_CryptoGetStakersResponse()
    }
    set {_uniqueStorage()._response = .cryptoGetProxyStakers(newValue)}
  }

  /// Get the contents of a file (the bytes stored in it)
  var fileGetContents: Proto_FileGetContentsResponse {
    get {
      if case .fileGetContents(let v)? = _storage._response {return v}
      return Proto_FileGetContentsResponse()
    }
    set {_uniqueStorage()._response = .fileGetContents(newValue)}
  }

  /// Get information about a file, such as its expiration date
  var fileGetInfo: Proto_FileGetInfoResponse {
    get {
      if case .fileGetInfo(let v)? = _storage._response {return v}
      return Proto_FileGetInfoResponse()
    }
    set {_uniqueStorage()._response = .fileGetInfo(newValue)}
  }

  /// Get a receipt for a transaction (lasts 180 seconds)
  var transactionGetReceipt: Proto_TransactionGetReceiptResponse {
    get {
      if case .transactionGetReceipt(let v)? = _storage._response {return v}
      return Proto_TransactionGetReceiptResponse()
    }
    set {_uniqueStorage()._response = .transactionGetReceipt(newValue)}
  }

  /// Get a record for a transaction (lasts 1 hour)
  var transactionGetRecord: Proto_TransactionGetRecordResponse {
    get {
      if case .transactionGetRecord(let v)? = _storage._response {return v}
      return Proto_TransactionGetRecordResponse()
    }
    set {_uniqueStorage()._response = .transactionGetRecord(newValue)}
  }

  /// Get a record for a transaction (lasts 180 seconds)
  var transactionGetFastRecord: Proto_TransactionGetFastRecordResponse {
    get {
      if case .transactionGetFastRecord(let v)? = _storage._response {return v}
      return Proto_TransactionGetFastRecordResponse()
    }
    set {_uniqueStorage()._response = .transactionGetFastRecord(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    /// Get all entities associated with a given key
    case getByKey(Proto_GetByKeyResponse)
    /// Get the IDs in the format used in transactions, given the format used in Solidity
    case getBySolidityID(Proto_GetBySolidityIDResponse)
    /// Response to call a function of a smart contract instance
    case contractCallLocal(Proto_ContractCallLocalResponse)
    /// Get the bytecode for a smart contract instance
    case contractGetBytecodeResponse(Proto_ContractGetBytecodeResponse)
    /// Get information about a smart contract instance
    case contractGetInfo(Proto_ContractGetInfoResponse)
    ///Get all existing records for a smart contract instance
    case contractGetRecordsResponse(Proto_ContractGetRecordsResponse)
    /// Get the current balance in a cryptocurrency account
    case cryptogetAccountBalance(Proto_CryptoGetAccountBalanceResponse)
    /// Get all the records that currently exist for transactions involving an account
    case cryptoGetAccountRecords(Proto_CryptoGetAccountRecordsResponse)
    /// Get all information about an account
    case cryptoGetInfo(Proto_CryptoGetInfoResponse)
    /// Get a single claim from a single account (or null if it doesn't exist)
    case cryptoGetClaim(Proto_CryptoGetClaimResponse)
    /// Get all the accounts that proxy stake to a given account, and how much they proxy stake
    case cryptoGetProxyStakers(Proto_CryptoGetStakersResponse)
    /// Get the contents of a file (the bytes stored in it)
    case fileGetContents(Proto_FileGetContentsResponse)
    /// Get information about a file, such as its expiration date
    case fileGetInfo(Proto_FileGetInfoResponse)
    /// Get a receipt for a transaction (lasts 180 seconds)
    case transactionGetReceipt(Proto_TransactionGetReceiptResponse)
    /// Get a record for a transaction (lasts 1 hour)
    case transactionGetRecord(Proto_TransactionGetRecordResponse)
    /// Get a record for a transaction (lasts 180 seconds)
    case transactionGetFastRecord(Proto_TransactionGetFastRecordResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Response.OneOf_Response, rhs: Proto_Response.OneOf_Response) -> Bool {
      switch (lhs, rhs) {
      case (.getByKey(let l), .getByKey(let r)): return l == r
      case (.getBySolidityID(let l), .getBySolidityID(let r)): return l == r
      case (.contractCallLocal(let l), .contractCallLocal(let r)): return l == r
      case (.contractGetBytecodeResponse(let l), .contractGetBytecodeResponse(let r)): return l == r
      case (.contractGetInfo(let l), .contractGetInfo(let r)): return l == r
      case (.contractGetRecordsResponse(let l), .contractGetRecordsResponse(let r)): return l == r
      case (.cryptogetAccountBalance(let l), .cryptogetAccountBalance(let r)): return l == r
      case (.cryptoGetAccountRecords(let l), .cryptoGetAccountRecords(let r)): return l == r
      case (.cryptoGetInfo(let l), .cryptoGetInfo(let r)): return l == r
      case (.cryptoGetClaim(let l), .cryptoGetClaim(let r)): return l == r
      case (.cryptoGetProxyStakers(let l), .cryptoGetProxyStakers(let r)): return l == r
      case (.fileGetContents(let l), .fileGetContents(let r)): return l == r
      case (.fileGetInfo(let l), .fileGetInfo(let r)): return l == r
      case (.transactionGetReceipt(let l), .transactionGetReceipt(let r)): return l == r
      case (.transactionGetRecord(let l), .transactionGetRecord(let r)): return l == r
      case (.transactionGetFastRecord(let l), .transactionGetFastRecord(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getByKey"),
    2: .same(proto: "getBySolidityID"),
    3: .same(proto: "contractCallLocal"),
    5: .same(proto: "contractGetBytecodeResponse"),
    4: .same(proto: "contractGetInfo"),
    6: .same(proto: "contractGetRecordsResponse"),
    7: .same(proto: "cryptogetAccountBalance"),
    8: .same(proto: "cryptoGetAccountRecords"),
    9: .same(proto: "cryptoGetInfo"),
    10: .same(proto: "cryptoGetClaim"),
    11: .same(proto: "cryptoGetProxyStakers"),
    12: .same(proto: "fileGetContents"),
    13: .same(proto: "fileGetInfo"),
    14: .same(proto: "transactionGetReceipt"),
    15: .same(proto: "transactionGetRecord"),
    16: .same(proto: "transactionGetFastRecord"),
  ]

  fileprivate class _StorageClass {
    var _response: Proto_Response.OneOf_Response?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Proto_GetByKeyResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .getByKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .getByKey(v)}
        case 2:
          var v: Proto_GetBySolidityIDResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .getBySolidityID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .getBySolidityID(v)}
        case 3:
          var v: Proto_ContractCallLocalResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .contractCallLocal(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .contractCallLocal(v)}
        case 4:
          var v: Proto_ContractGetInfoResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .contractGetInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .contractGetInfo(v)}
        case 5:
          var v: Proto_ContractGetBytecodeResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .contractGetBytecodeResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .contractGetBytecodeResponse(v)}
        case 6:
          var v: Proto_ContractGetRecordsResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .contractGetRecordsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .contractGetRecordsResponse(v)}
        case 7:
          var v: Proto_CryptoGetAccountBalanceResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .cryptogetAccountBalance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .cryptogetAccountBalance(v)}
        case 8:
          var v: Proto_CryptoGetAccountRecordsResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .cryptoGetAccountRecords(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .cryptoGetAccountRecords(v)}
        case 9:
          var v: Proto_CryptoGetInfoResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .cryptoGetInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .cryptoGetInfo(v)}
        case 10:
          var v: Proto_CryptoGetClaimResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .cryptoGetClaim(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .cryptoGetClaim(v)}
        case 11:
          var v: Proto_CryptoGetStakersResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .cryptoGetProxyStakers(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .cryptoGetProxyStakers(v)}
        case 12:
          var v: Proto_FileGetContentsResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .fileGetContents(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .fileGetContents(v)}
        case 13:
          var v: Proto_FileGetInfoResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .fileGetInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .fileGetInfo(v)}
        case 14:
          var v: Proto_TransactionGetReceiptResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .transactionGetReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .transactionGetReceipt(v)}
        case 15:
          var v: Proto_TransactionGetRecordResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .transactionGetRecord(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .transactionGetRecord(v)}
        case 16:
          var v: Proto_TransactionGetFastRecordResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .transactionGetFastRecord(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .transactionGetFastRecord(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._response {
      case .getByKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .getBySolidityID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .contractCallLocal(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .contractGetInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .contractGetBytecodeResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .contractGetRecordsResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .cryptogetAccountBalance(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .cryptoGetAccountRecords(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .cryptoGetInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .cryptoGetClaim(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .cryptoGetProxyStakers(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .fileGetContents(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .fileGetInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .transactionGetReceipt(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .transactionGetRecord(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .transactionGetFastRecord(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Response, rhs: Proto_Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
