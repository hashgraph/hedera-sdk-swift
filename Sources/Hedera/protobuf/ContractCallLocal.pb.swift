// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ContractCallLocal.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The log information for an event returned by a smart contract function call. One function call may return several such events. 
struct Proto_ContractLoginfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address of a contract that emitted the event
  var contractID: Proto_ContractID {
    get {return _storage._contractID ?? Proto_ContractID()}
    set {_uniqueStorage()._contractID = newValue}
  }
  /// Returns true if `contractID` has been explicitly set.
  var hasContractID: Bool {return _storage._contractID != nil}
  /// Clears the value of `contractID`. Subsequent reads from it will return its default value.
  mutating func clearContractID() {_uniqueStorage()._contractID = nil}

  ///bloom filter for a particular log
  var bloom: Data {
    get {return _storage._bloom}
    set {_uniqueStorage()._bloom = newValue}
  }

  /// topics of a particular event
  var topic: [Data] {
    get {return _storage._topic}
    set {_uniqueStorage()._topic = newValue}
  }

  /// event data
  var data: Data {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. 
struct Proto_ContractFunctionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the smart contract instance whose function was called
  var contractID: Proto_ContractID {
    get {return _storage._contractID ?? Proto_ContractID()}
    set {_uniqueStorage()._contractID = newValue}
  }
  /// Returns true if `contractID` has been explicitly set.
  var hasContractID: Bool {return _storage._contractID != nil}
  /// Clears the value of `contractID`. Subsequent reads from it will return its default value.
  mutating func clearContractID() {_uniqueStorage()._contractID = nil}

  /// the result returned by the function
  var contractCallResult: Data {
    get {return _storage._contractCallResult}
    set {_uniqueStorage()._contractCallResult = newValue}
  }

  /// message In case there was an error during smart contract execution
  var errorMessage: String {
    get {return _storage._errorMessage}
    set {_uniqueStorage()._errorMessage = newValue}
  }

  /// bloom filter for record
  var bloom: Data {
    get {return _storage._bloom}
    set {_uniqueStorage()._bloom = newValue}
  }

  ///units of gas used  to execute contract
  var gasUsed: UInt64 {
    get {return _storage._gasUsed}
    set {_uniqueStorage()._gasUsed = newValue}
  }

  /// the log info for events returned by the function
  var logInfo: [Proto_ContractLoginfo] {
    get {return _storage._logInfo}
    set {_uniqueStorage()._logInfo = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Call a function of the given smart contract instance, giving it functionParameters as its inputs. It will consume the entire given amount of gas.
///
/// This is performed locally on the particular node that the client is communicating with. It cannot change the state of the contract instance (and so, cannot spend anything from the instance's cryptocurrency account). It will not have a consensus timestamp. It cannot generate a record or a receipt. The response will contain the output returned by the function call.  This is useful for calling getter functions, which purely read the state and don't change it. It is faster and cheaper than a normal call, because it is purely local to a single  node. 
struct Proto_ContractCallLocalQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered.
  var header: Proto_QueryHeader {
    get {return _storage._header ?? Proto_QueryHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// the contract instance to call, in the format used in transactions
  var contractID: Proto_ContractID {
    get {return _storage._contractID ?? Proto_ContractID()}
    set {_uniqueStorage()._contractID = newValue}
  }
  /// Returns true if `contractID` has been explicitly set.
  var hasContractID: Bool {return _storage._contractID != nil}
  /// Clears the value of `contractID`. Subsequent reads from it will return its default value.
  mutating func clearContractID() {_uniqueStorage()._contractID = nil}

  /// the amount of gas to use for the call. All of the gas offered will be charged for.
  var gas: Int64 {
    get {return _storage._gas}
    set {_uniqueStorage()._gas = newValue}
  }

  /// which function to call, and the parameters to pass to the function
  var functionParameters: Data {
    get {return _storage._functionParameters}
    set {_uniqueStorage()._functionParameters = newValue}
  }

  /// max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes.
  var maxResultSize: Int64 {
    get {return _storage._maxResultSize}
    set {_uniqueStorage()._maxResultSize = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Response when the client sends the node ContractCallLocalQuery 
struct Proto_ContractCallLocalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
  var header: Proto_ResponseHeader {
    get {return _storage._header ?? Proto_ResponseHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// the value returned by the function (if it completed and didn't fail)
  var functionResult: Proto_ContractFunctionResult {
    get {return _storage._functionResult ?? Proto_ContractFunctionResult()}
    set {_uniqueStorage()._functionResult = newValue}
  }
  /// Returns true if `functionResult` has been explicitly set.
  var hasFunctionResult: Bool {return _storage._functionResult != nil}
  /// Clears the value of `functionResult`. Subsequent reads from it will return its default value.
  mutating func clearFunctionResult() {_uniqueStorage()._functionResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ContractLoginfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractLoginfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "bloom"),
    3: .same(proto: "topic"),
    4: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _contractID: Proto_ContractID? = nil
    var _bloom: Data = SwiftProtobuf.Internal.emptyData
    var _topic: [Data] = []
    var _data: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contractID = source._contractID
      _bloom = source._bloom
      _topic = source._topic
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._contractID)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._bloom)
        case 3: try decoder.decodeRepeatedBytesField(value: &_storage._topic)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._contractID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._bloom.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bloom, fieldNumber: 2)
      }
      if !_storage._topic.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._topic, fieldNumber: 3)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._data, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ContractLoginfo, rhs: Proto_ContractLoginfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contractID != rhs_storage._contractID {return false}
        if _storage._bloom != rhs_storage._bloom {return false}
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContractFunctionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractFunctionResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "contractCallResult"),
    3: .same(proto: "errorMessage"),
    4: .same(proto: "bloom"),
    5: .same(proto: "gasUsed"),
    6: .same(proto: "logInfo"),
  ]

  fileprivate class _StorageClass {
    var _contractID: Proto_ContractID? = nil
    var _contractCallResult: Data = SwiftProtobuf.Internal.emptyData
    var _errorMessage: String = String()
    var _bloom: Data = SwiftProtobuf.Internal.emptyData
    var _gasUsed: UInt64 = 0
    var _logInfo: [Proto_ContractLoginfo] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contractID = source._contractID
      _contractCallResult = source._contractCallResult
      _errorMessage = source._errorMessage
      _bloom = source._bloom
      _gasUsed = source._gasUsed
      _logInfo = source._logInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._contractID)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._contractCallResult)
        case 3: try decoder.decodeSingularStringField(value: &_storage._errorMessage)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._bloom)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._gasUsed)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._logInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._contractID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._contractCallResult.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._contractCallResult, fieldNumber: 2)
      }
      if !_storage._errorMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMessage, fieldNumber: 3)
      }
      if !_storage._bloom.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bloom, fieldNumber: 4)
      }
      if _storage._gasUsed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._gasUsed, fieldNumber: 5)
      }
      if !_storage._logInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._logInfo, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ContractFunctionResult, rhs: Proto_ContractFunctionResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contractID != rhs_storage._contractID {return false}
        if _storage._contractCallResult != rhs_storage._contractCallResult {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        if _storage._bloom != rhs_storage._bloom {return false}
        if _storage._gasUsed != rhs_storage._gasUsed {return false}
        if _storage._logInfo != rhs_storage._logInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContractCallLocalQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractCallLocalQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "contractID"),
    3: .same(proto: "gas"),
    4: .same(proto: "functionParameters"),
    5: .same(proto: "maxResultSize"),
  ]

  fileprivate class _StorageClass {
    var _header: Proto_QueryHeader? = nil
    var _contractID: Proto_ContractID? = nil
    var _gas: Int64 = 0
    var _functionParameters: Data = SwiftProtobuf.Internal.emptyData
    var _maxResultSize: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _contractID = source._contractID
      _gas = source._gas
      _functionParameters = source._functionParameters
      _maxResultSize = source._maxResultSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._header)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._contractID)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._gas)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._functionParameters)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._maxResultSize)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._contractID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._gas != 0 {
        try visitor.visitSingularInt64Field(value: _storage._gas, fieldNumber: 3)
      }
      if !_storage._functionParameters.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._functionParameters, fieldNumber: 4)
      }
      if _storage._maxResultSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxResultSize, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ContractCallLocalQuery, rhs: Proto_ContractCallLocalQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._contractID != rhs_storage._contractID {return false}
        if _storage._gas != rhs_storage._gas {return false}
        if _storage._functionParameters != rhs_storage._functionParameters {return false}
        if _storage._maxResultSize != rhs_storage._maxResultSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContractCallLocalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractCallLocalResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "functionResult"),
  ]

  fileprivate class _StorageClass {
    var _header: Proto_ResponseHeader? = nil
    var _functionResult: Proto_ContractFunctionResult? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _functionResult = source._functionResult
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._header)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._functionResult)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._functionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ContractCallLocalResponse, rhs: Proto_ContractCallLocalResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._functionResult != rhs_storage._functionResult {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
