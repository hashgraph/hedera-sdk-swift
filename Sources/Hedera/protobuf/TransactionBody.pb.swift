// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TransactionBody.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A single transaction. All transaction types are possible here. 
struct Proto_TransactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect
  var transactionID: Proto_TransactionID {
    get {return _storage._transactionID ?? Proto_TransactionID()}
    set {_uniqueStorage()._transactionID = newValue}
  }
  /// Returns true if `transactionID` has been explicitly set.
  var hasTransactionID: Bool {return _storage._transactionID != nil}
  /// Clears the value of `transactionID`. Subsequent reads from it will return its default value.
  mutating func clearTransactionID() {_uniqueStorage()._transactionID = nil}

  /// The account of the node that submits the client's transaction to the network
  var nodeAccountID: Proto_AccountID {
    get {return _storage._nodeAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._nodeAccountID = newValue}
  }
  /// Returns true if `nodeAccountID` has been explicitly set.
  var hasNodeAccountID: Bool {return _storage._nodeAccountID != nil}
  /// Clears the value of `nodeAccountID`. Subsequent reads from it will return its default value.
  mutating func clearNodeAccountID() {_uniqueStorage()._nodeAccountID = nil}

  /// The maximum transaction fee the client is willing to pay, which is split between the network and the node
  var transactionFee: UInt64 {
    get {return _storage._transactionFee}
    set {_uniqueStorage()._transactionFee = newValue}
  }

  ///The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration
  var transactionValidDuration: Proto_Duration {
    get {return _storage._transactionValidDuration ?? Proto_Duration()}
    set {_uniqueStorage()._transactionValidDuration = newValue}
  }
  /// Returns true if `transactionValidDuration` has been explicitly set.
  var hasTransactionValidDuration: Bool {return _storage._transactionValidDuration != nil}
  /// Clears the value of `transactionValidDuration`. Subsequent reads from it will return its default value.
  mutating func clearTransactionValidDuration() {_uniqueStorage()._transactionValidDuration = nil}

  /// Should a record of this transaction be generated? (A receipt is always generated, but the record is optional)
  var generateRecord: Bool {
    get {return _storage._generateRecord}
    set {_uniqueStorage()._generateRecord = newValue}
  }

  /// Any notes or descriptions that should be put into the record (max length 100)
  var memo: String {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  /// Contains the call a function of a contract instance
  var contractCall: Proto_ContractCallTransactionBody {
    get {
      if case .contractCall(let v)? = _storage._data {return v}
      return Proto_ContractCallTransactionBody()
    }
    set {_uniqueStorage()._data = .contractCall(newValue)}
  }

  /// Contains the create data a contract instance
  var contractCreateInstance: Proto_ContractCreateTransactionBody {
    get {
      if case .contractCreateInstance(let v)? = _storage._data {return v}
      return Proto_ContractCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .contractCreateInstance(newValue)}
  }

  /// Contains contract modify info such as expiration date for a contract instance
  var contractUpdateInstance: Proto_ContractUpdateTransactionBody {
    get {
      if case .contractUpdateInstance(let v)? = _storage._data {return v}
      return Proto_ContractUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .contractUpdateInstance(newValue)}
  }

  ///Delete contract and transfer remaining balance into specified account
  var contractDeleteInstance: Proto_ContractDeleteTransactionBody {
    get {
      if case .contractDeleteInstance(let v)? = _storage._data {return v}
      return Proto_ContractDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .contractDeleteInstance(newValue)}
  }

  /// Attach a new claim to an account
  var cryptoAddClaim: Proto_CryptoAddClaimTransactionBody {
    get {
      if case .cryptoAddClaim(let v)? = _storage._data {return v}
      return Proto_CryptoAddClaimTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoAddClaim(newValue)}
  }

  /// Create a new cryptocurrency account
  var cryptoCreateAccount: Proto_CryptoCreateTransactionBody {
    get {
      if case .cryptoCreateAccount(let v)? = _storage._data {return v}
      return Proto_CryptoCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoCreateAccount(newValue)}
  }

  /// Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
  var cryptoDelete: Proto_CryptoDeleteTransactionBody {
    get {
      if case .cryptoDelete(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDelete(newValue)}
  }

  /// Remove a claim from an account
  var cryptoDeleteClaim: Proto_CryptoDeleteClaimTransactionBody {
    get {
      if case .cryptoDeleteClaim(let v)? = _storage._data {return v}
      return Proto_CryptoDeleteClaimTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoDeleteClaim(newValue)}
  }

  /// Transfer amount between accounts
  var cryptoTransfer: Proto_CryptoTransferTransactionBody {
    get {
      if case .cryptoTransfer(let v)? = _storage._data {return v}
      return Proto_CryptoTransferTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoTransfer(newValue)}
  }

  /// Modify information such as the expiration date for an account
  var cryptoUpdateAccount: Proto_CryptoUpdateTransactionBody {
    get {
      if case .cryptoUpdateAccount(let v)? = _storage._data {return v}
      return Proto_CryptoUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .cryptoUpdateAccount(newValue)}
  }

  /// Add bytes to the end of the contents of a file
  var fileAppend: Proto_FileAppendTransactionBody {
    get {
      if case .fileAppend(let v)? = _storage._data {return v}
      return Proto_FileAppendTransactionBody()
    }
    set {_uniqueStorage()._data = .fileAppend(newValue)}
  }

  /// Create a new file
  var fileCreate: Proto_FileCreateTransactionBody {
    get {
      if case .fileCreate(let v)? = _storage._data {return v}
      return Proto_FileCreateTransactionBody()
    }
    set {_uniqueStorage()._data = .fileCreate(newValue)}
  }

  /// Delete a file (remove contents and mark as deleted until it expires)
  var fileDelete: Proto_FileDeleteTransactionBody {
    get {
      if case .fileDelete(let v)? = _storage._data {return v}
      return Proto_FileDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .fileDelete(newValue)}
  }

  /// Modify information such as the expiration date for a file
  var fileUpdate: Proto_FileUpdateTransactionBody {
    get {
      if case .fileUpdate(let v)? = _storage._data {return v}
      return Proto_FileUpdateTransactionBody()
    }
    set {_uniqueStorage()._data = .fileUpdate(newValue)}
  }

  /// Hedera multisig system deletes a file or smart contract
  var systemDelete: Proto_SystemDeleteTransactionBody {
    get {
      if case .systemDelete(let v)? = _storage._data {return v}
      return Proto_SystemDeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .systemDelete(newValue)}
  }

  ///To undelete an entity deleted by SystemDelete
  var systemUndelete: Proto_SystemUndeleteTransactionBody {
    get {
      if case .systemUndelete(let v)? = _storage._data {return v}
      return Proto_SystemUndeleteTransactionBody()
    }
    set {_uniqueStorage()._data = .systemUndelete(newValue)}
  }

  /// Freeze the nodes
  var freeze: Proto_FreezeTransactionBody {
    get {
      if case .freeze(let v)? = _storage._data {return v}
      return Proto_FreezeTransactionBody()
    }
    set {_uniqueStorage()._data = .freeze(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    /// Contains the call a function of a contract instance
    case contractCall(Proto_ContractCallTransactionBody)
    /// Contains the create data a contract instance
    case contractCreateInstance(Proto_ContractCreateTransactionBody)
    /// Contains contract modify info such as expiration date for a contract instance
    case contractUpdateInstance(Proto_ContractUpdateTransactionBody)
    ///Delete contract and transfer remaining balance into specified account
    case contractDeleteInstance(Proto_ContractDeleteTransactionBody)
    /// Attach a new claim to an account
    case cryptoAddClaim(Proto_CryptoAddClaimTransactionBody)
    /// Create a new cryptocurrency account
    case cryptoCreateAccount(Proto_CryptoCreateTransactionBody)
    /// Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
    case cryptoDelete(Proto_CryptoDeleteTransactionBody)
    /// Remove a claim from an account
    case cryptoDeleteClaim(Proto_CryptoDeleteClaimTransactionBody)
    /// Transfer amount between accounts
    case cryptoTransfer(Proto_CryptoTransferTransactionBody)
    /// Modify information such as the expiration date for an account
    case cryptoUpdateAccount(Proto_CryptoUpdateTransactionBody)
    /// Add bytes to the end of the contents of a file
    case fileAppend(Proto_FileAppendTransactionBody)
    /// Create a new file
    case fileCreate(Proto_FileCreateTransactionBody)
    /// Delete a file (remove contents and mark as deleted until it expires)
    case fileDelete(Proto_FileDeleteTransactionBody)
    /// Modify information such as the expiration date for a file
    case fileUpdate(Proto_FileUpdateTransactionBody)
    /// Hedera multisig system deletes a file or smart contract
    case systemDelete(Proto_SystemDeleteTransactionBody)
    ///To undelete an entity deleted by SystemDelete
    case systemUndelete(Proto_SystemUndeleteTransactionBody)
    /// Freeze the nodes
    case freeze(Proto_FreezeTransactionBody)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_TransactionBody.OneOf_Data, rhs: Proto_TransactionBody.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.contractCall(let l), .contractCall(let r)): return l == r
      case (.contractCreateInstance(let l), .contractCreateInstance(let r)): return l == r
      case (.contractUpdateInstance(let l), .contractUpdateInstance(let r)): return l == r
      case (.contractDeleteInstance(let l), .contractDeleteInstance(let r)): return l == r
      case (.cryptoAddClaim(let l), .cryptoAddClaim(let r)): return l == r
      case (.cryptoCreateAccount(let l), .cryptoCreateAccount(let r)): return l == r
      case (.cryptoDelete(let l), .cryptoDelete(let r)): return l == r
      case (.cryptoDeleteClaim(let l), .cryptoDeleteClaim(let r)): return l == r
      case (.cryptoTransfer(let l), .cryptoTransfer(let r)): return l == r
      case (.cryptoUpdateAccount(let l), .cryptoUpdateAccount(let r)): return l == r
      case (.fileAppend(let l), .fileAppend(let r)): return l == r
      case (.fileCreate(let l), .fileCreate(let r)): return l == r
      case (.fileDelete(let l), .fileDelete(let r)): return l == r
      case (.fileUpdate(let l), .fileUpdate(let r)): return l == r
      case (.systemDelete(let l), .systemDelete(let r)): return l == r
      case (.systemUndelete(let l), .systemUndelete(let r)): return l == r
      case (.freeze(let l), .freeze(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_TransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionID"),
    2: .same(proto: "nodeAccountID"),
    3: .same(proto: "transactionFee"),
    4: .same(proto: "transactionValidDuration"),
    5: .same(proto: "generateRecord"),
    6: .same(proto: "memo"),
    7: .same(proto: "contractCall"),
    8: .same(proto: "contractCreateInstance"),
    9: .same(proto: "contractUpdateInstance"),
    22: .same(proto: "contractDeleteInstance"),
    10: .same(proto: "cryptoAddClaim"),
    11: .same(proto: "cryptoCreateAccount"),
    12: .same(proto: "cryptoDelete"),
    13: .same(proto: "cryptoDeleteClaim"),
    14: .same(proto: "cryptoTransfer"),
    15: .same(proto: "cryptoUpdateAccount"),
    16: .same(proto: "fileAppend"),
    17: .same(proto: "fileCreate"),
    18: .same(proto: "fileDelete"),
    19: .same(proto: "fileUpdate"),
    20: .same(proto: "systemDelete"),
    21: .same(proto: "systemUndelete"),
    23: .same(proto: "freeze"),
  ]

  fileprivate class _StorageClass {
    var _transactionID: Proto_TransactionID? = nil
    var _nodeAccountID: Proto_AccountID? = nil
    var _transactionFee: UInt64 = 0
    var _transactionValidDuration: Proto_Duration? = nil
    var _generateRecord: Bool = false
    var _memo: String = String()
    var _data: Proto_TransactionBody.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionID = source._transactionID
      _nodeAccountID = source._nodeAccountID
      _transactionFee = source._transactionFee
      _transactionValidDuration = source._transactionValidDuration
      _generateRecord = source._generateRecord
      _memo = source._memo
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transactionID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._nodeAccountID)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._transactionFee)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._transactionValidDuration)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._generateRecord)
        case 6: try decoder.decodeSingularStringField(value: &_storage._memo)
        case 7:
          var v: Proto_ContractCallTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .contractCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .contractCall(v)}
        case 8:
          var v: Proto_ContractCreateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .contractCreateInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .contractCreateInstance(v)}
        case 9:
          var v: Proto_ContractUpdateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .contractUpdateInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .contractUpdateInstance(v)}
        case 10:
          var v: Proto_CryptoAddClaimTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoAddClaim(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoAddClaim(v)}
        case 11:
          var v: Proto_CryptoCreateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoCreateAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoCreateAccount(v)}
        case 12:
          var v: Proto_CryptoDeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoDelete(v)}
        case 13:
          var v: Proto_CryptoDeleteClaimTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoDeleteClaim(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoDeleteClaim(v)}
        case 14:
          var v: Proto_CryptoTransferTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoTransfer(v)}
        case 15:
          var v: Proto_CryptoUpdateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .cryptoUpdateAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .cryptoUpdateAccount(v)}
        case 16:
          var v: Proto_FileAppendTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .fileAppend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .fileAppend(v)}
        case 17:
          var v: Proto_FileCreateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .fileCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .fileCreate(v)}
        case 18:
          var v: Proto_FileDeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .fileDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .fileDelete(v)}
        case 19:
          var v: Proto_FileUpdateTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .fileUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .fileUpdate(v)}
        case 20:
          var v: Proto_SystemDeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .systemDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .systemDelete(v)}
        case 21:
          var v: Proto_SystemUndeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .systemUndelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .systemUndelete(v)}
        case 22:
          var v: Proto_ContractDeleteTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .contractDeleteInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .contractDeleteInstance(v)}
        case 23:
          var v: Proto_FreezeTransactionBody?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .freeze(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .freeze(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transactionID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._nodeAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._transactionFee != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._transactionFee, fieldNumber: 3)
      }
      if let v = _storage._transactionValidDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._generateRecord != false {
        try visitor.visitSingularBoolField(value: _storage._generateRecord, fieldNumber: 5)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 6)
      }
      switch _storage._data {
      case .contractCall(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .contractCreateInstance(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .contractUpdateInstance(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .cryptoAddClaim(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .cryptoCreateAccount(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .cryptoDelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .cryptoDeleteClaim(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .cryptoTransfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .cryptoUpdateAccount(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .fileAppend(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .fileCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .fileDelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .fileUpdate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .systemDelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .systemUndelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .contractDeleteInstance(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .freeze(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TransactionBody, rhs: Proto_TransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._nodeAccountID != rhs_storage._nodeAccountID {return false}
        if _storage._transactionFee != rhs_storage._transactionFee {return false}
        if _storage._transactionValidDuration != rhs_storage._transactionValidDuration {return false}
        if _storage._generateRecord != rhs_storage._generateRecord {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
