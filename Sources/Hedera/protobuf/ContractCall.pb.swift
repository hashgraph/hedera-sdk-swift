// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ContractCall.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.
///
/// If this function stores information, it is charged gas to store it. There is a fee in hbars to maintain that storage until the expiration time, and that fee is added as part of the transaction fee.
struct Proto_ContractCallTransactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the contract instance to call, in the format used in transactions
  var contractID: Proto_ContractID {
    get {return _storage._contractID ?? Proto_ContractID()}
    set {_uniqueStorage()._contractID = newValue}
  }
  /// Returns true if `contractID` has been explicitly set.
  var hasContractID: Bool {return _storage._contractID != nil}
  /// Clears the value of `contractID`. Subsequent reads from it will return its default value.
  mutating func clearContractID() {_uniqueStorage()._contractID = nil}

  /// the maximum amount of gas to use for the call
  var gas: Int64 {
    get {return _storage._gas}
    set {_uniqueStorage()._gas = newValue}
  }

  /// number of tinybars sent (the function must be payable if this is nonzero)
  var amount: Int64 {
    get {return _storage._amount}
    set {_uniqueStorage()._amount = newValue}
  }

  /// which function to call, and the parameters to pass to the function
  var functionParameters: Data {
    get {return _storage._functionParameters}
    set {_uniqueStorage()._functionParameters = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ContractCallTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractCallTransactionBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "gas"),
    3: .same(proto: "amount"),
    4: .same(proto: "functionParameters"),
  ]

  fileprivate class _StorageClass {
    var _contractID: Proto_ContractID? = nil
    var _gas: Int64 = 0
    var _amount: Int64 = 0
    var _functionParameters: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contractID = source._contractID
      _gas = source._gas
      _amount = source._amount
      _functionParameters = source._functionParameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._contractID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._gas)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._amount)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._functionParameters)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._contractID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._gas != 0 {
        try visitor.visitSingularInt64Field(value: _storage._gas, fieldNumber: 2)
      }
      if _storage._amount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amount, fieldNumber: 3)
      }
      if !_storage._functionParameters.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._functionParameters, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ContractCallTransactionBody, rhs: Proto_ContractCallTransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contractID != rhs_storage._contractID {return false}
        if _storage._gas != rhs_storage._gas {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._functionParameters != rhs_storage._functionParameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
