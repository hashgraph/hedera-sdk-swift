// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: QueryHeader.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. 
enum Proto_ResponseType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Response returns answer
  case answerOnly // = 0

  /// Response returns both answer and state proof
  case answerStateProof // = 1

  /// Response returns the cost of answer
  case costAnswer // = 2

  /// Response returns the total cost of answer and state proof
  case costAnswerStateProof // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .answerOnly
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .answerOnly
    case 1: self = .answerStateProof
    case 2: self = .costAnswer
    case 3: self = .costAnswerStateProof
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .answerOnly: return 0
    case .answerStateProof: return 1
    case .costAnswer: return 2
    case .costAnswerStateProof: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ResponseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ResponseType] = [
    .answerOnly,
    .answerStateProof,
    .costAnswer,
    .costAnswerStateProof,
  ]
}

#endif  // swift(>=4.2)

/// Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. 
struct Proto_QueryHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A signed CryptoTransferTransaction to pay the node a fee for handling this query
  var payment: Proto_Transaction {
    get {return _storage._payment ?? Proto_Transaction()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  mutating func clearPayment() {_uniqueStorage()._payment = nil}

  /// The requested response, asking for cost, state proof, both, or neither
  var responseType: Proto_ResponseType {
    get {return _storage._responseType}
    set {_uniqueStorage()._responseType = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ResponseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANSWER_ONLY"),
    1: .same(proto: "ANSWER_STATE_PROOF"),
    2: .same(proto: "COST_ANSWER"),
    3: .same(proto: "COST_ANSWER_STATE_PROOF"),
  ]
}

extension Proto_QueryHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment"),
    2: .same(proto: "responseType"),
  ]

  fileprivate class _StorageClass {
    var _payment: Proto_Transaction? = nil
    var _responseType: Proto_ResponseType = .answerOnly

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _payment = source._payment
      _responseType = source._responseType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._payment)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._responseType)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._responseType != .answerOnly {
        try visitor.visitSingularEnumField(value: _storage._responseType, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_QueryHeader, rhs: Proto_QueryHeader) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._responseType != rhs_storage._responseType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
