// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: BasicTypes.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The functionality provided by hedera hashgraph 
enum Proto_HederaFunctionality: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and not parsed (0 is ignored by parser)
  case none // = 0

  /// crypto transfer
  case cryptoTransfer // = 1

  /// crypto update account
  case cryptoUpdate // = 2

  /// crypto delete account
  case cryptoDelete // = 3

  /// crypto add claim to the account
  case cryptoAddClaim // = 4

  /// crypto delete claim to the account
  case cryptoDeleteClaim // = 5

  /// Smart Contract Call
  case contractCall // = 6

  /// Smart Contract Create Contract
  case contractCreate // = 7

  /// Smart Contract update contract
  case contractUpdate // = 8

  /// File Operation create file
  case fileCreate // = 9

  /// File Operation append file
  case fileAppend // = 10

  /// File Operation update file
  case fileUpdate // = 11

  /// File Operation delete file
  case fileDelete // = 12

  /// crypto get account balance
  case cryptoGetAccountBalance // = 13

  /// crypto get account record
  case cryptoGetAccountRecords // = 14

  /// Crypto get info
  case cryptoGetInfo // = 15

  /// Smart Contract Call
  case contractCallLocal // = 16

  /// Smart Contract get info
  case contractGetInfo // = 17

  /// Smart Contract, get the byte code
  case contractGetBytecode // = 18

  /// Smart Contract, get by solidity ID
  case getBySolidityID // = 19

  /// Smart Contract, get by key
  case getByKey // = 20

  /// Crypto get the claim
  case cryptoGetClaim // = 21

  /// Crypto, get the stakers for the node
  case cryptoGetStakers // = 22

  /// File Operations get file contents
  case fileGetContents // = 23

  /// File Operations get the info of the file
  case fileGetInfo // = 24

  /// Crypto get the transaction records
  case transactionGetRecord // = 25

  /// Contract get the transaction records
  case contractGetRecords // = 26

  /// crypto create account
  case cryptoCreate // = 27

  /// system delete file
  case systemDelete // = 28

  /// system undelete file
  case systemUndelete // = 29

  /// delete contract
  case contractDelete // = 30

  /// freeze
  case freeze // = 31

  /// Create Tx Record
  case createTransactionRecord // = 32

  /// Crypto Auto Renew
  case cryptoAccountAutoRenew // = 33

  /// Contract Auto Renew
  case contractAutoRenew // = 34

  ///Get Version
  case getVersion // = 35

  /// Transaction Get Receipt
  case transactionGetReceipt // = 36
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .cryptoTransfer
    case 2: self = .cryptoUpdate
    case 3: self = .cryptoDelete
    case 4: self = .cryptoAddClaim
    case 5: self = .cryptoDeleteClaim
    case 6: self = .contractCall
    case 7: self = .contractCreate
    case 8: self = .contractUpdate
    case 9: self = .fileCreate
    case 10: self = .fileAppend
    case 11: self = .fileUpdate
    case 12: self = .fileDelete
    case 13: self = .cryptoGetAccountBalance
    case 14: self = .cryptoGetAccountRecords
    case 15: self = .cryptoGetInfo
    case 16: self = .contractCallLocal
    case 17: self = .contractGetInfo
    case 18: self = .contractGetBytecode
    case 19: self = .getBySolidityID
    case 20: self = .getByKey
    case 21: self = .cryptoGetClaim
    case 22: self = .cryptoGetStakers
    case 23: self = .fileGetContents
    case 24: self = .fileGetInfo
    case 25: self = .transactionGetRecord
    case 26: self = .contractGetRecords
    case 27: self = .cryptoCreate
    case 28: self = .systemDelete
    case 29: self = .systemUndelete
    case 30: self = .contractDelete
    case 31: self = .freeze
    case 32: self = .createTransactionRecord
    case 33: self = .cryptoAccountAutoRenew
    case 34: self = .contractAutoRenew
    case 35: self = .getVersion
    case 36: self = .transactionGetReceipt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .cryptoTransfer: return 1
    case .cryptoUpdate: return 2
    case .cryptoDelete: return 3
    case .cryptoAddClaim: return 4
    case .cryptoDeleteClaim: return 5
    case .contractCall: return 6
    case .contractCreate: return 7
    case .contractUpdate: return 8
    case .fileCreate: return 9
    case .fileAppend: return 10
    case .fileUpdate: return 11
    case .fileDelete: return 12
    case .cryptoGetAccountBalance: return 13
    case .cryptoGetAccountRecords: return 14
    case .cryptoGetInfo: return 15
    case .contractCallLocal: return 16
    case .contractGetInfo: return 17
    case .contractGetBytecode: return 18
    case .getBySolidityID: return 19
    case .getByKey: return 20
    case .cryptoGetClaim: return 21
    case .cryptoGetStakers: return 22
    case .fileGetContents: return 23
    case .fileGetInfo: return 24
    case .transactionGetRecord: return 25
    case .contractGetRecords: return 26
    case .cryptoCreate: return 27
    case .systemDelete: return 28
    case .systemUndelete: return 29
    case .contractDelete: return 30
    case .freeze: return 31
    case .createTransactionRecord: return 32
    case .cryptoAccountAutoRenew: return 33
    case .contractAutoRenew: return 34
    case .getVersion: return 35
    case .transactionGetReceipt: return 36
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_HederaFunctionality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_HederaFunctionality] = [
    .none,
    .cryptoTransfer,
    .cryptoUpdate,
    .cryptoDelete,
    .cryptoAddClaim,
    .cryptoDeleteClaim,
    .contractCall,
    .contractCreate,
    .contractUpdate,
    .fileCreate,
    .fileAppend,
    .fileUpdate,
    .fileDelete,
    .cryptoGetAccountBalance,
    .cryptoGetAccountRecords,
    .cryptoGetInfo,
    .contractCallLocal,
    .contractGetInfo,
    .contractGetBytecode,
    .getBySolidityID,
    .getByKey,
    .cryptoGetClaim,
    .cryptoGetStakers,
    .fileGetContents,
    .fileGetInfo,
    .transactionGetRecord,
    .contractGetRecords,
    .cryptoCreate,
    .systemDelete,
    .systemUndelete,
    .contractDelete,
    .freeze,
    .createTransactionRecord,
    .cryptoAccountAutoRenew,
    .contractAutoRenew,
    .getVersion,
    .transactionGetReceipt,
  ]
}

#endif  // swift(>=4.2)

/// Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
///
///Everything is partitioned into realms so that each Solidity smart contract can  access everything in just a single realm, locking all those entities while it's  running, but other smart contracts could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized somewhat, even though the  language itself assumes everything is serial. 
struct Proto_ShardID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the shard number (nonnegative)
  var shardNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. 
struct Proto_RealmID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The shard number (nonnegative)
  var shardNum: Int64 = 0

  ///The realm number (nonnegative)
  var realmNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for an a cryptocurrency account  
struct Proto_AccountID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The shard number (nonnegative)
  var shardNum: Int64 = 0

  ///The realm number (nonnegative)
  var realmNum: Int64 = 0

  ///A nonnegative account number unique within its realm
  var accountNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for a file  
struct Proto_FileID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The shard number (nonnegative)
  var shardNum: Int64 = 0

  ///The realm number (nonnegative)
  var realmNum: Int64 = 0

  ///A nonnegative File number unique within its realm
  var fileNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for a smart contract instance  
struct Proto_ContractID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The shard number (nonnegative)
  var shardNum: Int64 = 0

  ///The realm number (nonnegative)
  var realmNum: Int64 = 0

  ///A nonnegative number unique within its realm
  var contractNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. 
struct Proto_TransactionID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
  var transactionValidStart: Proto_Timestamp {
    get {return _storage._transactionValidStart ?? Proto_Timestamp()}
    set {_uniqueStorage()._transactionValidStart = newValue}
  }
  /// Returns true if `transactionValidStart` has been explicitly set.
  var hasTransactionValidStart: Bool {return _storage._transactionValidStart != nil}
  /// Clears the value of `transactionValidStart`. Subsequent reads from it will return its default value.
  mutating func clearTransactionValidStart() {_uniqueStorage()._transactionValidStart = nil}

  ///The Account ID that paid for this transaction
  var accountID: Proto_AccountID {
    get {return _storage._accountID ?? Proto_AccountID()}
    set {_uniqueStorage()._accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return _storage._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.
///
/// A Key can be a smart contract ID, which means that smart contract is to authorize operations as if it had signed with a key that it owned. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key.
///
/// A key can be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements.
///
/// A Key can be a list of keys. Their use is dependent on context. For example, a Hedera file is created with a list of keys, where all of them must sign a transaction to create or modify the file, but only one of them is needed to sign a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold key, and sometimes acts as an M-of-M threshold key.
///
/// A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive keys (e.g., ed25519) has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive keys (e.g., ed25519) has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels: Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
///
/// Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
struct Proto_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: OneOf_Key? {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// smart contract instance that is authorized as if it had signed with a key
  var contractID: Proto_ContractID {
    get {
      if case .contractID(let v)? = _storage._key {return v}
      return Proto_ContractID()
    }
    set {_uniqueStorage()._key = .contractID(newValue)}
  }

  /// ed25519 public key bytes
  var ed25519: Data {
    get {
      if case .ed25519(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .ed25519(newValue)}
  }

  ///RSA-3072 public key bytes
  var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .rsa3072(newValue)}
  }

  ///ECDSA with the p-384 curve public key bytes
  var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .ecdsa384(newValue)}
  }

  /// a threshold N followed by a list of M keys, any N of which are required to form a valid signature
  var thresholdKey: Proto_ThresholdKey {
    get {
      if case .thresholdKey(let v)? = _storage._key {return v}
      return Proto_ThresholdKey()
    }
    set {_uniqueStorage()._key = .thresholdKey(newValue)}
  }

  /// A list of Keys of the Key type.
  var keyList: Proto_KeyList {
    get {
      if case .keyList(let v)? = _storage._key {return v}
      return Proto_KeyList()
    }
    set {_uniqueStorage()._key = .keyList(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Key: Equatable {
    /// smart contract instance that is authorized as if it had signed with a key
    case contractID(Proto_ContractID)
    /// ed25519 public key bytes
    case ed25519(Data)
    ///RSA-3072 public key bytes
    case rsa3072(Data)
    ///ECDSA with the p-384 curve public key bytes
    case ecdsa384(Data)
    /// a threshold N followed by a list of M keys, any N of which are required to form a valid signature
    case thresholdKey(Proto_ThresholdKey)
    /// A list of Keys of the Key type.
    case keyList(Proto_KeyList)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Key.OneOf_Key, rhs: Proto_Key.OneOf_Key) -> Bool {
      switch (lhs, rhs) {
      case (.contractID(let l), .contractID(let r)): return l == r
      case (.ed25519(let l), .ed25519(let r)): return l == r
      case (.rsa3072(let l), .rsa3072(let r)): return l == r
      case (.ecdsa384(let l), .ecdsa384(let r)): return l == r
      case (.thresholdKey(let l), .thresholdKey(let r)): return l == r
      case (.keyList(let l), .keyList(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. 
struct Proto_ThresholdKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A valid signature set must have at least this many signatures
  var threshold: UInt32 {
    get {return _storage._threshold}
    set {_uniqueStorage()._threshold = newValue}
  }

  /// List of all the keys that can sign
  var keys: Proto_KeyList {
    get {return _storage._keys ?? Proto_KeyList()}
    set {_uniqueStorage()._keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  var hasKeys: Bool {return _storage._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  mutating func clearKeys() {_uniqueStorage()._keys = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of keys 
struct Proto_KeyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list of keys
  var keys: [Proto_Key] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.
/// The definition of Key uses mutual recursion, so it allows nesting that is arbitrarily deep. But the current API only accepts Key messages up to 3 levels deep, such as a list of threshold keys, each of which is a list of primitive keys. Therefore, the matching Signature will have the same limitation. This restriction may be relaxed in future versions of the API, to allow deeper nesting.
/// This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
struct Proto_Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signature: OneOf_Signature? {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  /// smart contract virtual signature (always length zero)
  var contract: Data {
    get {
      if case .contract(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .contract(newValue)}
  }

  /// ed25519 signature bytes
  var ed25519: Data {
    get {
      if case .ed25519(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .ed25519(newValue)}
  }

  ///RSA-3072 signature bytes
  var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .rsa3072(newValue)}
  }

  ///ECDSA p-384 signature bytes
  var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .ecdsa384(newValue)}
  }

  /// A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.
  var thresholdSignature: Proto_ThresholdSignature {
    get {
      if case .thresholdSignature(let v)? = _storage._signature {return v}
      return Proto_ThresholdSignature()
    }
    set {_uniqueStorage()._signature = .thresholdSignature(newValue)}
  }

  /// A list of M signatures, each corresponding to a Key in a KeyList of the same length.
  var signatureList: Proto_SignatureList {
    get {
      if case .signatureList(let v)? = _storage._signature {return v}
      return Proto_SignatureList()
    }
    set {_uniqueStorage()._signature = .signatureList(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Signature: Equatable {
    /// smart contract virtual signature (always length zero)
    case contract(Data)
    /// ed25519 signature bytes
    case ed25519(Data)
    ///RSA-3072 signature bytes
    case rsa3072(Data)
    ///ECDSA p-384 signature bytes
    case ecdsa384(Data)
    /// A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.
    case thresholdSignature(Proto_ThresholdSignature)
    /// A list of M signatures, each corresponding to a Key in a KeyList of the same length.
    case signatureList(Proto_SignatureList)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Signature.OneOf_Signature, rhs: Proto_Signature.OneOf_Signature) -> Bool {
      switch (lhs, rhs) {
      case (.contract(let l), .contract(let r)): return l == r
      case (.ed25519(let l), .ed25519(let r)): return l == r
      case (.rsa3072(let l), .rsa3072(let r)): return l == r
      case (.ecdsa384(let l), .ecdsa384(let r)): return l == r
      case (.thresholdSignature(let l), .thresholdSignature(let r)): return l == r
      case (.signatureList(let l), .signatureList(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. 
/// This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
struct Proto_ThresholdSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null
  var sigs: Proto_SignatureList {
    get {return _storage._sigs ?? Proto_SignatureList()}
    set {_uniqueStorage()._sigs = newValue}
  }
  /// Returns true if `sigs` has been explicitly set.
  var hasSigs: Bool {return _storage._sigs != nil}
  /// Clears the value of `sigs`. Subsequent reads from it will return its default value.
  mutating func clearSigs() {_uniqueStorage()._sigs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The signatures corresponding to a KeyList of the same length.
/// This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
struct Proto_SignatureList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// each signature corresponds to a Key in the KeyList
  var sigs: [Proto_Signature] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The client may use any number of bytes from 0 to the whole length of the public key for pubKeyPrefix. 
/// If 0 bytes is used, then it is assumed that only one public key is used to sign.
struct Proto_SignaturePair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// First few bytes of the public key
  var pubKeyPrefix: Data = SwiftProtobuf.Internal.emptyData

  var signature: Proto_SignaturePair.OneOf_Signature? = nil

  /// smart contract virtual signature (always length zero)
  var contract: Data {
    get {
      if case .contract(let v)? = signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {signature = .contract(newValue)}
  }

  /// ed25519 signature
  var ed25519: Data {
    get {
      if case .ed25519(let v)? = signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {signature = .ed25519(newValue)}
  }

  ///RSA-3072 signature
  var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {signature = .rsa3072(newValue)}
  }

  ///ECDSA p-384 signature
  var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {signature = .ecdsa384(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Signature: Equatable {
    /// smart contract virtual signature (always length zero)
    case contract(Data)
    /// ed25519 signature
    case ed25519(Data)
    ///RSA-3072 signature
    case rsa3072(Data)
    ///ECDSA p-384 signature
    case ecdsa384(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_SignaturePair.OneOf_Signature, rhs: Proto_SignaturePair.OneOf_Signature) -> Bool {
      switch (lhs, rhs) {
      case (.contract(let l), .contract(let r)): return l == r
      case (.ed25519(let l), .ed25519(let r)): return l == r
      case (.rsa3072(let l), .rsa3072(let r)): return l == r
      case (.ecdsa384(let l), .ecdsa384(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// A set of signatures corresponding to every unique public key used to sign a given transaction. 
/// If one public key matches more than one prefixes on the signature map, the transaction containing the map will fail immediately with the response code KEY_PREFIX_MISMATCH.  
struct Proto_SignatureMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Each signature pair corresponds to a unique Key required to sign the transaction.
  var sigPair: [Proto_SignaturePair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_FeeComponents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum fees that needs to be paid
  var min: Int64 = 0

  /// The maximum fees that can be submitted
  var max: Int64 = 0

  /// A constant determined by the business to calculate the fees
  var constant: Int64 = 0

  /// Bytes per transaction
  var bpt: Int64 = 0

  /// Verifications per transaction
  var vpt: Int64 = 0

  /// Ram byte seconds
  var rbh: Int64 = 0

  /// Storage byte seconds
  var sbh: Int64 = 0

  /// Gas for the contract execution
  var gas: Int64 = 0

  /// Transaction value (crypto transfers amount, tv is in tiny bars divided by 1000, rounded down)
  var tv: Int64 = 0

  /// Bytes per response
  var bpr: Int64 = 0

  /// Storage bytes per response
  var sbpr: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The fees for a specific transaction or query based on the fee data. 
struct Proto_TransactionFeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specific Transaction or Query
  var hederaFunctionality: Proto_HederaFunctionality {
    get {return _storage._hederaFunctionality}
    set {_uniqueStorage()._hederaFunctionality = newValue}
  }

  /// The fee information about the query/data
  var feeData: Proto_FeeData {
    get {return _storage._feeData ?? Proto_FeeData()}
    set {_uniqueStorage()._feeData = newValue}
  }
  /// Returns true if `feeData` has been explicitly set.
  var hasFeeData: Bool {return _storage._feeData != nil}
  /// Clears the value of `feeData`. Subsequent reads from it will return its default value.
  mutating func clearFeeData() {_uniqueStorage()._feeData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The total fees charged for a transaction. It contains three parts namely node data, network data and service data 
struct Proto_FeeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fee charged by Node for this functionality
  var nodedata: Proto_FeeComponents {
    get {return _storage._nodedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._nodedata = newValue}
  }
  /// Returns true if `nodedata` has been explicitly set.
  var hasNodedata: Bool {return _storage._nodedata != nil}
  /// Clears the value of `nodedata`. Subsequent reads from it will return its default value.
  mutating func clearNodedata() {_uniqueStorage()._nodedata = nil}

  /// Fee charged for network operations by Hedera
  var networkdata: Proto_FeeComponents {
    get {return _storage._networkdata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._networkdata = newValue}
  }
  /// Returns true if `networkdata` has been explicitly set.
  var hasNetworkdata: Bool {return _storage._networkdata != nil}
  /// Clears the value of `networkdata`. Subsequent reads from it will return its default value.
  mutating func clearNetworkdata() {_uniqueStorage()._networkdata = nil}

  /// Fee charged for providing service by Hedera
  var servicedata: Proto_FeeComponents {
    get {return _storage._servicedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._servicedata = newValue}
  }
  /// Returns true if `servicedata` has been explicitly set.
  var hasServicedata: Bool {return _storage._servicedata != nil}
  /// Clears the value of `servicedata`. Subsequent reads from it will return its default value.
  mutating func clearServicedata() {_uniqueStorage()._servicedata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The fee schedule for a specific hedera functionality and the time period this fee schedule will expire  
struct Proto_FeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains multiple functionality specific fee schedule.
  var transactionFeeSchedule: [Proto_TransactionFeeSchedule] {
    get {return _storage._transactionFeeSchedule}
    set {_uniqueStorage()._transactionFeeSchedule = newValue}
  }

  /// FeeSchedule expiry time
  var expiryTime: Proto_TimestampSeconds {
    get {return _storage._expiryTime ?? Proto_TimestampSeconds()}
    set {_uniqueStorage()._expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  var hasExpiryTime: Bool {return _storage._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  mutating func clearExpiryTime() {_uniqueStorage()._expiryTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This contains two Fee Schedules with expiry timestamp. 
struct Proto_CurrentAndNextFeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains current Fee Schedule
  var currentFeeSchedule: Proto_FeeSchedule {
    get {return _storage._currentFeeSchedule ?? Proto_FeeSchedule()}
    set {_uniqueStorage()._currentFeeSchedule = newValue}
  }
  /// Returns true if `currentFeeSchedule` has been explicitly set.
  var hasCurrentFeeSchedule: Bool {return _storage._currentFeeSchedule != nil}
  /// Clears the value of `currentFeeSchedule`. Subsequent reads from it will return its default value.
  mutating func clearCurrentFeeSchedule() {_uniqueStorage()._currentFeeSchedule = nil}

  /// Contains next Fee Schedule
  var nextFeeSchedule: Proto_FeeSchedule {
    get {return _storage._nextFeeSchedule ?? Proto_FeeSchedule()}
    set {_uniqueStorage()._nextFeeSchedule = newValue}
  }
  /// Returns true if `nextFeeSchedule` has been explicitly set.
  var hasNextFeeSchedule: Bool {return _storage._nextFeeSchedule != nil}
  /// Clears the value of `nextFeeSchedule`. Subsequent reads from it will return its default value.
  mutating func clearNextFeeSchedule() {_uniqueStorage()._nextFeeSchedule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The information about a node 
struct Proto_NodeAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ip address of the Node with separator & octets
  var ipAddress: Data = SwiftProtobuf.Internal.emptyData

  /// The port number of the grpc server for the node
  var portno: Int32 = 0

  /// The memo field of the node
  var memo: Data = SwiftProtobuf.Internal.emptyData

  /// The RSA public key of the node.
  var rsaPubKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Gives the node addresses in the address book 
struct Proto_NodeAddressBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains multiple Node Address for the network
  var nodeAddress: [Proto_NodeAddress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_HederaFunctionality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CryptoTransfer"),
    2: .same(proto: "CryptoUpdate"),
    3: .same(proto: "CryptoDelete"),
    4: .same(proto: "CryptoAddClaim"),
    5: .same(proto: "CryptoDeleteClaim"),
    6: .same(proto: "ContractCall"),
    7: .same(proto: "ContractCreate"),
    8: .same(proto: "ContractUpdate"),
    9: .same(proto: "FileCreate"),
    10: .same(proto: "FileAppend"),
    11: .same(proto: "FileUpdate"),
    12: .same(proto: "FileDelete"),
    13: .same(proto: "CryptoGetAccountBalance"),
    14: .same(proto: "CryptoGetAccountRecords"),
    15: .same(proto: "CryptoGetInfo"),
    16: .same(proto: "ContractCallLocal"),
    17: .same(proto: "ContractGetInfo"),
    18: .same(proto: "ContractGetBytecode"),
    19: .same(proto: "GetBySolidityID"),
    20: .same(proto: "GetByKey"),
    21: .same(proto: "CryptoGetClaim"),
    22: .same(proto: "CryptoGetStakers"),
    23: .same(proto: "FileGetContents"),
    24: .same(proto: "FileGetInfo"),
    25: .same(proto: "TransactionGetRecord"),
    26: .same(proto: "ContractGetRecords"),
    27: .same(proto: "CryptoCreate"),
    28: .same(proto: "SystemDelete"),
    29: .same(proto: "SystemUndelete"),
    30: .same(proto: "ContractDelete"),
    31: .same(proto: "Freeze"),
    32: .same(proto: "CreateTransactionRecord"),
    33: .same(proto: "CryptoAccountAutoRenew"),
    34: .same(proto: "ContractAutoRenew"),
    35: .same(proto: "getVersion"),
    36: .same(proto: "TransactionGetReceipt"),
  ]
}

extension Proto_ShardID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShardID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ShardID, rhs: Proto_ShardID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RealmID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RealmID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RealmID, rhs: Proto_RealmID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "accountNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.accountNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.accountNum != 0 {
      try visitor.visitSingularInt64Field(value: self.accountNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AccountID, rhs: Proto_AccountID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.accountNum != rhs.accountNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FileID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "fileNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.fileNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.fileNum != 0 {
      try visitor.visitSingularInt64Field(value: self.fileNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FileID, rhs: Proto_FileID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.fileNum != rhs.fileNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContractID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "contractNum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.contractNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.contractNum != 0 {
      try visitor.visitSingularInt64Field(value: self.contractNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ContractID, rhs: Proto_ContractID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.contractNum != rhs.contractNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionValidStart"),
    2: .same(proto: "accountID"),
  ]

  fileprivate class _StorageClass {
    var _transactionValidStart: Proto_Timestamp? = nil
    var _accountID: Proto_AccountID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionValidStart = source._transactionValidStart
      _accountID = source._accountID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transactionValidStart)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._accountID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transactionValidStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TransactionID, rhs: Proto_TransactionID) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionValidStart != rhs_storage._transactionValidStart {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Key"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdKey"),
    6: .same(proto: "keyList"),
  ]

  fileprivate class _StorageClass {
    var _key: Proto_Key.OneOf_Key?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Proto_ContractID?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .contractID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .contractID(v)}
        case 2:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .ed25519(v)}
        case 3:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .rsa3072(v)}
        case 4:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .ecdsa384(v)}
        case 5:
          var v: Proto_ThresholdKey?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .thresholdKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .thresholdKey(v)}
        case 6:
          var v: Proto_KeyList?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .keyList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .keyList(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._key {
      case .contractID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .ed25519(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      case .rsa3072(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      case .ecdsa384(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      case .thresholdKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .keyList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Key, rhs: Proto_Key) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThresholdKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "keys"),
  ]

  fileprivate class _StorageClass {
    var _threshold: UInt32 = 0
    var _keys: Proto_KeyList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _threshold = source._threshold
      _keys = source._keys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._threshold)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._keys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._threshold != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._threshold, fieldNumber: 1)
      }
      if let v = _storage._keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ThresholdKey, rhs: Proto_ThresholdKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._threshold != rhs_storage._threshold {return false}
        if _storage._keys != rhs_storage._keys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_KeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_KeyList, rhs: Proto_KeyList) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Signature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contract"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdSignature"),
    6: .same(proto: "signatureList"),
  ]

  fileprivate class _StorageClass {
    var _signature: Proto_Signature.OneOf_Signature?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .contract(v)}
        case 2:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .ed25519(v)}
        case 3:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .rsa3072(v)}
        case 4:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .ecdsa384(v)}
        case 5:
          var v: Proto_ThresholdSignature?
          if let current = _storage._signature {
            try decoder.handleConflictingOneOf()
            if case .thresholdSignature(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._signature = .thresholdSignature(v)}
        case 6:
          var v: Proto_SignatureList?
          if let current = _storage._signature {
            try decoder.handleConflictingOneOf()
            if case .signatureList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._signature = .signatureList(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._signature {
      case .contract(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      case .ed25519(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      case .rsa3072(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      case .ecdsa384(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      case .thresholdSignature(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .signatureList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Signature, rhs: Proto_Signature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThresholdSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  fileprivate class _StorageClass {
    var _sigs: Proto_SignatureList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sigs = source._sigs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sigs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sigs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ThresholdSignature, rhs: Proto_ThresholdSignature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sigs != rhs_storage._sigs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignatureList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.sigs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SignatureList, rhs: Proto_SignatureList) -> Bool {
    if lhs.sigs != rhs.sigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignaturePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignaturePair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubKeyPrefix"),
    2: .same(proto: "contract"),
    3: .same(proto: "ed25519"),
    4: .standard(proto: "RSA_3072"),
    5: .standard(proto: "ECDSA_384"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.pubKeyPrefix)
      case 2:
        if self.signature != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.signature = .contract(v)}
      case 3:
        if self.signature != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.signature = .ed25519(v)}
      case 4:
        if self.signature != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.signature = .rsa3072(v)}
      case 5:
        if self.signature != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.signature = .ecdsa384(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKeyPrefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKeyPrefix, fieldNumber: 1)
    }
    switch self.signature {
    case .contract(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    case .ed25519(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case .rsa3072(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    case .ecdsa384(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SignaturePair, rhs: Proto_SignaturePair) -> Bool {
    if lhs.pubKeyPrefix != rhs.pubKeyPrefix {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignatureMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sigPair"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sigPair)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigPair.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigPair, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SignatureMap, rhs: Proto_SignatureMap) -> Bool {
    if lhs.sigPair != rhs.sigPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeComponents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeComponents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .same(proto: "constant"),
    4: .same(proto: "bpt"),
    5: .same(proto: "vpt"),
    6: .same(proto: "rbh"),
    7: .same(proto: "sbh"),
    8: .same(proto: "gas"),
    9: .same(proto: "tv"),
    10: .same(proto: "bpr"),
    11: .same(proto: "sbpr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.min)
      case 2: try decoder.decodeSingularInt64Field(value: &self.max)
      case 3: try decoder.decodeSingularInt64Field(value: &self.constant)
      case 4: try decoder.decodeSingularInt64Field(value: &self.bpt)
      case 5: try decoder.decodeSingularInt64Field(value: &self.vpt)
      case 6: try decoder.decodeSingularInt64Field(value: &self.rbh)
      case 7: try decoder.decodeSingularInt64Field(value: &self.sbh)
      case 8: try decoder.decodeSingularInt64Field(value: &self.gas)
      case 9: try decoder.decodeSingularInt64Field(value: &self.tv)
      case 10: try decoder.decodeSingularInt64Field(value: &self.bpr)
      case 11: try decoder.decodeSingularInt64Field(value: &self.sbpr)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularInt64Field(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularInt64Field(value: self.max, fieldNumber: 2)
    }
    if self.constant != 0 {
      try visitor.visitSingularInt64Field(value: self.constant, fieldNumber: 3)
    }
    if self.bpt != 0 {
      try visitor.visitSingularInt64Field(value: self.bpt, fieldNumber: 4)
    }
    if self.vpt != 0 {
      try visitor.visitSingularInt64Field(value: self.vpt, fieldNumber: 5)
    }
    if self.rbh != 0 {
      try visitor.visitSingularInt64Field(value: self.rbh, fieldNumber: 6)
    }
    if self.sbh != 0 {
      try visitor.visitSingularInt64Field(value: self.sbh, fieldNumber: 7)
    }
    if self.gas != 0 {
      try visitor.visitSingularInt64Field(value: self.gas, fieldNumber: 8)
    }
    if self.tv != 0 {
      try visitor.visitSingularInt64Field(value: self.tv, fieldNumber: 9)
    }
    if self.bpr != 0 {
      try visitor.visitSingularInt64Field(value: self.bpr, fieldNumber: 10)
    }
    if self.sbpr != 0 {
      try visitor.visitSingularInt64Field(value: self.sbpr, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FeeComponents, rhs: Proto_FeeComponents) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.constant != rhs.constant {return false}
    if lhs.bpt != rhs.bpt {return false}
    if lhs.vpt != rhs.vpt {return false}
    if lhs.rbh != rhs.rbh {return false}
    if lhs.sbh != rhs.sbh {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.tv != rhs.tv {return false}
    if lhs.bpr != rhs.bpr {return false}
    if lhs.sbpr != rhs.sbpr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionFeeSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hederaFunctionality"),
    2: .same(proto: "feeData"),
  ]

  fileprivate class _StorageClass {
    var _hederaFunctionality: Proto_HederaFunctionality = .none
    var _feeData: Proto_FeeData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hederaFunctionality = source._hederaFunctionality
      _feeData = source._feeData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._hederaFunctionality)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._feeData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._hederaFunctionality != .none {
        try visitor.visitSingularEnumField(value: _storage._hederaFunctionality, fieldNumber: 1)
      }
      if let v = _storage._feeData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TransactionFeeSchedule, rhs: Proto_TransactionFeeSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hederaFunctionality != rhs_storage._hederaFunctionality {return false}
        if _storage._feeData != rhs_storage._feeData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodedata"),
    2: .same(proto: "networkdata"),
    3: .same(proto: "servicedata"),
  ]

  fileprivate class _StorageClass {
    var _nodedata: Proto_FeeComponents? = nil
    var _networkdata: Proto_FeeComponents? = nil
    var _servicedata: Proto_FeeComponents? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nodedata = source._nodedata
      _networkdata = source._networkdata
      _servicedata = source._servicedata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._nodedata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._networkdata)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._servicedata)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._nodedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._networkdata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._servicedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FeeData, rhs: Proto_FeeData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodedata != rhs_storage._nodedata {return false}
        if _storage._networkdata != rhs_storage._networkdata {return false}
        if _storage._servicedata != rhs_storage._servicedata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionFeeSchedule"),
    2: .same(proto: "expiryTime"),
  ]

  fileprivate class _StorageClass {
    var _transactionFeeSchedule: [Proto_TransactionFeeSchedule] = []
    var _expiryTime: Proto_TimestampSeconds? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionFeeSchedule = source._transactionFeeSchedule
      _expiryTime = source._expiryTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._transactionFeeSchedule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._expiryTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactionFeeSchedule.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactionFeeSchedule, fieldNumber: 1)
      }
      if let v = _storage._expiryTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FeeSchedule, rhs: Proto_FeeSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionFeeSchedule != rhs_storage._transactionFeeSchedule {return false}
        if _storage._expiryTime != rhs_storage._expiryTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CurrentAndNextFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CurrentAndNextFeeSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentFeeSchedule"),
    2: .same(proto: "nextFeeSchedule"),
  ]

  fileprivate class _StorageClass {
    var _currentFeeSchedule: Proto_FeeSchedule? = nil
    var _nextFeeSchedule: Proto_FeeSchedule? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _currentFeeSchedule = source._currentFeeSchedule
      _nextFeeSchedule = source._nextFeeSchedule
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._currentFeeSchedule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._nextFeeSchedule)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._currentFeeSchedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._nextFeeSchedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CurrentAndNextFeeSchedule, rhs: Proto_CurrentAndNextFeeSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._currentFeeSchedule != rhs_storage._currentFeeSchedule {return false}
        if _storage._nextFeeSchedule != rhs_storage._nextFeeSchedule {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ipAddress"),
    2: .same(proto: "portno"),
    3: .same(proto: "memo"),
    4: .standard(proto: "RSA_PubKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ipAddress)
      case 2: try decoder.decodeSingularInt32Field(value: &self.portno)
      case 3: try decoder.decodeSingularBytesField(value: &self.memo)
      case 4: try decoder.decodeSingularStringField(value: &self.rsaPubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ipAddress, fieldNumber: 1)
    }
    if self.portno != 0 {
      try visitor.visitSingularInt32Field(value: self.portno, fieldNumber: 2)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularBytesField(value: self.memo, fieldNumber: 3)
    }
    if !self.rsaPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.rsaPubKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_NodeAddress, rhs: Proto_NodeAddress) -> Bool {
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.portno != rhs.portno {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.rsaPubKey != rhs.rsaPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddressBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeAddressBook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodeAddress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodeAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeAddress.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_NodeAddressBook, rhs: Proto_NodeAddressBook) -> Bool {
    if lhs.nodeAddress != rhs.nodeAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
