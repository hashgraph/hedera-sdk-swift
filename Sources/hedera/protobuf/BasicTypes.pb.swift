// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: BasicTypes.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The functionality provided by hedera hashgraph 
public enum Proto_HederaFunctionality: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and not parsed (0 is ignored by parser)
  case none // = 0

  /// crypto transfer
  case cryptoTransfer // = 1

  /// crypto update account
  case cryptoUpdate // = 2

  /// crypto delete account
  case cryptoDelete // = 3

  /// crypto add claim to the account
  case cryptoAddClaim // = 4

  /// crypto delete claim to the account
  case cryptoDeleteClaim // = 5

  /// Smart Contract Call
  case contractCall // = 6

  /// Smart Contract Create Contract
  case contractCreate // = 7

  /// Smart Contract update contract
  case contractUpdate // = 8

  /// File Operation create file
  case fileCreate // = 9

  /// File Operation append file
  case fileAppend // = 10

  /// File Operation update file
  case fileUpdate // = 11

  /// File Operation delete file
  case fileDelete // = 12

  /// crypto get account balance
  case cryptoGetAccountBalance // = 13

  /// crypto get account record
  case cryptoGetAccountRecords // = 14

  /// Crypto get info
  case cryptoGetInfo // = 15

  /// Smart Contract Call
  case contractCallLocal // = 16

  /// Smart Contract get info
  case contractGetInfo // = 17

  /// Smart Contract, get the byte code
  case contractGetBytecode // = 18

  /// Smart Contract, get by solidity ID
  case getBySolidityID // = 19

  /// Smart Contract, get by key
  case getByKey // = 20

  /// Crypto get the claim
  case cryptoGetClaim // = 21

  /// Crypto, get the stakers for the node
  case cryptoGetStakers // = 22

  /// File Operations get file contents
  case fileGetContents // = 23

  /// File Operations get the info of the file
  case fileGetInfo // = 24

  /// Crypto get the transaction records
  case transactionGetRecord // = 25

  /// Contract get the transaction records
  case contractGetRecords // = 26

  /// crypto create account
  case cryptoCreate // = 27

  /// system delete file
  case systemDelete // = 28

  /// system undelete file
  case systemUndelete // = 29

  /// delete contract
  case contractDelete // = 30

  /// freeze
  case freeze // = 31

  /// Create Tx Record
  case createTransactionRecord // = 32

  /// Crypto Auto Renew
  case cryptoAccountAutoRenew // = 33

  /// Contract Auto Renew
  case contractAutoRenew // = 34

  ///Get Version
  case getVersion // = 35

  /// Transaction Get Receipt
  case transactionGetReceipt // = 36
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .cryptoTransfer
    case 2: self = .cryptoUpdate
    case 3: self = .cryptoDelete
    case 4: self = .cryptoAddClaim
    case 5: self = .cryptoDeleteClaim
    case 6: self = .contractCall
    case 7: self = .contractCreate
    case 8: self = .contractUpdate
    case 9: self = .fileCreate
    case 10: self = .fileAppend
    case 11: self = .fileUpdate
    case 12: self = .fileDelete
    case 13: self = .cryptoGetAccountBalance
    case 14: self = .cryptoGetAccountRecords
    case 15: self = .cryptoGetInfo
    case 16: self = .contractCallLocal
    case 17: self = .contractGetInfo
    case 18: self = .contractGetBytecode
    case 19: self = .getBySolidityID
    case 20: self = .getByKey
    case 21: self = .cryptoGetClaim
    case 22: self = .cryptoGetStakers
    case 23: self = .fileGetContents
    case 24: self = .fileGetInfo
    case 25: self = .transactionGetRecord
    case 26: self = .contractGetRecords
    case 27: self = .cryptoCreate
    case 28: self = .systemDelete
    case 29: self = .systemUndelete
    case 30: self = .contractDelete
    case 31: self = .freeze
    case 32: self = .createTransactionRecord
    case 33: self = .cryptoAccountAutoRenew
    case 34: self = .contractAutoRenew
    case 35: self = .getVersion
    case 36: self = .transactionGetReceipt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .cryptoTransfer: return 1
    case .cryptoUpdate: return 2
    case .cryptoDelete: return 3
    case .cryptoAddClaim: return 4
    case .cryptoDeleteClaim: return 5
    case .contractCall: return 6
    case .contractCreate: return 7
    case .contractUpdate: return 8
    case .fileCreate: return 9
    case .fileAppend: return 10
    case .fileUpdate: return 11
    case .fileDelete: return 12
    case .cryptoGetAccountBalance: return 13
    case .cryptoGetAccountRecords: return 14
    case .cryptoGetInfo: return 15
    case .contractCallLocal: return 16
    case .contractGetInfo: return 17
    case .contractGetBytecode: return 18
    case .getBySolidityID: return 19
    case .getByKey: return 20
    case .cryptoGetClaim: return 21
    case .cryptoGetStakers: return 22
    case .fileGetContents: return 23
    case .fileGetInfo: return 24
    case .transactionGetRecord: return 25
    case .contractGetRecords: return 26
    case .cryptoCreate: return 27
    case .systemDelete: return 28
    case .systemUndelete: return 29
    case .contractDelete: return 30
    case .freeze: return 31
    case .createTransactionRecord: return 32
    case .cryptoAccountAutoRenew: return 33
    case .contractAutoRenew: return 34
    case .getVersion: return 35
    case .transactionGetReceipt: return 36
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_HederaFunctionality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_HederaFunctionality] = [
    .none,
    .cryptoTransfer,
    .cryptoUpdate,
    .cryptoDelete,
    .cryptoAddClaim,
    .cryptoDeleteClaim,
    .contractCall,
    .contractCreate,
    .contractUpdate,
    .fileCreate,
    .fileAppend,
    .fileUpdate,
    .fileDelete,
    .cryptoGetAccountBalance,
    .cryptoGetAccountRecords,
    .cryptoGetInfo,
    .contractCallLocal,
    .contractGetInfo,
    .contractGetBytecode,
    .getBySolidityID,
    .getByKey,
    .cryptoGetClaim,
    .cryptoGetStakers,
    .fileGetContents,
    .fileGetInfo,
    .transactionGetRecord,
    .contractGetRecords,
    .cryptoCreate,
    .systemDelete,
    .systemUndelete,
    .contractDelete,
    .freeze,
    .createTransactionRecord,
    .cryptoAccountAutoRenew,
    .contractAutoRenew,
    .getVersion,
    .transactionGetReceipt,
  ]
}

#endif  // swift(>=4.2)

/// Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
///
///Everything is partitioned into realms so that each Solidity smart contract can  access everything in just a single realm, locking all those entities while it's  running, but other smart contracts could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized somewhat, even though the  language itself assumes everything is serial. 
public struct Proto_ShardID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the shard number (nonnegative)
  public var shardNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. 
public struct Proto_RealmID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///The realm number (nonnegative)
  public var realmNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The ID for an a cryptocurrency account  
public struct Proto_AccountID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///The realm number (nonnegative)
  public var realmNum: Int64 = 0

  ///A nonnegative account number unique within its realm
  public var accountNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The ID for a file  
public struct Proto_FileID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///The realm number (nonnegative)
  public var realmNum: Int64 = 0

  ///A nonnegative File number unique within its realm
  public var fileNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The ID for a smart contract instance  
public struct Proto_ContractID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///The realm number (nonnegative)
  public var realmNum: Int64 = 0

  ///A nonnegative number unique within its realm
  public var contractNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. 
public struct Proto_TransactionID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
  public var transactionValidStart: Proto_Timestamp {
    get {return _storage._transactionValidStart ?? Proto_Timestamp()}
    set {_uniqueStorage()._transactionValidStart = newValue}
  }
  /// Returns true if `transactionValidStart` has been explicitly set.
  public var hasTransactionValidStart: Bool {return _storage._transactionValidStart != nil}
  /// Clears the value of `transactionValidStart`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionValidStart() {_uniqueStorage()._transactionValidStart = nil}

  ///The Account ID that paid for this transaction
  public var accountID: Proto_AccountID {
    get {return _storage._accountID ?? Proto_AccountID()}
    set {_uniqueStorage()._accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return _storage._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.
///
/// A Key can be a smart contract ID, which means that smart contract is to authorize operations as if it had signed with a key that it owned. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key.
///
/// A key can be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements.
///
/// A Key can be a list of keys. Their use is dependent on context. For example, a Hedera file is created with a list of keys, where all of them must sign a transaction to create or modify the file, but only one of them is needed to sign a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold key, and sometimes acts as an M-of-M threshold key.
///
/// A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive keys (e.g., ed25519) has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive keys (e.g., ed25519) has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels: Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
///
/// Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
public struct Proto_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: OneOf_Key? {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// smart contract instance that is authorized as if it had signed with a key
  public var contractID: Proto_ContractID {
    get {
      if case .contractID(let v)? = _storage._key {return v}
      return Proto_ContractID()
    }
    set {_uniqueStorage()._key = .contractID(newValue)}
  }

  /// ed25519 public key bytes
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .ed25519(newValue)}
  }

  ///RSA-3072 public key bytes
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .rsa3072(newValue)}
  }

  ///ECDSA with the p-384 curve public key bytes
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = _storage._key {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._key = .ecdsa384(newValue)}
  }

  /// a threshold N followed by a list of M keys, any N of which are required to form a valid signature
  public var thresholdKey: Proto_ThresholdKey {
    get {
      if case .thresholdKey(let v)? = _storage._key {return v}
      return Proto_ThresholdKey()
    }
    set {_uniqueStorage()._key = .thresholdKey(newValue)}
  }

  /// A list of Keys of the Key type.
  public var keyList: Proto_KeyList {
    get {
      if case .keyList(let v)? = _storage._key {return v}
      return Proto_KeyList()
    }
    set {_uniqueStorage()._key = .keyList(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable {
    /// smart contract instance that is authorized as if it had signed with a key
    case contractID(Proto_ContractID)
    /// ed25519 public key bytes
    case ed25519(Data)
    ///RSA-3072 public key bytes
    case rsa3072(Data)
    ///ECDSA with the p-384 curve public key bytes
    case ecdsa384(Data)
    /// a threshold N followed by a list of M keys, any N of which are required to form a valid signature
    case thresholdKey(Proto_ThresholdKey)
    /// A list of Keys of the Key type.
    case keyList(Proto_KeyList)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_Key.OneOf_Key, rhs: Proto_Key.OneOf_Key) -> Bool {
      switch (lhs, rhs) {
      case (.contractID(let l), .contractID(let r)): return l == r
      case (.ed25519(let l), .ed25519(let r)): return l == r
      case (.rsa3072(let l), .rsa3072(let r)): return l == r
      case (.ecdsa384(let l), .ecdsa384(let r)): return l == r
      case (.thresholdKey(let l), .thresholdKey(let r)): return l == r
      case (.keyList(let l), .keyList(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. 
public struct Proto_ThresholdKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A valid signature set must have at least this many signatures
  public var threshold: UInt32 {
    get {return _storage._threshold}
    set {_uniqueStorage()._threshold = newValue}
  }

  /// List of all the keys that can sign
  public var keys: Proto_KeyList {
    get {return _storage._keys ?? Proto_KeyList()}
    set {_uniqueStorage()._keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  public var hasKeys: Bool {return _storage._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  public mutating func clearKeys() {_uniqueStorage()._keys = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of keys 
public struct Proto_KeyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list of keys
  public var keys: [Proto_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.
/// The definition of Key uses mutual recursion, so it allows nesting that is arbitrarily deep. But the current API only accepts Key messages up to 3 levels deep, such as a list of threshold keys, each of which is a list of primitive keys. Therefore, the matching Signature will have the same limitation. This restriction may be relaxed in future versions of the API, to allow deeper nesting.
/// This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
public struct Proto_Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signature: OneOf_Signature? {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  /// smart contract virtual signature (always length zero)
  public var contract: Data {
    get {
      if case .contract(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .contract(newValue)}
  }

  /// ed25519 signature bytes
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .ed25519(newValue)}
  }

  ///RSA-3072 signature bytes
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .rsa3072(newValue)}
  }

  ///ECDSA p-384 signature bytes
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .ecdsa384(newValue)}
  }

  /// A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.
  public var thresholdSignature: Proto_ThresholdSignature {
    get {
      if case .thresholdSignature(let v)? = _storage._signature {return v}
      return Proto_ThresholdSignature()
    }
    set {_uniqueStorage()._signature = .thresholdSignature(newValue)}
  }

  /// A list of M signatures, each corresponding to a Key in a KeyList of the same length.
  public var signatureList: Proto_SignatureList {
    get {
      if case .signatureList(let v)? = _storage._signature {return v}
      return Proto_SignatureList()
    }
    set {_uniqueStorage()._signature = .signatureList(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signature: Equatable {
    /// smart contract virtual signature (always length zero)
    case contract(Data)
    /// ed25519 signature bytes
    case ed25519(Data)
    ///RSA-3072 signature bytes
    case rsa3072(Data)
    ///ECDSA p-384 signature bytes
    case ecdsa384(Data)
    /// A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.
    case thresholdSignature(Proto_ThresholdSignature)
    /// A list of M signatures, each corresponding to a Key in a KeyList of the same length.
    case signatureList(Proto_SignatureList)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_Signature.OneOf_Signature, rhs: Proto_Signature.OneOf_Signature) -> Bool {
      switch (lhs, rhs) {
      case (.contract(let l), .contract(let r)): return l == r
      case (.ed25519(let l), .ed25519(let r)): return l == r
      case (.rsa3072(let l), .rsa3072(let r)): return l == r
      case (.ecdsa384(let l), .ecdsa384(let r)): return l == r
      case (.thresholdSignature(let l), .thresholdSignature(let r)): return l == r
      case (.signatureList(let l), .signatureList(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. 
/// This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
public struct Proto_ThresholdSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null
  public var sigs: Proto_SignatureList {
    get {return _storage._sigs ?? Proto_SignatureList()}
    set {_uniqueStorage()._sigs = newValue}
  }
  /// Returns true if `sigs` has been explicitly set.
  public var hasSigs: Bool {return _storage._sigs != nil}
  /// Clears the value of `sigs`. Subsequent reads from it will return its default value.
  public mutating func clearSigs() {_uniqueStorage()._sigs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The signatures corresponding to a KeyList of the same length.
/// This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
public struct Proto_SignatureList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// each signature corresponds to a Key in the KeyList
  public var sigs: [Proto_Signature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The client may use any number of bytes from 0 to the whole length of the public key for pubKeyPrefix. 
/// If 0 bytes is used, then it is assumed that only one public key is used to sign.
public struct Proto_SignaturePair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// First few bytes of the public key
  public var pubKeyPrefix: Data = SwiftProtobuf.Internal.emptyData

  public var signature: Proto_SignaturePair.OneOf_Signature? = nil

  /// smart contract virtual signature (always length zero)
  public var contract: Data {
    get {
      if case .contract(let v)? = signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {signature = .contract(newValue)}
  }

  /// ed25519 signature
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {signature = .ed25519(newValue)}
  }

  ///RSA-3072 signature
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {signature = .rsa3072(newValue)}
  }

  ///ECDSA p-384 signature
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {signature = .ecdsa384(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signature: Equatable {
    /// smart contract virtual signature (always length zero)
    case contract(Data)
    /// ed25519 signature
    case ed25519(Data)
    ///RSA-3072 signature
    case rsa3072(Data)
    ///ECDSA p-384 signature
    case ecdsa384(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_SignaturePair.OneOf_Signature, rhs: Proto_SignaturePair.OneOf_Signature) -> Bool {
      switch (lhs, rhs) {
      case (.contract(let l), .contract(let r)): return l == r
      case (.ed25519(let l), .ed25519(let r)): return l == r
      case (.rsa3072(let l), .rsa3072(let r)): return l == r
      case (.ecdsa384(let l), .ecdsa384(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A set of signatures corresponding to every unique public key used to sign a given transaction. 
/// If one public key matches more than one prefixes on the signature map, the transaction containing the map will fail immediately with the response code KEY_PREFIX_MISMATCH.  
public struct Proto_SignatureMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Each signature pair corresponds to a unique Key required to sign the transaction.
  public var sigPair: [Proto_SignaturePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_FeeComponents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum fees that needs to be paid
  public var min: Int64 = 0

  /// The maximum fees that can be submitted
  public var max: Int64 = 0

  /// A constant determined by the business to calculate the fees
  public var constant: Int64 = 0

  /// Bytes per transaction
  public var bpt: Int64 = 0

  /// Verifications per transaction
  public var vpt: Int64 = 0

  /// Ram byte seconds
  public var rbh: Int64 = 0

  /// Storage byte seconds
  public var sbh: Int64 = 0

  /// Gas for the contract execution
  public var gas: Int64 = 0

  /// Transaction value (crypto transfers amount, tv is in tiny bars divided by 1000, rounded down)
  public var tv: Int64 = 0

  /// Bytes per response
  public var bpr: Int64 = 0

  /// Storage bytes per response
  public var sbpr: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The fees for a specific transaction or query based on the fee data. 
public struct Proto_TransactionFeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specific Transaction or Query
  public var hederaFunctionality: Proto_HederaFunctionality {
    get {return _storage._hederaFunctionality}
    set {_uniqueStorage()._hederaFunctionality = newValue}
  }

  /// The fee information about the query/data
  public var feeData: Proto_FeeData {
    get {return _storage._feeData ?? Proto_FeeData()}
    set {_uniqueStorage()._feeData = newValue}
  }
  /// Returns true if `feeData` has been explicitly set.
  public var hasFeeData: Bool {return _storage._feeData != nil}
  /// Clears the value of `feeData`. Subsequent reads from it will return its default value.
  public mutating func clearFeeData() {_uniqueStorage()._feeData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The total fees charged for a transaction. It contains three parts namely node data, network data and service data 
public struct Proto_FeeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fee charged by Node for this functionality
  public var nodedata: Proto_FeeComponents {
    get {return _storage._nodedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._nodedata = newValue}
  }
  /// Returns true if `nodedata` has been explicitly set.
  public var hasNodedata: Bool {return _storage._nodedata != nil}
  /// Clears the value of `nodedata`. Subsequent reads from it will return its default value.
  public mutating func clearNodedata() {_uniqueStorage()._nodedata = nil}

  /// Fee charged for network operations by Hedera
  public var networkdata: Proto_FeeComponents {
    get {return _storage._networkdata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._networkdata = newValue}
  }
  /// Returns true if `networkdata` has been explicitly set.
  public var hasNetworkdata: Bool {return _storage._networkdata != nil}
  /// Clears the value of `networkdata`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkdata() {_uniqueStorage()._networkdata = nil}

  /// Fee charged for providing service by Hedera
  public var servicedata: Proto_FeeComponents {
    get {return _storage._servicedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._servicedata = newValue}
  }
  /// Returns true if `servicedata` has been explicitly set.
  public var hasServicedata: Bool {return _storage._servicedata != nil}
  /// Clears the value of `servicedata`. Subsequent reads from it will return its default value.
  public mutating func clearServicedata() {_uniqueStorage()._servicedata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The fee schedule for a specific hedera functionality and the time period this fee schedule will expire  
public struct Proto_FeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains multiple functionality specific fee schedule.
  public var transactionFeeSchedule: [Proto_TransactionFeeSchedule] {
    get {return _storage._transactionFeeSchedule}
    set {_uniqueStorage()._transactionFeeSchedule = newValue}
  }

  /// FeeSchedule expiry time
  public var expiryTime: Proto_TimestampSeconds {
    get {return _storage._expiryTime ?? Proto_TimestampSeconds()}
    set {_uniqueStorage()._expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  public var hasExpiryTime: Bool {return _storage._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpiryTime() {_uniqueStorage()._expiryTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This contains two Fee Schedules with expiry timestamp. 
public struct Proto_CurrentAndNextFeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains current Fee Schedule
  public var currentFeeSchedule: Proto_FeeSchedule {
    get {return _storage._currentFeeSchedule ?? Proto_FeeSchedule()}
    set {_uniqueStorage()._currentFeeSchedule = newValue}
  }
  /// Returns true if `currentFeeSchedule` has been explicitly set.
  public var hasCurrentFeeSchedule: Bool {return _storage._currentFeeSchedule != nil}
  /// Clears the value of `currentFeeSchedule`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentFeeSchedule() {_uniqueStorage()._currentFeeSchedule = nil}

  /// Contains next Fee Schedule
  public var nextFeeSchedule: Proto_FeeSchedule {
    get {return _storage._nextFeeSchedule ?? Proto_FeeSchedule()}
    set {_uniqueStorage()._nextFeeSchedule = newValue}
  }
  /// Returns true if `nextFeeSchedule` has been explicitly set.
  public var hasNextFeeSchedule: Bool {return _storage._nextFeeSchedule != nil}
  /// Clears the value of `nextFeeSchedule`. Subsequent reads from it will return its default value.
  public mutating func clearNextFeeSchedule() {_uniqueStorage()._nextFeeSchedule = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The information about a node 
public struct Proto_NodeAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ip address of the Node with separator & octets
  public var ipAddress: Data = SwiftProtobuf.Internal.emptyData

  /// The port number of the grpc server for the node
  public var portno: Int32 = 0

  /// The memo field of the node
  public var memo: Data = SwiftProtobuf.Internal.emptyData

  /// The RSA public key of the node.
  public var rsaPubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Gives the node addresses in the address book 
public struct Proto_NodeAddressBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains multiple Node Address for the network
  public var nodeAddress: [Proto_NodeAddress] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_HederaFunctionality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CryptoTransfer"),
    2: .same(proto: "CryptoUpdate"),
    3: .same(proto: "CryptoDelete"),
    4: .same(proto: "CryptoAddClaim"),
    5: .same(proto: "CryptoDeleteClaim"),
    6: .same(proto: "ContractCall"),
    7: .same(proto: "ContractCreate"),
    8: .same(proto: "ContractUpdate"),
    9: .same(proto: "FileCreate"),
    10: .same(proto: "FileAppend"),
    11: .same(proto: "FileUpdate"),
    12: .same(proto: "FileDelete"),
    13: .same(proto: "CryptoGetAccountBalance"),
    14: .same(proto: "CryptoGetAccountRecords"),
    15: .same(proto: "CryptoGetInfo"),
    16: .same(proto: "ContractCallLocal"),
    17: .same(proto: "ContractGetInfo"),
    18: .same(proto: "ContractGetBytecode"),
    19: .same(proto: "GetBySolidityID"),
    20: .same(proto: "GetByKey"),
    21: .same(proto: "CryptoGetClaim"),
    22: .same(proto: "CryptoGetStakers"),
    23: .same(proto: "FileGetContents"),
    24: .same(proto: "FileGetInfo"),
    25: .same(proto: "TransactionGetRecord"),
    26: .same(proto: "ContractGetRecords"),
    27: .same(proto: "CryptoCreate"),
    28: .same(proto: "SystemDelete"),
    29: .same(proto: "SystemUndelete"),
    30: .same(proto: "ContractDelete"),
    31: .same(proto: "Freeze"),
    32: .same(proto: "CreateTransactionRecord"),
    33: .same(proto: "CryptoAccountAutoRenew"),
    34: .same(proto: "ContractAutoRenew"),
    35: .same(proto: "getVersion"),
    36: .same(proto: "TransactionGetReceipt"),
  ]
}

extension Proto_ShardID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShardID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ShardID, rhs: Proto_ShardID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RealmID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RealmID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_RealmID, rhs: Proto_RealmID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "accountNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.accountNum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.accountNum != 0 {
      try visitor.visitSingularInt64Field(value: self.accountNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AccountID, rhs: Proto_AccountID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.accountNum != rhs.accountNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FileID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "fileNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.fileNum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.fileNum != 0 {
      try visitor.visitSingularInt64Field(value: self.fileNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FileID, rhs: Proto_FileID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.fileNum != rhs.fileNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContractID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContractID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "contractNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.shardNum)
      case 2: try decoder.decodeSingularInt64Field(value: &self.realmNum)
      case 3: try decoder.decodeSingularInt64Field(value: &self.contractNum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.contractNum != 0 {
      try visitor.visitSingularInt64Field(value: self.contractNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ContractID, rhs: Proto_ContractID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.contractNum != rhs.contractNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionValidStart"),
    2: .same(proto: "accountID"),
  ]

  fileprivate class _StorageClass {
    var _transactionValidStart: Proto_Timestamp? = nil
    var _accountID: Proto_AccountID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionValidStart = source._transactionValidStart
      _accountID = source._accountID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transactionValidStart)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._accountID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transactionValidStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionID, rhs: Proto_TransactionID) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionValidStart != rhs_storage._transactionValidStart {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdKey"),
    6: .same(proto: "keyList"),
  ]

  fileprivate class _StorageClass {
    var _key: Proto_Key.OneOf_Key?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Proto_ContractID?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .contractID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .contractID(v)}
        case 2:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .ed25519(v)}
        case 3:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .rsa3072(v)}
        case 4:
          if _storage._key != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._key = .ecdsa384(v)}
        case 5:
          var v: Proto_ThresholdKey?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .thresholdKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .thresholdKey(v)}
        case 6:
          var v: Proto_KeyList?
          if let current = _storage._key {
            try decoder.handleConflictingOneOf()
            if case .keyList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._key = .keyList(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._key {
      case .contractID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .ed25519(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      case .rsa3072(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      case .ecdsa384(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      case .thresholdKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .keyList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Key, rhs: Proto_Key) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "keys"),
  ]

  fileprivate class _StorageClass {
    var _threshold: UInt32 = 0
    var _keys: Proto_KeyList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _threshold = source._threshold
      _keys = source._keys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._threshold)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._keys)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._threshold != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._threshold, fieldNumber: 1)
      }
      if let v = _storage._keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ThresholdKey, rhs: Proto_ThresholdKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._threshold != rhs_storage._threshold {return false}
        if _storage._keys != rhs_storage._keys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_KeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_KeyList, rhs: Proto_KeyList) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contract"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdSignature"),
    6: .same(proto: "signatureList"),
  ]

  fileprivate class _StorageClass {
    var _signature: Proto_Signature.OneOf_Signature?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .contract(v)}
        case 2:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .ed25519(v)}
        case 3:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .rsa3072(v)}
        case 4:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .ecdsa384(v)}
        case 5:
          var v: Proto_ThresholdSignature?
          if let current = _storage._signature {
            try decoder.handleConflictingOneOf()
            if case .thresholdSignature(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._signature = .thresholdSignature(v)}
        case 6:
          var v: Proto_SignatureList?
          if let current = _storage._signature {
            try decoder.handleConflictingOneOf()
            if case .signatureList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._signature = .signatureList(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._signature {
      case .contract(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      case .ed25519(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      case .rsa3072(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      case .ecdsa384(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      case .thresholdSignature(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .signatureList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Signature, rhs: Proto_Signature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  fileprivate class _StorageClass {
    var _sigs: Proto_SignatureList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sigs = source._sigs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sigs)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sigs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ThresholdSignature, rhs: Proto_ThresholdSignature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sigs != rhs_storage._sigs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignatureList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.sigs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignatureList, rhs: Proto_SignatureList) -> Bool {
    if lhs.sigs != rhs.sigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignaturePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignaturePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubKeyPrefix"),
    2: .same(proto: "contract"),
    3: .same(proto: "ed25519"),
    4: .standard(proto: "RSA_3072"),
    5: .standard(proto: "ECDSA_384"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.pubKeyPrefix)
      case 2:
        if self.signature != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.signature = .contract(v)}
      case 3:
        if self.signature != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.signature = .ed25519(v)}
      case 4:
        if self.signature != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.signature = .rsa3072(v)}
      case 5:
        if self.signature != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.signature = .ecdsa384(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKeyPrefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKeyPrefix, fieldNumber: 1)
    }
    switch self.signature {
    case .contract(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    case .ed25519(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case .rsa3072(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    case .ecdsa384(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignaturePair, rhs: Proto_SignaturePair) -> Bool {
    if lhs.pubKeyPrefix != rhs.pubKeyPrefix {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignatureMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sigPair"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sigPair)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigPair.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigPair, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignatureMap, rhs: Proto_SignatureMap) -> Bool {
    if lhs.sigPair != rhs.sigPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeComponents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeComponents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .same(proto: "constant"),
    4: .same(proto: "bpt"),
    5: .same(proto: "vpt"),
    6: .same(proto: "rbh"),
    7: .same(proto: "sbh"),
    8: .same(proto: "gas"),
    9: .same(proto: "tv"),
    10: .same(proto: "bpr"),
    11: .same(proto: "sbpr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.min)
      case 2: try decoder.decodeSingularInt64Field(value: &self.max)
      case 3: try decoder.decodeSingularInt64Field(value: &self.constant)
      case 4: try decoder.decodeSingularInt64Field(value: &self.bpt)
      case 5: try decoder.decodeSingularInt64Field(value: &self.vpt)
      case 6: try decoder.decodeSingularInt64Field(value: &self.rbh)
      case 7: try decoder.decodeSingularInt64Field(value: &self.sbh)
      case 8: try decoder.decodeSingularInt64Field(value: &self.gas)
      case 9: try decoder.decodeSingularInt64Field(value: &self.tv)
      case 10: try decoder.decodeSingularInt64Field(value: &self.bpr)
      case 11: try decoder.decodeSingularInt64Field(value: &self.sbpr)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularInt64Field(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularInt64Field(value: self.max, fieldNumber: 2)
    }
    if self.constant != 0 {
      try visitor.visitSingularInt64Field(value: self.constant, fieldNumber: 3)
    }
    if self.bpt != 0 {
      try visitor.visitSingularInt64Field(value: self.bpt, fieldNumber: 4)
    }
    if self.vpt != 0 {
      try visitor.visitSingularInt64Field(value: self.vpt, fieldNumber: 5)
    }
    if self.rbh != 0 {
      try visitor.visitSingularInt64Field(value: self.rbh, fieldNumber: 6)
    }
    if self.sbh != 0 {
      try visitor.visitSingularInt64Field(value: self.sbh, fieldNumber: 7)
    }
    if self.gas != 0 {
      try visitor.visitSingularInt64Field(value: self.gas, fieldNumber: 8)
    }
    if self.tv != 0 {
      try visitor.visitSingularInt64Field(value: self.tv, fieldNumber: 9)
    }
    if self.bpr != 0 {
      try visitor.visitSingularInt64Field(value: self.bpr, fieldNumber: 10)
    }
    if self.sbpr != 0 {
      try visitor.visitSingularInt64Field(value: self.sbpr, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeComponents, rhs: Proto_FeeComponents) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.constant != rhs.constant {return false}
    if lhs.bpt != rhs.bpt {return false}
    if lhs.vpt != rhs.vpt {return false}
    if lhs.rbh != rhs.rbh {return false}
    if lhs.sbh != rhs.sbh {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.tv != rhs.tv {return false}
    if lhs.bpr != rhs.bpr {return false}
    if lhs.sbpr != rhs.sbpr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionFeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hederaFunctionality"),
    2: .same(proto: "feeData"),
  ]

  fileprivate class _StorageClass {
    var _hederaFunctionality: Proto_HederaFunctionality = .none
    var _feeData: Proto_FeeData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hederaFunctionality = source._hederaFunctionality
      _feeData = source._feeData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._hederaFunctionality)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._feeData)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._hederaFunctionality != .none {
        try visitor.visitSingularEnumField(value: _storage._hederaFunctionality, fieldNumber: 1)
      }
      if let v = _storage._feeData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionFeeSchedule, rhs: Proto_TransactionFeeSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hederaFunctionality != rhs_storage._hederaFunctionality {return false}
        if _storage._feeData != rhs_storage._feeData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodedata"),
    2: .same(proto: "networkdata"),
    3: .same(proto: "servicedata"),
  ]

  fileprivate class _StorageClass {
    var _nodedata: Proto_FeeComponents? = nil
    var _networkdata: Proto_FeeComponents? = nil
    var _servicedata: Proto_FeeComponents? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nodedata = source._nodedata
      _networkdata = source._networkdata
      _servicedata = source._servicedata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._nodedata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._networkdata)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._servicedata)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._nodedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._networkdata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._servicedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeData, rhs: Proto_FeeData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodedata != rhs_storage._nodedata {return false}
        if _storage._networkdata != rhs_storage._networkdata {return false}
        if _storage._servicedata != rhs_storage._servicedata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionFeeSchedule"),
    2: .same(proto: "expiryTime"),
  ]

  fileprivate class _StorageClass {
    var _transactionFeeSchedule: [Proto_TransactionFeeSchedule] = []
    var _expiryTime: Proto_TimestampSeconds? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionFeeSchedule = source._transactionFeeSchedule
      _expiryTime = source._expiryTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._transactionFeeSchedule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._expiryTime)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactionFeeSchedule.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactionFeeSchedule, fieldNumber: 1)
      }
      if let v = _storage._expiryTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeSchedule, rhs: Proto_FeeSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionFeeSchedule != rhs_storage._transactionFeeSchedule {return false}
        if _storage._expiryTime != rhs_storage._expiryTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CurrentAndNextFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrentAndNextFeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentFeeSchedule"),
    2: .same(proto: "nextFeeSchedule"),
  ]

  fileprivate class _StorageClass {
    var _currentFeeSchedule: Proto_FeeSchedule? = nil
    var _nextFeeSchedule: Proto_FeeSchedule? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _currentFeeSchedule = source._currentFeeSchedule
      _nextFeeSchedule = source._nextFeeSchedule
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._currentFeeSchedule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._nextFeeSchedule)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._currentFeeSchedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._nextFeeSchedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CurrentAndNextFeeSchedule, rhs: Proto_CurrentAndNextFeeSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._currentFeeSchedule != rhs_storage._currentFeeSchedule {return false}
        if _storage._nextFeeSchedule != rhs_storage._nextFeeSchedule {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ipAddress"),
    2: .same(proto: "portno"),
    3: .same(proto: "memo"),
    4: .standard(proto: "RSA_PubKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ipAddress)
      case 2: try decoder.decodeSingularInt32Field(value: &self.portno)
      case 3: try decoder.decodeSingularBytesField(value: &self.memo)
      case 4: try decoder.decodeSingularStringField(value: &self.rsaPubKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ipAddress, fieldNumber: 1)
    }
    if self.portno != 0 {
      try visitor.visitSingularInt32Field(value: self.portno, fieldNumber: 2)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularBytesField(value: self.memo, fieldNumber: 3)
    }
    if !self.rsaPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.rsaPubKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeAddress, rhs: Proto_NodeAddress) -> Bool {
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.portno != rhs.portno {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.rsaPubKey != rhs.rsaPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddressBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeAddressBook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodeAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodeAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeAddress.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeAddressBook, rhs: Proto_NodeAddressBook) -> Bool {
    if lhs.nodeAddress != rhs.nodeAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
