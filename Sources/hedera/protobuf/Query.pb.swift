// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Query.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A single query, which is sent from the client to the node. This includes all possible queries. Each Query should not have more than 50 levels. 
public struct Proto_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: OneOf_Query? {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  /// Get all entities associated with a given key
  public var getByKey: Proto_GetByKeyQuery {
    get {
      if case .getByKey(let v)? = _storage._query {return v}
      return Proto_GetByKeyQuery()
    }
    set {_uniqueStorage()._query = .getByKey(newValue)}
  }

  /// Get the IDs in the format used in transactions, given the format used in Solidity
  public var getBySolidityID: Proto_GetBySolidityIDQuery {
    get {
      if case .getBySolidityID(let v)? = _storage._query {return v}
      return Proto_GetBySolidityIDQuery()
    }
    set {_uniqueStorage()._query = .getBySolidityID(newValue)}
  }

  /// Call a function of a smart contract instance
  public var contractCallLocal: Proto_ContractCallLocalQuery {
    get {
      if case .contractCallLocal(let v)? = _storage._query {return v}
      return Proto_ContractCallLocalQuery()
    }
    set {_uniqueStorage()._query = .contractCallLocal(newValue)}
  }

  /// Get information about a smart contract instance
  public var contractGetInfo: Proto_ContractGetInfoQuery {
    get {
      if case .contractGetInfo(let v)? = _storage._query {return v}
      return Proto_ContractGetInfoQuery()
    }
    set {_uniqueStorage()._query = .contractGetInfo(newValue)}
  }

  /// Get bytecode used by a smart contract instance
  public var contractGetBytecode: Proto_ContractGetBytecodeQuery {
    get {
      if case .contractGetBytecode(let v)? = _storage._query {return v}
      return Proto_ContractGetBytecodeQuery()
    }
    set {_uniqueStorage()._query = .contractGetBytecode(newValue)}
  }

  /// Get Records of the contract instance
  public var contractGetRecords: Proto_ContractGetRecordsQuery {
    get {
      if case .contractGetRecords(let v)? = _storage._query {return v}
      return Proto_ContractGetRecordsQuery()
    }
    set {_uniqueStorage()._query = .contractGetRecords(newValue)}
  }

  /// Get the current balance in a cryptocurrency account
  public var cryptogetAccountBalance: Proto_CryptoGetAccountBalanceQuery {
    get {
      if case .cryptogetAccountBalance(let v)? = _storage._query {return v}
      return Proto_CryptoGetAccountBalanceQuery()
    }
    set {_uniqueStorage()._query = .cryptogetAccountBalance(newValue)}
  }

  /// Get all the records that currently exist for transactions involving an account
  public var cryptoGetAccountRecords: Proto_CryptoGetAccountRecordsQuery {
    get {
      if case .cryptoGetAccountRecords(let v)? = _storage._query {return v}
      return Proto_CryptoGetAccountRecordsQuery()
    }
    set {_uniqueStorage()._query = .cryptoGetAccountRecords(newValue)}
  }

  /// Get all information about an account
  public var cryptoGetInfo: Proto_CryptoGetInfoQuery {
    get {
      if case .cryptoGetInfo(let v)? = _storage._query {return v}
      return Proto_CryptoGetInfoQuery()
    }
    set {_uniqueStorage()._query = .cryptoGetInfo(newValue)}
  }

  /// Get a single claim from a single account (or null if it doesn't exist)
  public var cryptoGetClaim: Proto_CryptoGetClaimQuery {
    get {
      if case .cryptoGetClaim(let v)? = _storage._query {return v}
      return Proto_CryptoGetClaimQuery()
    }
    set {_uniqueStorage()._query = .cryptoGetClaim(newValue)}
  }

  /// Get all the accounts that proxy stake to a given account, and how much they proxy stake (not yet implemented in the current API)
  public var cryptoGetProxyStakers: Proto_CryptoGetStakersQuery {
    get {
      if case .cryptoGetProxyStakers(let v)? = _storage._query {return v}
      return Proto_CryptoGetStakersQuery()
    }
    set {_uniqueStorage()._query = .cryptoGetProxyStakers(newValue)}
  }

  /// Get the contents of a file (the bytes stored in it)
  public var fileGetContents: Proto_FileGetContentsQuery {
    get {
      if case .fileGetContents(let v)? = _storage._query {return v}
      return Proto_FileGetContentsQuery()
    }
    set {_uniqueStorage()._query = .fileGetContents(newValue)}
  }

  /// Get information about a file, such as its expiration date
  public var fileGetInfo: Proto_FileGetInfoQuery {
    get {
      if case .fileGetInfo(let v)? = _storage._query {return v}
      return Proto_FileGetInfoQuery()
    }
    set {_uniqueStorage()._query = .fileGetInfo(newValue)}
  }

  /// Get a receipt for a transaction (lasts 180 seconds)
  public var transactionGetReceipt: Proto_TransactionGetReceiptQuery {
    get {
      if case .transactionGetReceipt(let v)? = _storage._query {return v}
      return Proto_TransactionGetReceiptQuery()
    }
    set {_uniqueStorage()._query = .transactionGetReceipt(newValue)}
  }

  /// Get a record for a transaction (lasts 1 hour)
  public var transactionGetRecord: Proto_TransactionGetRecordQuery {
    get {
      if case .transactionGetRecord(let v)? = _storage._query {return v}
      return Proto_TransactionGetRecordQuery()
    }
    set {_uniqueStorage()._query = .transactionGetRecord(newValue)}
  }

  /// Get a record for a transaction (lasts 180 seconds)
  public var transactionGetFastRecord: Proto_TransactionGetFastRecordQuery {
    get {
      if case .transactionGetFastRecord(let v)? = _storage._query {return v}
      return Proto_TransactionGetFastRecordQuery()
    }
    set {_uniqueStorage()._query = .transactionGetFastRecord(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Query: Equatable {
    /// Get all entities associated with a given key
    case getByKey(Proto_GetByKeyQuery)
    /// Get the IDs in the format used in transactions, given the format used in Solidity
    case getBySolidityID(Proto_GetBySolidityIDQuery)
    /// Call a function of a smart contract instance
    case contractCallLocal(Proto_ContractCallLocalQuery)
    /// Get information about a smart contract instance
    case contractGetInfo(Proto_ContractGetInfoQuery)
    /// Get bytecode used by a smart contract instance
    case contractGetBytecode(Proto_ContractGetBytecodeQuery)
    /// Get Records of the contract instance
    case contractGetRecords(Proto_ContractGetRecordsQuery)
    /// Get the current balance in a cryptocurrency account
    case cryptogetAccountBalance(Proto_CryptoGetAccountBalanceQuery)
    /// Get all the records that currently exist for transactions involving an account
    case cryptoGetAccountRecords(Proto_CryptoGetAccountRecordsQuery)
    /// Get all information about an account
    case cryptoGetInfo(Proto_CryptoGetInfoQuery)
    /// Get a single claim from a single account (or null if it doesn't exist)
    case cryptoGetClaim(Proto_CryptoGetClaimQuery)
    /// Get all the accounts that proxy stake to a given account, and how much they proxy stake (not yet implemented in the current API)
    case cryptoGetProxyStakers(Proto_CryptoGetStakersQuery)
    /// Get the contents of a file (the bytes stored in it)
    case fileGetContents(Proto_FileGetContentsQuery)
    /// Get information about a file, such as its expiration date
    case fileGetInfo(Proto_FileGetInfoQuery)
    /// Get a receipt for a transaction (lasts 180 seconds)
    case transactionGetReceipt(Proto_TransactionGetReceiptQuery)
    /// Get a record for a transaction (lasts 1 hour)
    case transactionGetRecord(Proto_TransactionGetRecordQuery)
    /// Get a record for a transaction (lasts 180 seconds)
    case transactionGetFastRecord(Proto_TransactionGetFastRecordQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_Query.OneOf_Query, rhs: Proto_Query.OneOf_Query) -> Bool {
      switch (lhs, rhs) {
      case (.getByKey(let l), .getByKey(let r)): return l == r
      case (.getBySolidityID(let l), .getBySolidityID(let r)): return l == r
      case (.contractCallLocal(let l), .contractCallLocal(let r)): return l == r
      case (.contractGetInfo(let l), .contractGetInfo(let r)): return l == r
      case (.contractGetBytecode(let l), .contractGetBytecode(let r)): return l == r
      case (.contractGetRecords(let l), .contractGetRecords(let r)): return l == r
      case (.cryptogetAccountBalance(let l), .cryptogetAccountBalance(let r)): return l == r
      case (.cryptoGetAccountRecords(let l), .cryptoGetAccountRecords(let r)): return l == r
      case (.cryptoGetInfo(let l), .cryptoGetInfo(let r)): return l == r
      case (.cryptoGetClaim(let l), .cryptoGetClaim(let r)): return l == r
      case (.cryptoGetProxyStakers(let l), .cryptoGetProxyStakers(let r)): return l == r
      case (.fileGetContents(let l), .fileGetContents(let r)): return l == r
      case (.fileGetInfo(let l), .fileGetInfo(let r)): return l == r
      case (.transactionGetReceipt(let l), .transactionGetReceipt(let r)): return l == r
      case (.transactionGetRecord(let l), .transactionGetRecord(let r)): return l == r
      case (.transactionGetFastRecord(let l), .transactionGetFastRecord(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Query"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getByKey"),
    2: .same(proto: "getBySolidityID"),
    3: .same(proto: "contractCallLocal"),
    4: .same(proto: "contractGetInfo"),
    5: .same(proto: "contractGetBytecode"),
    6: .same(proto: "ContractGetRecords"),
    7: .same(proto: "cryptogetAccountBalance"),
    8: .same(proto: "cryptoGetAccountRecords"),
    9: .same(proto: "cryptoGetInfo"),
    10: .same(proto: "cryptoGetClaim"),
    11: .same(proto: "cryptoGetProxyStakers"),
    12: .same(proto: "fileGetContents"),
    13: .same(proto: "fileGetInfo"),
    14: .same(proto: "transactionGetReceipt"),
    15: .same(proto: "transactionGetRecord"),
    16: .same(proto: "transactionGetFastRecord"),
  ]

  fileprivate class _StorageClass {
    var _query: Proto_Query.OneOf_Query?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _query = source._query
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Proto_GetByKeyQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .getByKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .getByKey(v)}
        case 2:
          var v: Proto_GetBySolidityIDQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .getBySolidityID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .getBySolidityID(v)}
        case 3:
          var v: Proto_ContractCallLocalQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .contractCallLocal(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .contractCallLocal(v)}
        case 4:
          var v: Proto_ContractGetInfoQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .contractGetInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .contractGetInfo(v)}
        case 5:
          var v: Proto_ContractGetBytecodeQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .contractGetBytecode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .contractGetBytecode(v)}
        case 6:
          var v: Proto_ContractGetRecordsQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .contractGetRecords(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .contractGetRecords(v)}
        case 7:
          var v: Proto_CryptoGetAccountBalanceQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .cryptogetAccountBalance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .cryptogetAccountBalance(v)}
        case 8:
          var v: Proto_CryptoGetAccountRecordsQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .cryptoGetAccountRecords(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .cryptoGetAccountRecords(v)}
        case 9:
          var v: Proto_CryptoGetInfoQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .cryptoGetInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .cryptoGetInfo(v)}
        case 10:
          var v: Proto_CryptoGetClaimQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .cryptoGetClaim(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .cryptoGetClaim(v)}
        case 11:
          var v: Proto_CryptoGetStakersQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .cryptoGetProxyStakers(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .cryptoGetProxyStakers(v)}
        case 12:
          var v: Proto_FileGetContentsQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .fileGetContents(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .fileGetContents(v)}
        case 13:
          var v: Proto_FileGetInfoQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .fileGetInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .fileGetInfo(v)}
        case 14:
          var v: Proto_TransactionGetReceiptQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .transactionGetReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .transactionGetReceipt(v)}
        case 15:
          var v: Proto_TransactionGetRecordQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .transactionGetRecord(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .transactionGetRecord(v)}
        case 16:
          var v: Proto_TransactionGetFastRecordQuery?
          if let current = _storage._query {
            try decoder.handleConflictingOneOf()
            if case .transactionGetFastRecord(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._query = .transactionGetFastRecord(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._query {
      case .getByKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .getBySolidityID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .contractCallLocal(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .contractGetInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .contractGetBytecode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .contractGetRecords(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .cryptogetAccountBalance(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .cryptoGetAccountRecords(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .cryptoGetInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .cryptoGetClaim(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .cryptoGetProxyStakers(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .fileGetContents(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .fileGetInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .transactionGetReceipt(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .transactionGetRecord(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .transactionGetFastRecord(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Query, rhs: Proto_Query) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._query != rhs_storage._query {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
