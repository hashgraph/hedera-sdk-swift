// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: CryptoGetInfo.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Get all the information about an account, including the balance. This does not get the list of account records. 
public struct Proto_CryptoGetInfoQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).
  public var header: Proto_QueryHeader {
    get {return _storage._header ?? Proto_QueryHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// The account ID for which information is requested
  public var accountID: Proto_AccountID {
    get {return _storage._accountID ?? Proto_AccountID()}
    set {_uniqueStorage()._accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return _storage._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Response when the client sends the node CryptoGetInfoQuery 
public struct Proto_CryptoGetInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
  public var header: Proto_ResponseHeader {
    get {return _storage._header ?? Proto_ResponseHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// Info about the account (a state proof can be generated for this)
  public var accountInfo: Proto_CryptoGetInfoResponse.AccountInfo {
    get {return _storage._accountInfo ?? Proto_CryptoGetInfoResponse.AccountInfo()}
    set {_uniqueStorage()._accountInfo = newValue}
  }
  /// Returns true if `accountInfo` has been explicitly set.
  public var hasAccountInfo: Bool {return _storage._accountInfo != nil}
  /// Clears the value of `accountInfo`. Subsequent reads from it will return its default value.
  public mutating func clearAccountInfo() {_uniqueStorage()._accountInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct AccountInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The account ID for which this information applies
    public var accountID: Proto_AccountID {
      get {return _storage._accountID ?? Proto_AccountID()}
      set {_uniqueStorage()._accountID = newValue}
    }
    /// Returns true if `accountID` has been explicitly set.
    public var hasAccountID: Bool {return _storage._accountID != nil}
    /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
    public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

    /// The Contract Account ID comprising of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity
    public var contractAccountID: String {
      get {return _storage._contractAccountID}
      set {_uniqueStorage()._contractAccountID = newValue}
    }

    /// If true, then this account has been deleted, it will disappear when it expires, and all transactions for it will fail except the transaction to extend its expiration date
    public var deleted: Bool {
      get {return _storage._deleted}
      set {_uniqueStorage()._deleted = newValue}
    }

    /// The Account ID of the account to which this is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking , or if it is not currently running a node, then it will behave as if proxyAccountID was null.
    public var proxyAccountID: Proto_AccountID {
      get {return _storage._proxyAccountID ?? Proto_AccountID()}
      set {_uniqueStorage()._proxyAccountID = newValue}
    }
    /// Returns true if `proxyAccountID` has been explicitly set.
    public var hasProxyAccountID: Bool {return _storage._proxyAccountID != nil}
    /// Clears the value of `proxyAccountID`. Subsequent reads from it will return its default value.
    public mutating func clearProxyAccountID() {_uniqueStorage()._proxyAccountID = nil}

    /// The total number of tinybars proxy staked to this account
    public var proxyReceived: Int64 {
      get {return _storage._proxyReceived}
      set {_uniqueStorage()._proxyReceived = newValue}
    }

    /// The key for the account, which must sign in order to transfer out, or to modify the account in any way other than extending its expiration date.
    public var key: Proto_Key {
      get {return _storage._key ?? Proto_Key()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {_uniqueStorage()._key = nil}

    /// The current balance of account in tinybars
    public var balance: UInt64 {
      get {return _storage._balance}
      set {_uniqueStorage()._balance = newValue}
    }

    /// The threshold amount (in tinybars) for which an account record is created (and this account charged for them) for any send/withdraw transaction.
    public var generateSendRecordThreshold: UInt64 {
      get {return _storage._generateSendRecordThreshold}
      set {_uniqueStorage()._generateSendRecordThreshold = newValue}
    }

    /// The threshold amount (in tinybars) for which an account record is created  (and this account charged for them) for any transaction above this amount.
    public var generateReceiveRecordThreshold: UInt64 {
      get {return _storage._generateReceiveRecordThreshold}
      set {_uniqueStorage()._generateReceiveRecordThreshold = newValue}
    }

    /// If true, no transaction can transfer to this account unless signed by this account's key
    public var receiverSigRequired: Bool {
      get {return _storage._receiverSigRequired}
      set {_uniqueStorage()._receiverSigRequired = newValue}
    }

    /// The TimeStamp time at which this account is set to expire
    public var expirationTime: Proto_Timestamp {
      get {return _storage._expirationTime ?? Proto_Timestamp()}
      set {_uniqueStorage()._expirationTime = newValue}
    }
    /// Returns true if `expirationTime` has been explicitly set.
    public var hasExpirationTime: Bool {return _storage._expirationTime != nil}
    /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
    public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

    /// The duration for expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If it is empty when it expires, then it is deleted.
    public var autoRenewPeriod: Proto_Duration {
      get {return _storage._autoRenewPeriod ?? Proto_Duration()}
      set {_uniqueStorage()._autoRenewPeriod = newValue}
    }
    /// Returns true if `autoRenewPeriod` has been explicitly set.
    public var hasAutoRenewPeriod: Bool {return _storage._autoRenewPeriod != nil}
    /// Clears the value of `autoRenewPeriod`. Subsequent reads from it will return its default value.
    public mutating func clearAutoRenewPeriod() {_uniqueStorage()._autoRenewPeriod = nil}

    /// All of the claims attached to the account (each of which is a hash along with the keys that authorized it and can delete it )
    public var claims: [Proto_Claim] {
      get {return _storage._claims}
      set {_uniqueStorage()._claims = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_CryptoGetInfoQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoGetInfoQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "accountID"),
  ]

  fileprivate class _StorageClass {
    var _header: Proto_QueryHeader? = nil
    var _accountID: Proto_AccountID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _accountID = source._accountID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._header)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._accountID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CryptoGetInfoQuery, rhs: Proto_CryptoGetInfoQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CryptoGetInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoGetInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "accountInfo"),
  ]

  fileprivate class _StorageClass {
    var _header: Proto_ResponseHeader? = nil
    var _accountInfo: Proto_CryptoGetInfoResponse.AccountInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _accountInfo = source._accountInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._header)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._accountInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._accountInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CryptoGetInfoResponse, rhs: Proto_CryptoGetInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._accountInfo != rhs_storage._accountInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CryptoGetInfoResponse.AccountInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proto_CryptoGetInfoResponse.protoMessageName + ".AccountInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountID"),
    2: .same(proto: "contractAccountID"),
    3: .same(proto: "deleted"),
    4: .same(proto: "proxyAccountID"),
    6: .same(proto: "proxyReceived"),
    7: .same(proto: "key"),
    8: .same(proto: "balance"),
    9: .same(proto: "generateSendRecordThreshold"),
    10: .same(proto: "generateReceiveRecordThreshold"),
    11: .same(proto: "receiverSigRequired"),
    12: .same(proto: "expirationTime"),
    13: .same(proto: "autoRenewPeriod"),
    14: .same(proto: "claims"),
  ]

  fileprivate class _StorageClass {
    var _accountID: Proto_AccountID? = nil
    var _contractAccountID: String = String()
    var _deleted: Bool = false
    var _proxyAccountID: Proto_AccountID? = nil
    var _proxyReceived: Int64 = 0
    var _key: Proto_Key? = nil
    var _balance: UInt64 = 0
    var _generateSendRecordThreshold: UInt64 = 0
    var _generateReceiveRecordThreshold: UInt64 = 0
    var _receiverSigRequired: Bool = false
    var _expirationTime: Proto_Timestamp? = nil
    var _autoRenewPeriod: Proto_Duration? = nil
    var _claims: [Proto_Claim] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _contractAccountID = source._contractAccountID
      _deleted = source._deleted
      _proxyAccountID = source._proxyAccountID
      _proxyReceived = source._proxyReceived
      _key = source._key
      _balance = source._balance
      _generateSendRecordThreshold = source._generateSendRecordThreshold
      _generateReceiveRecordThreshold = source._generateReceiveRecordThreshold
      _receiverSigRequired = source._receiverSigRequired
      _expirationTime = source._expirationTime
      _autoRenewPeriod = source._autoRenewPeriod
      _claims = source._claims
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accountID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._contractAccountID)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._deleted)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._proxyAccountID)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._proxyReceived)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 8: try decoder.decodeSingularUInt64Field(value: &_storage._balance)
        case 9: try decoder.decodeSingularUInt64Field(value: &_storage._generateSendRecordThreshold)
        case 10: try decoder.decodeSingularUInt64Field(value: &_storage._generateReceiveRecordThreshold)
        case 11: try decoder.decodeSingularBoolField(value: &_storage._receiverSigRequired)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._expirationTime)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._autoRenewPeriod)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._claims)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._contractAccountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contractAccountID, fieldNumber: 2)
      }
      if _storage._deleted != false {
        try visitor.visitSingularBoolField(value: _storage._deleted, fieldNumber: 3)
      }
      if let v = _storage._proxyAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._proxyReceived != 0 {
        try visitor.visitSingularInt64Field(value: _storage._proxyReceived, fieldNumber: 6)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._balance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._balance, fieldNumber: 8)
      }
      if _storage._generateSendRecordThreshold != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._generateSendRecordThreshold, fieldNumber: 9)
      }
      if _storage._generateReceiveRecordThreshold != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._generateReceiveRecordThreshold, fieldNumber: 10)
      }
      if _storage._receiverSigRequired != false {
        try visitor.visitSingularBoolField(value: _storage._receiverSigRequired, fieldNumber: 11)
      }
      if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._autoRenewPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._claims.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._claims, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CryptoGetInfoResponse.AccountInfo, rhs: Proto_CryptoGetInfoResponse.AccountInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._contractAccountID != rhs_storage._contractAccountID {return false}
        if _storage._deleted != rhs_storage._deleted {return false}
        if _storage._proxyAccountID != rhs_storage._proxyAccountID {return false}
        if _storage._proxyReceived != rhs_storage._proxyReceived {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._generateSendRecordThreshold != rhs_storage._generateSendRecordThreshold {return false}
        if _storage._generateReceiveRecordThreshold != rhs_storage._generateReceiveRecordThreshold {return false}
        if _storage._receiverSigRequired != rhs_storage._receiverSigRequired {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._autoRenewPeriod != rhs_storage._autoRenewPeriod {return false}
        if _storage._claims != rhs_storage._claims {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
