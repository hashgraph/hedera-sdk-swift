// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: CryptoDeleteClaim.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. 
public struct Proto_CryptoDeleteClaimTransactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account ID that should have a claim deleted
  public var accountIdtoDeleteFrom: Proto_AccountID {
    get {return _storage._accountIdtoDeleteFrom ?? Proto_AccountID()}
    set {_uniqueStorage()._accountIdtoDeleteFrom = newValue}
  }
  /// Returns true if `accountIdtoDeleteFrom` has been explicitly set.
  public var hasAccountIdtoDeleteFrom: Bool {return _storage._accountIdtoDeleteFrom != nil}
  /// Clears the value of `accountIdtoDeleteFrom`. Subsequent reads from it will return its default value.
  public mutating func clearAccountIdtoDeleteFrom() {_uniqueStorage()._accountIdtoDeleteFrom = nil}

  /// The hash in the claim to delete (a SHA-384 hash, 48 bytes)
  public var hashToDelete: Data {
    get {return _storage._hashToDelete}
    set {_uniqueStorage()._hashToDelete = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_CryptoDeleteClaimTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoDeleteClaimTransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountIDToDeleteFrom"),
    2: .same(proto: "hashToDelete"),
  ]

  fileprivate class _StorageClass {
    var _accountIdtoDeleteFrom: Proto_AccountID? = nil
    var _hashToDelete: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountIdtoDeleteFrom = source._accountIdtoDeleteFrom
      _hashToDelete = source._hashToDelete
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accountIdtoDeleteFrom)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._hashToDelete)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountIdtoDeleteFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._hashToDelete.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hashToDelete, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CryptoDeleteClaimTransactionBody, rhs: Proto_CryptoDeleteClaimTransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountIdtoDeleteFrom != rhs_storage._accountIdtoDeleteFrom {return false}
        if _storage._hashToDelete != rhs_storage._hashToDelete {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
