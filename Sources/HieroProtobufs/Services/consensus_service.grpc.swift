//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the protocol buffer compiler.
// Source: consensus_service.proto
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


///*
/// The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to
/// the order and validity of messages submitted to a *topic*, as well as a *consensus timestamp* for
/// those messages.
///
/// Automatic renewal can be configured via an autoRenewAccount.
/// Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must
/// be signed by the autoRenewAccount.
///
/// The autoRenewPeriod on an account must currently be set a value in createTopic between
/// MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During
/// creation this sets the initial expirationTime of the topic (see more below).
///
/// If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is
/// not allowed, and the only change allowed via an updateTopic is to extend the expirationTime.
///
/// If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the
/// adminKey, except for updateTopics which only extend the topic's expirationTime (no adminKey
/// authorization required).
///
/// If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic
/// must fulfill both the pre-update and post-update adminKey signature requirements.
///
/// Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to
/// the topic definition and the consensus ordering and timestamp of submitted messages.
///
/// Until autoRenew functionality is supported by HAPI, the topic will not expire, the
/// autoRenewAccount will not be charged, and the topic will not automatically be deleted.
///
/// Once autoRenew functionality is supported by HAPI:
///
/// 1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the
/// account will be charged automatically at the expirationTime, to extend the expirationTime of the
/// topic up to the topic's autoRenewPeriod (or as much extension as the account's balance will
/// supply).
///
/// 2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state.
/// All transactions on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that
/// modifies only the expirationTime.  getTopicInfo() will succeed. This state will be available for
/// a AUTORENEW_GRACE_PERIOD grace period (7 days).
///
/// 3. After the grace period, if the topic's expirationTime is not extended, the topic will be
/// automatically deleted and no transactions or queries on the topic will succeed after that point.
///
/// Usage: instantiate `Proto_ConsensusServiceClient`, then call methods of this protocol to make API calls.
public protocol Proto_ConsensusServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? { get }

  func createTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func updateTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func deleteTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func getTopicInfo(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Query, Proto_Response>

  func submitMessage(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>
}

extension Proto_ConsensusServiceClientProtocol {
  public var serviceName: String {
    return "proto.ConsensusService"
  }

  ///*
  /// Create a topic to be used for consensus.
  /// If an autoRenewAccount is specified, that account must also sign this transaction.
  /// If an adminKey is specified, the adminKey must sign the transaction.
  /// On success, the resulting TransactionReceipt contains the newly created TopicId.
  /// Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
  ///
  /// - Parameters:
  ///   - request: Request to send to createTopic.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func createTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
    )
  }

  ///*
  /// Update a topic.
  /// If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
  /// Otherwise transaction must be signed by the adminKey.
  /// If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
  /// If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
  /// Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
  ///
  /// - Parameters:
  ///   - request: Request to send to updateTopic.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func updateTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
    )
  }

  ///*
  /// Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
  /// If an adminKey is set, this transaction must be signed by that key.
  /// If there is no adminKey, this transaction will fail UNAUTHORIZED.
  /// Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
  ///
  /// - Parameters:
  ///   - request: Request to send to deleteTopic.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func deleteTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
    )
  }

  ///*
  /// Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
  /// Deleted accounts will not be returned.
  /// Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)
  /// Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
  ///
  /// - Parameters:
  ///   - request: Request to send to getTopicInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getTopicInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Query, Proto_Response> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
    )
  }

  ///*
  /// Submit a message for consensus.
  /// Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
  /// mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
  /// The submitKey (if any) must sign this transaction.
  /// On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and
  /// topicRunningHash.
  /// Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
  ///
  /// - Parameters:
  ///   - request: Request to send to submitMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func submitMessage(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension Proto_ConsensusServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Proto_ConsensusServiceNIOClient")
public final class Proto_ConsensusServiceClient: Proto_ConsensusServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the proto.ConsensusService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Proto_ConsensusServiceNIOClient: Proto_ConsensusServiceClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the proto.ConsensusService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

///*
/// The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to
/// the order and validity of messages submitted to a *topic*, as well as a *consensus timestamp* for
/// those messages.
///
/// Automatic renewal can be configured via an autoRenewAccount.
/// Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must
/// be signed by the autoRenewAccount.
///
/// The autoRenewPeriod on an account must currently be set a value in createTopic between
/// MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During
/// creation this sets the initial expirationTime of the topic (see more below).
///
/// If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is
/// not allowed, and the only change allowed via an updateTopic is to extend the expirationTime.
///
/// If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the
/// adminKey, except for updateTopics which only extend the topic's expirationTime (no adminKey
/// authorization required).
///
/// If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic
/// must fulfill both the pre-update and post-update adminKey signature requirements.
///
/// Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to
/// the topic definition and the consensus ordering and timestamp of submitted messages.
///
/// Until autoRenew functionality is supported by HAPI, the topic will not expire, the
/// autoRenewAccount will not be charged, and the topic will not automatically be deleted.
///
/// Once autoRenew functionality is supported by HAPI:
///
/// 1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the
/// account will be charged automatically at the expirationTime, to extend the expirationTime of the
/// topic up to the topic's autoRenewPeriod (or as much extension as the account's balance will
/// supply).
///
/// 2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state.
/// All transactions on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that
/// modifies only the expirationTime.  getTopicInfo() will succeed. This state will be available for
/// a AUTORENEW_GRACE_PERIOD grace period (7 days).
///
/// 3. After the grace period, if the topic's expirationTime is not extended, the topic will be
/// automatically deleted and no transactions or queries on the topic will succeed after that point.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Proto_ConsensusServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? { get }

  func makeCreateTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeUpdateTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeDeleteTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeGetTopicInfoCall(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response>

  func makeSubmitMessageCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Proto_ConsensusServiceAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Proto_ConsensusServiceClientMetadata.serviceDescriptor
  }

  public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeCreateTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
    )
  }

  public func makeUpdateTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
    )
  }

  public func makeDeleteTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
    )
  }

  public func makeGetTopicInfoCall(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
    )
  }

  public func makeSubmitMessageCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Proto_ConsensusServiceAsyncClientProtocol {
  public func createTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
    )
  }

  public func updateTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
    )
  }

  public func deleteTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
    )
  }

  public func getTopicInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_Response {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
    )
  }

  public func submitMessage(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Proto_ConsensusServiceAsyncClient: Proto_ConsensusServiceAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

public protocol Proto_ConsensusServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'createTopic'.
  func makecreateTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'updateTopic'.
  func makeupdateTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'deleteTopic'.
  func makedeleteTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'getTopicInfo'.
  func makegetTopicInfoInterceptors() -> [ClientInterceptor<Proto_Query, Proto_Response>]

  /// - Returns: Interceptors to use when invoking 'submitMessage'.
  func makesubmitMessageInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]
}

public enum Proto_ConsensusServiceClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "ConsensusService",
    fullName: "proto.ConsensusService",
    methods: [
      Proto_ConsensusServiceClientMetadata.Methods.createTopic,
      Proto_ConsensusServiceClientMetadata.Methods.updateTopic,
      Proto_ConsensusServiceClientMetadata.Methods.deleteTopic,
      Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo,
      Proto_ConsensusServiceClientMetadata.Methods.submitMessage,
    ]
  )

  public enum Methods {
    public static let createTopic = GRPCMethodDescriptor(
      name: "createTopic",
      path: "/proto.ConsensusService/createTopic",
      type: GRPCCallType.unary
    )

    public static let updateTopic = GRPCMethodDescriptor(
      name: "updateTopic",
      path: "/proto.ConsensusService/updateTopic",
      type: GRPCCallType.unary
    )

    public static let deleteTopic = GRPCMethodDescriptor(
      name: "deleteTopic",
      path: "/proto.ConsensusService/deleteTopic",
      type: GRPCCallType.unary
    )

    public static let getTopicInfo = GRPCMethodDescriptor(
      name: "getTopicInfo",
      path: "/proto.ConsensusService/getTopicInfo",
      type: GRPCCallType.unary
    )

    public static let submitMessage = GRPCMethodDescriptor(
      name: "submitMessage",
      path: "/proto.ConsensusService/submitMessage",
      type: GRPCCallType.unary
    )
  }
}

